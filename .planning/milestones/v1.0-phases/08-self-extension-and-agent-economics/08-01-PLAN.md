---
phase: 08-self-extension-and-agent-economics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/agent-migrations.ts
  - packages/db/src/schema/index.ts
  - packages/db/drizzle.config.ts
  - packages/tools/package.json
  - packages/tools/src/self-extension/compiler.ts
  - packages/tools/src/self-extension/sandbox-runner.ts
  - packages/tools/src/self-extension/tool-loader.ts
  - packages/tools/src/self-extension/sandbox-harness.ts
autonomous: true
requirements:
  - EXTEND-01
  - EXTEND-02
  - EXTEND-05

must_haves:
  truths:
    - "Valid TypeScript source compiles to runnable JavaScript. Invalid TypeScript returns a descriptive error. No disk I/O during compilation step."
    - "Compiled JavaScript runs in a forked child process isolated from the parent — child crash does not affect parent"
    - "Sandbox runner returns a structured SandboxResult with passed/output/error, never throws to caller"
    - "Agent-authored tool .js files in agent-tools/ directory are loaded into the ToolRegistry on startup"
    - "agent_migrations table exists in the database and tracks applied DDL migrations"
  artifacts:
    - path: "packages/db/src/schema/agent-migrations.ts"
      provides: "agent_migrations Drizzle schema table"
      contains: "agent_migrations"
    - path: "packages/tools/src/self-extension/compiler.ts"
      provides: "compileTypeScript() function using esbuild.transform"
      exports: ["compileTypeScript"]
    - path: "packages/tools/src/self-extension/sandbox-runner.ts"
      provides: "runInSandbox() function using child_process.fork"
      exports: ["runInSandbox"]
    - path: "packages/tools/src/self-extension/tool-loader.ts"
      provides: "loadPersistedTools() for startup loading from disk"
      exports: ["loadPersistedTools"]
    - path: "packages/tools/src/self-extension/sandbox-harness.ts"
      provides: "Child process entry point that imports tool, runs execute(), sends result via IPC"
  key_links:
    - from: "packages/tools/src/self-extension/sandbox-runner.ts"
      to: "packages/tools/src/self-extension/sandbox-harness.ts"
      via: "child_process.fork with temp .mjs file importing harness"
      pattern: "fork.*sandbox-harness"
    - from: "packages/tools/src/self-extension/tool-loader.ts"
      to: "packages/tools/src/registry.ts"
      via: "dynamic import + registry.register()"
      pattern: "registry\\.register"
    - from: "packages/db/src/schema/agent-migrations.ts"
      to: "packages/db/drizzle.config.ts"
      via: "schema array entry"
      pattern: "agent-migrations"
---

<objective>
Create the foundation infrastructure for agent self-extension: the agent_migrations database schema table, TypeScript compilation via esbuild, process-isolated sandbox execution via child_process.fork, and startup tool loading from disk.

Purpose: Provides the three core building blocks that Plans 02-04 build upon — compile TS to JS, test code safely in isolation, and persist/load tools across restarts.
Output: 4 new source files in self-extension/, 1 new schema file, updated drizzle config, esbuild + simple-git added as deps.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-self-extension-and-agent-economics/08-RESEARCH.md
@.planning/phases/08-self-extension-and-agent-economics/08-CONTEXT.md
@packages/tools/src/types.ts
@packages/tools/src/registry.ts
@packages/tools/src/index.ts
@packages/tools/package.json
@packages/db/src/schema/goals.ts
@packages/db/src/schema/index.ts
@packages/db/drizzle.config.ts
@packages/db/src/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: agent_migrations schema + install esbuild and simple-git</name>
  <files>
    packages/db/src/schema/agent-migrations.ts
    packages/db/src/schema/index.ts
    packages/db/drizzle.config.ts
    packages/tools/package.json
  </files>
  <action>
1. Create `packages/db/src/schema/agent-migrations.ts`:
   - pgTable('agent_migrations') with columns:
     - `id`: integer, primaryKey, generatedAlwaysAsIdentity
     - `migrationName`: text('migration_name'), notNull, unique — human-readable name like 'create_agent_x402_transactions'
     - `sqlExecuted`: text('sql_executed'), notNull — the exact DDL SQL for audit/re-creation
     - `appliedAt`: timestamp('applied_at'), defaultNow, notNull
   - Export types: AgentMigration (inferSelect), NewAgentMigration (inferInsert)
   - Follow existing schema style (see goals.ts for reference)

2. Update `packages/db/src/schema/index.ts`:
   - Add `export * from './agent-migrations.js';`

3. Update `packages/db/drizzle.config.ts`:
   - Add `'./src/schema/agent-migrations.ts'` to the schema array
   - Note: agent-migrations.ts has NO FK references to other tables, so it does NOT need to be co-located with anything

4. Add esbuild and simple-git to @jarvis/tools:
   - Run `pnpm add esbuild simple-git --filter @jarvis/tools`
   - Verify with `pnpm why esbuild --filter @jarvis/tools` (esbuild may already exist as transitive dep via tsx — still needs to be explicit per pnpm strict isolation)

5. Run `pnpm db:push` to apply the new agent_migrations table to the database, then run `pnpm build --filter @jarvis/db` to compile the schema changes.
  </action>
  <verify>
    - `pnpm build --filter @jarvis/db` succeeds (schema compiles)
    - `pnpm db:push` succeeds (table created in Postgres)
    - `pnpm why esbuild --filter @jarvis/tools` shows direct dependency
    - `pnpm why simple-git --filter @jarvis/tools` shows direct dependency
  </verify>
  <done>agent_migrations table exists in Postgres. esbuild and simple-git are direct deps of @jarvis/tools.</done>
</task>

<task type="auto">
  <name>Task 2: TypeScript compiler, sandbox runner, sandbox harness, and tool loader</name>
  <files>
    packages/tools/src/self-extension/compiler.ts
    packages/tools/src/self-extension/sandbox-runner.ts
    packages/tools/src/self-extension/sandbox-harness.ts
    packages/tools/src/self-extension/tool-loader.ts
  </files>
  <action>
1. Create `packages/tools/src/self-extension/compiler.ts`:
   - Export `async function compileTypeScript(tsSource: string): Promise<{ code: string; warnings: string[] }>`
   - Uses `esbuild.transform(tsSource, { loader: 'ts', format: 'esm', target: 'node20', platform: 'node' })`
   - If result.errors.length > 0, throw Error with concatenated error texts
   - Return `{ code: result.code, warnings: result.warnings.map(w => w.text) }`
   - Import esbuild with `import * as esbuild from 'esbuild';`

2. Create `packages/tools/src/self-extension/sandbox-harness.ts`:
   - This is the child process entry point, NOT a tool. It receives IPC messages and runs tool execute().
   - The sandbox-runner writes a temp `.mjs` file that imports the compiled tool JS and this harness logic. The harness pattern is:
     - Listen for IPC message with `{ action: 'run', toolPath: string, testInput: unknown }`
     - Dynamic import the tool from `toolPath`: `const mod = await import(toolPath)`
     - Extract tool definition: `const tool = mod.default ?? mod.tool` (ToolDefinition)
     - If no tool found, send error result via `process.send()` and exit(1)
     - Call `tool.execute(testInput, new AbortController().signal)` wrapped in try/catch
     - On success: `process.send({ passed: true, output: result })` then exit(0)
     - On error: `process.send({ passed: false, error: err.message ?? String(err) })` then exit(1)
   - Export the harness entry function so it can be embedded in the temp file by sandbox-runner

   IMPORTANT: Since fork() requires a file path and this harness needs to be importable, the actual approach is:
   - sandbox-harness.ts exports a `HARNESS_SCRIPT` string template that sandbox-runner inlines into the temp .mjs file
   - The template receives the toolPath as a variable injected at write time
   - Pattern: the temp .mjs file IS the harness — it imports the tool, runs execute, sends IPC result
   - This avoids needing sandbox-harness.ts to be separately compiled/resolved at runtime

   So sandbox-harness.ts should export:
   ```
   export function generateHarnessScript(toolJsPath: string, testInput: unknown): string
   ```
   Returns a complete .mjs script string that:
   - Imports the tool from the absolute toolJsPath
   - Runs execute with the serialized testInput
   - Sends result via process.send()
   - Handles errors with try/catch
   - Exits with appropriate code

3. Create `packages/tools/src/self-extension/sandbox-runner.ts`:
   - Export interface `SandboxResult { passed: boolean; output?: unknown; error?: string }`
   - Export `async function runInSandbox(compiledJs: string, toolName: string, testInput: unknown, timeoutMs?: number): Promise<SandboxResult>`
   - Default timeoutMs = 30_000
   - Steps:
     a. Write compiledJs to temp file: `/tmp/sandbox-${toolName}-${Date.now()}.mjs`
     b. Generate harness script using `generateHarnessScript()` with the temp tool path and testInput
     c. Write harness to separate temp file: `/tmp/sandbox-harness-${toolName}-${Date.now()}.mjs`
     d. Fork the harness file: `fork(harnessPath, [], { silent: true, execArgv: [] })`
     e. Collect IPC messages via `child.on('message', ...)`
     f. Set timeout — on timeout, kill child with SIGKILL, resolve with `{ passed: false, error: 'Sandbox timeout after Xms' }`
     g. On exit code 0: resolve with `{ passed: true, output: messages[0] }` (first IPC message is the result)
     h. On exit code != 0: resolve with `{ passed: false, error: ... }`
     i. On 'error' event: resolve with `{ passed: false, error: err.message }`
     j. ALWAYS clean up both temp files in a finally/exit handler (wrap unlinkSync in try/catch)
   - Import fork from 'node:child_process', writeFileSync/unlinkSync from 'node:fs', path from 'node:path'
   - Per locked decision: never throws — always returns SandboxResult

4. Create `packages/tools/src/self-extension/tool-loader.ts`:
   - Export `const AGENT_TOOLS_DIR = path.join(process.cwd(), 'agent-tools');`
   - Export `async function loadPersistedTools(registry: ToolRegistry): Promise<{ loaded: string[]; failed: string[] }>`
   - Steps:
     a. Try to read AGENT_TOOLS_DIR with readdirSync — if directory doesn't exist, return `{ loaded: [], failed: [] }` (first run)
     b. Filter for `.mjs` files (compiled JS — NOT .ts source files)
     c. For each .mjs file:
        - Dynamic import with cache-busting: `import(\`file://${absPath}?v=${Date.now()}\`)`
        - Extract tool: `mod.default ?? mod.tool`
        - If no valid tool definition (missing name), skip and add to failed
        - `registry.unregister(tool.name)` first (safe if not registered — returns false)
        - `registry.register(tool)` to add to registry
        - Add to loaded list
     d. On error per file: log to stderr with `[tool-loader] Failed to load ${file}: ${err}`, add to failed, continue
   - Import type ToolRegistry from '../registry.js', type ToolDefinition from '../types.js'
   - Import readdirSync from 'node:fs', path from 'node:path'

Note on file extensions: Agent-authored tools are persisted as `.ts` (source for reference) and `.mjs` (compiled JS for import). The loader reads only `.mjs` files. The `.ts` file is for agent inspection and future modifications.
  </action>
  <verify>
    - `pnpm build --filter @jarvis/tools` succeeds (all 4 new files compile)
    - Manual verification: the compiler, sandbox-runner, sandbox-harness, and tool-loader modules exist in dist/self-extension/
  </verify>
  <done>compileTypeScript() compiles TS strings to JS. runInSandbox() forks a child process to test compiled code safely. generateHarnessScript() creates the child process entry script. loadPersistedTools() loads .mjs files from agent-tools/ into the registry on startup.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds across entire workspace (no breakage in dependent packages)
- `packages/db/src/schema/agent-migrations.ts` exports agentMigrations table and types
- `packages/tools/src/self-extension/compiler.ts` exports compileTypeScript
- `packages/tools/src/self-extension/sandbox-runner.ts` exports runInSandbox and SandboxResult
- `packages/tools/src/self-extension/tool-loader.ts` exports loadPersistedTools and AGENT_TOOLS_DIR
- No changes to existing tool implementations or registry behavior
</verification>

<success_criteria>
The three core self-extension building blocks exist and compile: TypeScript-to-JS compiler, process-isolated sandbox runner, and startup tool loader. The agent_migrations table is in the database and drizzle schema. esbuild and simple-git are installed as direct deps.
</success_criteria>

<output>
After completion, create `.planning/phases/08-self-extension-and-agent-economics/08-01-SUMMARY.md`
</output>
