---
phase: 02-ai-backbone-and-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/ai-calls.ts
  - packages/db/src/schema/operating-costs.ts
  - packages/db/src/schema/revenue.ts
  - packages/db/src/schema/kill-switch-audit.ts
  - packages/db/src/schema/index.ts
  - packages/db/drizzle.config.ts
  - packages/ai/package.json
  - packages/ai/tsconfig.json
  - packages/ai/src/provider.ts
  - packages/ai/src/openrouter.ts
  - packages/ai/src/config.ts
  - packages/ai/src/kill-switch.ts
  - packages/ai/src/router.ts
  - packages/ai/src/index.ts
autonomous: true
requirements: [MODL-01, MODL-02, MODL-03, MODL-04, MODL-05, KILL-02, KILL-04, COST-01]

must_haves:
  truths:
    - "ModelRouter resolves tier names (strong/mid/cheap) to concrete OpenRouter model IDs"
    - "Every AI completion call is logged to ai_calls table with model, tier, tokens, and cost"
    - "KillSwitchGuard reads kill switch state from agent_state table and caches it for 1 second"
    - "ModelRouter calls KillSwitchGuard.assertActive() before dispatching any AI call"
    - "OpenRouterProvider uses the openai SDK pointed at https://openrouter.ai/api/v1"
    - "Adding a new provider means implementing AiProvider interface -- no router changes needed"
  artifacts:
    - path: "packages/db/src/schema/ai-calls.ts"
      provides: "ai_calls table schema for per-call AI usage logging"
      contains: "pgTable('ai_calls'"
    - path: "packages/db/src/schema/operating-costs.ts"
      provides: "operating_costs table with cost_category enum"
      contains: "pgTable('operating_costs'"
    - path: "packages/db/src/schema/revenue.ts"
      provides: "revenue table for strategy P&L tracking"
      contains: "pgTable('revenue'"
    - path: "packages/db/src/schema/kill-switch-audit.ts"
      provides: "kill_switch_audit table for activation/deactivation history"
      contains: "pgTable('kill_switch_audit'"
    - path: "packages/ai/src/provider.ts"
      provides: "AiProvider interface, CompletionRequest, CompletionResponse, CompletionUsage types"
      exports: ["AiProvider", "CompletionRequest", "CompletionResponse", "CompletionUsage"]
    - path: "packages/ai/src/openrouter.ts"
      provides: "OpenRouterProvider implementing AiProvider via openai SDK"
      contains: "implements AiProvider"
    - path: "packages/ai/src/router.ts"
      provides: "ModelRouter class with tier resolution, kill switch check, and AI call logging"
      exports: ["ModelRouter", "Tier"]
    - path: "packages/ai/src/kill-switch.ts"
      provides: "KillSwitchGuard with 1-second DB cache and KillSwitchActiveError"
      exports: ["KillSwitchGuard", "KillSwitchActiveError"]
    - path: "packages/ai/src/config.ts"
      provides: "ModelTierConfig type and Zod-validated config loader"
      exports: ["ModelTierConfig", "loadModelConfig"]
  key_links:
    - from: "packages/ai/src/router.ts"
      to: "packages/ai/src/kill-switch.ts"
      via: "this.killSwitch.assertActive() call before completion"
      pattern: "killSwitch\\.assertActive"
    - from: "packages/ai/src/router.ts"
      to: "packages/ai/src/provider.ts"
      via: "this.provider.complete(req) delegation"
      pattern: "provider\\.complete"
    - from: "packages/ai/src/router.ts"
      to: "packages/db/src/schema/ai-calls.ts"
      via: "insert into aiCalls after each completion"
      pattern: "aiCalls"
    - from: "packages/ai/src/kill-switch.ts"
      to: "packages/db/src/schema/agent-state.ts"
      via: "query agentState where key = 'kill_switch'"
      pattern: "kill_switch"
    - from: "packages/ai/src/openrouter.ts"
      to: "openai SDK"
      via: "new OpenAI({ baseURL: 'https://openrouter.ai/api/v1' })"
      pattern: "openrouter\\.ai/api/v1"
---

<objective>
Create the Phase 2 data layer (4 new DB schema tables) and the complete @jarvis/ai package containing the AiProvider interface, OpenRouterProvider, ModelTierConfig, KillSwitchGuard, and ModelRouter. This is the foundation for all AI routing, safety enforcement, and cost tracking.

Purpose: The agent needs a type-safe AI routing layer that resolves task tiers to concrete model IDs, enforces the kill switch before every AI call, and logs every completion with token counts and cost. All downstream plans (CLI, tool gate, cost monitoring) depend on this package.

Output: 4 new DB tables pushed to Postgres, @jarvis/ai package compiles and exports all types/classes.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ai-backbone-and-safety/02-CONTEXT.md
@.planning/phases/02-ai-backbone-and-safety/02-RESEARCH.md
@.planning/phases/01-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-infrastructure/01-04-SUMMARY.md
@packages/db/src/schema/agent-state.ts
@packages/db/src/schema/index.ts
@packages/db/src/index.ts
@packages/db/drizzle.config.ts
@packages/db/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 4 new DB schema tables and push to Postgres</name>
  <files>
    packages/db/src/schema/ai-calls.ts
    packages/db/src/schema/operating-costs.ts
    packages/db/src/schema/revenue.ts
    packages/db/src/schema/kill-switch-audit.ts
    packages/db/src/schema/index.ts
    packages/db/drizzle.config.ts
  </files>
  <action>
    Create 4 new schema files in packages/db/src/schema/:

    **ai-calls.ts** (MODL-02, COST-01):
    - Table `ai_calls` with columns: id (integer, PK, generatedAlwaysAsIdentity), model (varchar 128, notNull), tier (varchar 32, notNull -- 'strong'|'mid'|'cheap'), promptTokens (integer, notNull), completionTokens (integer, notNull), costUsd (numeric precision 12 scale 8, notNull -- financial values use exact decimal, not float), goalId (integer, nullable -- optional link to planning cycle), createdAt (timestamp, defaultNow, notNull)
    - Export type aliases: AiCall, NewAiCall

    **operating-costs.ts** (COST-02):
    - Create pgEnum `cost_category` with values: 'ai_inference', 'vm', 'api_service', 'other'
    - Table `operating_costs` with columns: id (integer, PK, generatedAlwaysAsIdentity), category (costCategoryEnum, notNull), amountUsd (numeric precision 12 scale 8, notNull), description (text, nullable), periodStart (timestamp, notNull), periodEnd (timestamp, notNull), createdAt (timestamp, defaultNow, notNull)
    - Export the enum and type aliases

    **revenue.ts** (COST-03 -- schema only, populated in later phases):
    - Table `revenue` with columns: id (integer, PK, generatedAlwaysAsIdentity), strategyId (text, notNull), sourceAttribution (text, nullable), amountUsd (numeric precision 12 scale 8, notNull), earnedAt (timestamp, defaultNow, notNull), createdAt (timestamp, defaultNow, notNull)
    - Export type aliases

    **kill-switch-audit.ts** (KILL-01 audit trail):
    - Table `kill_switch_audit` with columns: id (integer, PK, generatedAlwaysAsIdentity), action (text, notNull -- 'activate'|'deactivate'), reason (text, notNull), triggeredBy (text, notNull -- 'cli'|'api'|'agent'), createdAt (timestamp, defaultNow, notNull)
    - Export type aliases

    **Update schema/index.ts**: Add 4 new `export * from './xxx.js'` lines for the new schema files.

    **Update drizzle.config.ts**: Add 4 new schema file paths to the explicit array (following established pattern -- individual .ts files, not barrel).

    **Run db:push**: Execute `DATABASE_URL=postgres://jarvis:jarvis@localhost:5433/jarvis pnpm --filter @jarvis/db run db:push` to create the tables in Postgres.

    Follow existing schema patterns exactly: use `drizzle-orm/pg-core` imports, integer() for IDs with generatedAlwaysAsIdentity(), timestamp() with defaultNow().notNull() for createdAt. Use `numeric` (not `real`) for USD amounts -- financial precision matters.
  </action>
  <verify>
    1. `pnpm --filter @jarvis/db run build` exits 0 (TypeScript compiles)
    2. `DATABASE_URL=postgres://jarvis:jarvis@localhost:5433/jarvis pnpm --filter @jarvis/db run db:push` exits 0 (tables created)
    3. Verify tables exist: `docker exec jarvis-postgres psql -U jarvis -d jarvis -c "\dt"` shows ai_calls, operating_costs, revenue, kill_switch_audit
  </verify>
  <done>
    4 new tables exist in Postgres (ai_calls, operating_costs, revenue, kill_switch_audit). Schema types exported from @jarvis/db. drizzle.config.ts lists all 9 schema files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create @jarvis/ai package with provider, router, kill switch, and config</name>
  <files>
    packages/ai/package.json
    packages/ai/tsconfig.json
    packages/ai/src/provider.ts
    packages/ai/src/openrouter.ts
    packages/ai/src/config.ts
    packages/ai/src/kill-switch.ts
    packages/ai/src/router.ts
    packages/ai/src/index.ts
  </files>
  <action>
    Create the `packages/ai` directory and all source files:

    **package.json**: name "@jarvis/ai", version "0.0.1", type "module", main "dist/index.js", types "dist/index.d.ts". Dependencies: @jarvis/db (workspace:*), openai (^4.x), zod (^3.24.x). DevDependencies: @jarvis/typescript-config (workspace:*), typescript (^5.7.3). Scripts: build (tsc).

    **tsconfig.json**: Extends @jarvis/typescript-config/base.json, compilerOptions outDir "dist", rootDir "src". Include ["src"].

    **provider.ts** (MODL-05 -- generic interface):
    - Export interface `CompletionRequest` with: messages (Array of {role: 'system'|'user'|'assistant', content: string}), model (string -- exact OpenRouter model ID), temperature (optional number), maxTokens (optional number).
    - Export interface `CompletionUsage` with: promptTokens (number), completionTokens (number), totalTokens (number), costUsd (number -- from OpenRouter response.usage.cost).
    - Export interface `CompletionResponse` with: content (string), model (string -- actual model used), usage (CompletionUsage).
    - Export interface `AiProvider` with: complete(req: CompletionRequest): Promise<CompletionResponse>.
    - These are pure TypeScript interfaces -- no runtime code, no dependencies.

    **openrouter.ts** (MODL-05 -- first provider implementation):
    - Import OpenAI from 'openai' (default import).
    - Class `OpenRouterProvider` implements AiProvider.
    - Constructor takes apiKey (string). Creates OpenAI client with baseURL 'https://openrouter.ai/api/v1', apiKey, defaultHeaders: { 'HTTP-Referer': 'https://jarvis.internal', 'X-Title': 'Jarvis Agent' }.
    - complete() method: calls this.client.chat.completions.create({ model, messages, temperature, max_tokens, stream: false }). Extracts choice[0].message.content. Extracts usage from response.usage! -- note that the `cost` field is an OpenRouter extension not in the OpenAI SDK types, so cast: `(usage as unknown as { cost?: number }).cost ?? 0`. Returns CompletionResponse.
    - Add support for OpenRouter model fallback per research: accept optional `fallbackModel` in constructor config. If set, pass via extra body: `// @ts-expect-error -- OpenRouter extension not in openai SDK types` then `(requestBody as Record<string, unknown>).models = [req.model, this.fallbackModel]`. Actually, simpler: use the openai SDK's `body` spread or just pass the primary model. Per research recommendation, keep it simple -- use single model per request. OpenRouter handles provider-level failover internally for the same model ID.

    **config.ts** (runtime configurable model mapping):
    - Export type `Tier` = 'strong' | 'mid' | 'cheap'.
    - Export interface `ModelTierConfig` with: strong (string), mid (string), cheap (string).
    - Export const `modelTierConfigSchema` = z.object({ strong: z.string(), mid: z.string(), cheap: z.string() }) -- Zod validation.
    - Export function `loadModelConfig()`: reads from environment variables JARVIS_MODEL_STRONG, JARVIS_MODEL_MID, JARVIS_MODEL_CHEAP. Falls back to defaults: strong='anthropic/claude-opus-4.6', mid='anthropic/claude-sonnet-4.5', cheap='x-ai/grok-4.1-fast' (per user decision). Validates with Zod schema. Returns ModelTierConfig.
    - Using env vars per research recommendation (Claude's Discretion: env vars, not DB storage). Models are swappable without redeploy by changing env vars and restarting.

    **kill-switch.ts** (KILL-02, KILL-04):
    - Import DbClient from @jarvis/db (not drizzle-orm directly -- pnpm strict isolation).
    - Import agentState, eq from @jarvis/db.
    - Export class `KillSwitchActiveError` extends Error with name 'KillSwitchActiveError'.
    - Export class `KillSwitchGuard`:
      - Private cachedState: { active: boolean; expiresAt: number } | null = null
      - Private readonly TTL_MS = 1000 (1-second cache)
      - Constructor takes db: DbClient
      - async isActive(): Promise<boolean> -- checks cache first (if not null and now < expiresAt, return cached). Otherwise queries: `db.select().from(agentState).where(eq(agentState.key, 'kill_switch')).limit(1)`. Parses row.value as `{ active?: boolean }`. Sets cache. Returns active boolean.
      - async assertActive(): Promise<void> -- if await isActive() is true, throws new KillSwitchActiveError('Kill switch is active. No new operations allowed.').
      - clearCache(): void -- sets cachedState to null (useful for testing).

    **router.ts** (MODL-01, MODL-02, MODL-03, MODL-04):
    - Import types from provider.ts, config.ts, kill-switch.ts.
    - Import DbClient, aiCalls from @jarvis/db.
    - Export class `ModelRouter`:
      - Constructor takes: provider (AiProvider), config (ModelTierConfig), db (DbClient), killSwitch (KillSwitchGuard).
      - async complete(messages: CompletionRequest['messages'], tier: Tier, context?: { goalId?: number }): Promise<CompletionResponse>:
        1. await this.killSwitch.assertActive() -- KILL-02
        2. const modelId = this.config[tier] -- MODL-01 tier resolution
        3. const req: CompletionRequest = { messages, model: modelId }
        4. const response = await this.provider.complete(req)
        5. Log to ai_calls: await db.insert(aiCalls).values({ model: response.model, tier, promptTokens: response.usage.promptTokens, completionTokens: response.usage.completionTokens, costUsd: response.usage.costUsd.toString(), goalId: context?.goalId ?? null }) -- MODL-02, COST-01. Note: numeric columns receive string values in drizzle.
        6. return response

    **index.ts** (barrel exports):
    - Export everything from provider.ts, openrouter.ts, config.ts, kill-switch.ts, router.ts.
    - Export a convenience factory: `createRouter(db: DbClient, apiKey: string): ModelRouter` that wires everything together (creates OpenRouterProvider, loads config, creates KillSwitchGuard, returns new ModelRouter).

    Run `pnpm install` from root to link the new workspace package. Then `pnpm --filter @jarvis/ai run build` to verify compilation.

    IMPORTANT pnpm strict isolation rules:
    - @jarvis/ai can import from @jarvis/db (direct dep) but NOT from drizzle-orm directly
    - Use eq, agentState, aiCalls etc. from @jarvis/db
    - The `openai` package is a direct dep of @jarvis/ai, so it CAN be imported directly
  </action>
  <verify>
    1. `pnpm install` exits 0 (workspace linked)
    2. `pnpm --filter @jarvis/ai run build` exits 0 (TypeScript compiles with no errors)
    3. Verify exports: `node -e "import('@jarvis/ai').then(m => console.log(Object.keys(m)))"` -- should not error (or use tsx to test imports)
  </verify>
  <done>
    @jarvis/ai package exists with: AiProvider interface (MODL-05), OpenRouterProvider (openai SDK pointed at OpenRouter), ModelRouter (tier resolution + kill switch check + ai_calls logging), KillSwitchGuard (1-second cached DB check), loadModelConfig() (env-var based with defaults matching user decision). Package compiles cleanly.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter @jarvis/db run build && pnpm --filter @jarvis/ai run build` both exit 0
- All 9 schema files listed in drizzle.config.ts
- All 4 new tables exist in Postgres
- @jarvis/ai exports: AiProvider, OpenRouterProvider, ModelRouter, KillSwitchGuard, KillSwitchActiveError, CompletionRequest, CompletionResponse, CompletionUsage, Tier, ModelTierConfig, loadModelConfig, createRouter
</verification>

<success_criteria>
- 4 new DB tables (ai_calls, operating_costs, revenue, kill_switch_audit) exist in Postgres
- @jarvis/ai package compiles and exports all types and classes
- ModelRouter resolves strong/mid/cheap to configured model IDs
- KillSwitchGuard reads from agent_state and caches for 1 second
- OpenRouterProvider wraps openai SDK pointed at OpenRouter
- No direct drizzle-orm imports in @jarvis/ai (all via @jarvis/db)
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-backbone-and-safety/02-01-SUMMARY.md`
</output>
