---
phase: 03-autonomous-loop
plan: 03
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - apps/agent/src/multi-agent/sub-agent-tool.ts
  - apps/agent/src/multi-agent/agent-worker.ts
autonomous: true
requirements:
  - MULTI-01
  - MULTI-02
  - MULTI-03
  - MULTI-04
  - MULTI-05

must_haves:
  truths:
    - "Main agent can spawn a sub-agent by calling the spawn-agent tool, receiving a jobId"
    - "Sub-agents execute with isolated LLM context (fresh message array per job)"
    - "Sub-agents report structured results back via BullMQ job return value"
    - "Main agent can cancel a running sub-agent by jobId"
    - "Sub-agents share the same ModelRouter instance (shared cost pool via ai_calls logging) while maintaining isolated LLM contexts"
  artifacts:
    - path: "apps/agent/src/multi-agent/sub-agent-tool.ts"
      provides: "spawn-agent, await-agent, cancel-agent tool definitions"
      exports: ["createSpawnAgentTool", "createAwaitAgentTool", "createCancelAgentTool"]
    - path: "apps/agent/src/multi-agent/agent-worker.ts"
      provides: "BullMQ worker for agent-tasks queue processing sub-agent jobs"
      exports: ["createAgentWorker"]
  key_links:
    - from: "apps/agent/src/multi-agent/sub-agent-tool.ts"
      to: "bullmq Queue"
      via: "queue.add('sub-agent', { task, context }) for spawning"
      pattern: "queue\\.add"
    - from: "apps/agent/src/multi-agent/agent-worker.ts"
      to: "packages/ai/src/router.ts"
      via: "ModelRouter.completeWithTools for sub-agent LLM loop"
      pattern: "router\\.completeWithTools"
    - from: "apps/agent/src/multi-agent/sub-agent-tool.ts"
      to: "apps/agent/src/multi-agent/agent-worker.ts"
      via: "BullMQ agent-tasks queue connects tool to worker"
      pattern: "agent-tasks"
---

<objective>
Create the sub-agent spawning tools and the BullMQ worker that processes sub-agent jobs. This enables the main agent to delegate tasks to independent sub-agents that run their own LLM tool-calling loops with isolated context.

Purpose: Sub-agent spawning is a first-class tool (locked decision). The main agent decides when to delegate vs execute inline. Sub-agents enable parallelism and context isolation.
Output: Three tool definitions (spawn-agent, await-agent, cancel-agent) and a BullMQ worker that executes sub-agent jobs with isolated LLM context.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-autonomous-loop/03-RESEARCH.md
@.planning/phases/03-autonomous-loop/03-01-SUMMARY.md

@packages/tools/src/types.ts
@packages/tools/src/registry.ts
@packages/tools/src/invoke-safe.ts
@packages/ai/src/router.ts
@packages/ai/src/provider.ts
@packages/ai/src/tool-schema.ts
@apps/agent/src/worker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create spawn-agent, await-agent, and cancel-agent tool definitions</name>
  <files>apps/agent/src/multi-agent/sub-agent-tool.ts</files>
  <action>
Create `apps/agent/src/multi-agent/sub-agent-tool.ts`:

Import Queue from bullmq, z from zod, ToolDefinition from @jarvis/tools.

Export function `createSpawnAgentTool(queue: Queue): ToolDefinition`:
- name: 'spawn-agent'
- description: 'Spawn a focused sub-agent to execute a scoped task concurrently. Returns a jobId to track the sub-agent. Use this for tasks that are complex enough to warrant isolated context OR can run in parallel with other work. Do NOT spawn sub-agents for simple, fast tasks — execute those inline.'
- inputSchema: z.object({
    task: z.string().describe('Clear task description with objectives and expected output format'),
    context: z.record(z.unknown()).describe('Scoped context the sub-agent needs — only what is relevant to the task. Do NOT include parent state or unrelated information.'),
  })
- timeoutMs: 5_000 (just the enqueue operation, not the sub-agent runtime)
- execute: `async ({ task, context }) => { const job = await queue.add('sub-agent', { task, context }, { removeOnComplete: { age: 3600 }, removeOnFail: false }); return { jobId: job.id }; }`

Export function `createAwaitAgentTool(queue: Queue): ToolDefinition`:
- name: 'await-agent'
- description: 'Wait for a spawned sub-agent to complete and return its structured result. Polls every 2 seconds.'
- inputSchema: z.object({ jobId: z.string().describe('The jobId returned by spawn-agent') })
- timeoutMs: 300_000 (5 min max wait)
- execute: `async ({ jobId }, signal) => { while (!signal.aborted) { const job = await queue.getJob(jobId); if (!job) throw new Error('Sub-agent job not found: ' + jobId); const state = await job.getState(); if (state === 'completed') return job.returnvalue; if (state === 'failed') throw new Error('Sub-agent failed: ' + (job.failedReason ?? 'unknown')); await new Promise(r => setTimeout(r, 2000)); } throw new Error('await-agent aborted by timeout'); }`

Export function `createCancelAgentTool(queue: Queue): ToolDefinition`:
- name: 'cancel-agent'
- description: 'Cancel a running sub-agent. Use when a sub-agent is stuck or its task is no longer needed.'
- inputSchema: z.object({ jobId: z.string().describe('The jobId of the sub-agent to cancel') })
- timeoutMs: 10_000
- execute: `async ({ jobId }) => { const job = await queue.getJob(jobId); if (!job) return { cancelled: false, reason: 'job not found' }; const state = await job.getState(); if (state === 'completed' || state === 'failed') return { cancelled: false, reason: 'already ' + state }; await job.moveToFailed(new Error('Cancelled by parent agent'), 'cancel-agent', true); return { cancelled: true }; }`

Note: Use `job.moveToFailed()` for cancellation rather than `worker.cancelJob()` since we may not have a reference to the worker from the tool context. The job moves to failed state which the parent agent can detect.

CRITICAL per locked decision: Sub-agents receive SCOPED context only. The tool description explicitly instructs the LLM to pass only relevant context. No visibility into parent's full state or sibling agents' work.
  </action>
  <verify>
`cd /Users/sn0w/Documents/dev/jarvis/apps/agent && npx tsc --noEmit` compiles cleanly. All three tool factory functions are importable.
  </verify>
  <done>
Three tool definitions (spawn-agent, await-agent, cancel-agent) exist as factory functions that accept a BullMQ Queue. spawn-agent enqueues a job with scoped context, await-agent polls for completion, cancel-agent moves jobs to failed state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create agent-tasks BullMQ worker for sub-agent execution</name>
  <files>apps/agent/src/multi-agent/agent-worker.ts</files>
  <action>
Create `apps/agent/src/multi-agent/agent-worker.ts`:

This is a BullMQ Worker that processes jobs on the `agent-tasks` queue. Each job runs an independent agentic tool-calling loop with isolated LLM context.

Export function `createAgentWorker(deps: { redisUrl: string; router: ModelRouter; registry: ToolRegistry; killSwitch: KillCheckable; db: DbClient; tools: ChatCompletionTool[]; concurrency?: number }): Worker`:

- Create and return a new Worker on queue name `'agent-tasks'` with:
  - connection: `{ url: deps.redisUrl }`
  - concurrency: `deps.concurrency ?? 3` (per-main-agent sub-agent cap — locked decision)
  - removeOnComplete: `{ age: 3600 }`
  - removeOnFail: false (preserve for DLQ inspection — QUEUE-02)

- Job processor function:
  - Extract `{ task, context }` from job.data
  - MULTI-02: Create a FRESH messages array (isolated LLM context):
    ```
    const messages: ChatCompletionMessageParam[] = [
      { role: 'system', content: buildSubAgentSystemPrompt(task, context) },
      { role: 'user', content: task },
    ];
    ```
  - Run a mini agentic loop (same pattern as AgentLoop.executeSubGoal but self-contained):
    - Max 15 turns (sub-agents should be focused, not open-ended)
    - Call `deps.router.completeWithTools(messages, 'mid', deps.tools)` — use 'mid' tier for sub-agents (they handle focused tasks, not complex reasoning)
    - Push assistant message before tool results (same critical pattern)
    - For tool_calls: execute via `invokeWithKillCheck`, push tool results
    - On 'stop': return `{ success: true, result: message.content }`
    - On 'length'/'content_filter': return `{ success: false, error: finishReason }`
    - On max turns exceeded: return `{ success: false, error: 'max turns exceeded' }`
  - MULTI-03: The return value becomes `job.returnvalue` — structured JSON accessible by the parent via await-agent

- Helper function `buildSubAgentSystemPrompt(task: string, context: Record<string, unknown>): string`:
  - "You are a focused sub-agent. Your task: {task}"
  - "Context: {JSON.stringify(context)}"
  - "Execute the task using the available tools. When done, provide a clear summary of what you accomplished and the structured result."
  - "Do NOT attempt tasks outside your scope. If you cannot complete the task, explain why."

Note on imports: This file is in apps/agent, so it imports ModelRouter from @jarvis/ai, ToolRegistry/invokeWithKillCheck from @jarvis/tools, DbClient from @jarvis/db. Use the same duck-typed KillCheckable interface pattern as invoke-safe.ts (define locally or import from @jarvis/tools).
  </action>
  <verify>
`cd /Users/sn0w/Documents/dev/jarvis/apps/agent && npx tsc --noEmit` compiles cleanly. createAgentWorker is importable and returns a BullMQ Worker instance.
  </verify>
  <done>
Agent-tasks BullMQ worker processes sub-agent jobs with isolated LLM context (fresh message array per job), executes via the tool-calling protocol, and returns structured results via job.returnvalue. Uses 'mid' tier for focused sub-agent tasks.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/sn0w/Documents/dev/jarvis && npx turbo build` — monorepo builds
2. spawn-agent tool enqueues a job on 'agent-tasks' queue with task + scoped context
3. Agent worker creates isolated LLM context per job (no shared message arrays)
4. await-agent tool polls and returns structured result from job.returnvalue
5. cancel-agent tool moves job to failed state
6. Worker uses 'mid' tier (not 'strong') for sub-agent tasks
</verification>

<success_criteria>
- Main agent can call spawn-agent tool to create a sub-agent BullMQ job (MULTI-01)
- Each sub-agent job runs with its own message array (MULTI-02)
- Sub-agent results are returned as structured JSON via job.returnvalue (MULTI-03)
- Main agent can cancel running sub-agents via cancel-agent tool (MULTI-04)
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-autonomous-loop/03-03-SUMMARY.md`
</output>
