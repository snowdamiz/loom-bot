---
phase: 03-autonomous-loop
plan: 04
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - apps/agent/src/queue/retry-config.ts
  - apps/agent/src/queue/scheduler.ts
  - apps/agent/src/worker.ts
autonomous: true
requirements:
  - QUEUE-01
  - QUEUE-02
  - QUEUE-03
  - QUEUE-04
  - QUEUE-05

must_haves:
  truths:
    - "Failed external calls retry with exponential backoff up to 5 attempts"
    - "Exhausted retries are preserved in the BullMQ failed set (DLQ) for operator inspection"
    - "Task data payload is immutable across retries for deterministic replay"
    - "Recurring tasks fire on a cron schedule that survives process restarts"
    - "Long-running tasks execute asynchronously without blocking the agent loop"
  artifacts:
    - path: "apps/agent/src/queue/retry-config.ts"
      provides: "Job options factory with exponential backoff, DLQ preservation, and UnrecoverableError handling"
      exports: ["createRetryJobOptions", "isTransientError"]
    - path: "apps/agent/src/queue/scheduler.ts"
      provides: "Scheduler helpers for cron and fixed-interval recurring tasks"
      exports: ["scheduleRecurringTask", "scheduleFixedInterval"]
    - path: "apps/agent/src/worker.ts"
      provides: "Updated worker with retry config, DLQ preservation, and UnrecoverableError support"
      contains: "removeOnFail: false"
  key_links:
    - from: "apps/agent/src/worker.ts"
      to: "apps/agent/src/queue/retry-config.ts"
      via: "Worker uses retry configuration for job processing"
      pattern: "attempts.*backoff"
    - from: "apps/agent/src/queue/scheduler.ts"
      to: "bullmq Queue.upsertJobScheduler"
      via: "Creates cron-based recurring jobs in Redis"
      pattern: "upsertJobScheduler"
---

<objective>
Harden the BullMQ task queue with exponential backoff retry, dead-letter queue for failed jobs, and scheduled/recurring task support. This makes the agent's external interactions resilient to transient failures and enables time-based automation.

Purpose: Without retry logic, a single network blip kills a task permanently. Without DLQ, the operator has no visibility into what failed. Without scheduling, the agent cannot perform recurring operations.
Output: Retry configuration module, scheduler helpers, and updated worker with production-ready job lifecycle management.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-autonomous-loop/03-RESEARCH.md

@apps/agent/src/worker.ts
@apps/agent/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create retry configuration and DLQ support</name>
  <files>
    apps/agent/src/queue/retry-config.ts
    apps/agent/src/worker.ts
  </files>
  <action>
Create `apps/agent/src/queue/retry-config.ts`:

Import `UnrecoverableError` from `bullmq`.

Export function `createRetryJobOptions(overrides?: { attempts?: number; delayMs?: number }): object`:
- Returns BullMQ job options object:
  ```
  {
    attempts: overrides?.attempts ?? 5,
    backoff: {
      type: 'exponential',
      delay: overrides?.delayMs ?? 1000,  // 1s, 2s, 4s, 8s, 16s
    },
    removeOnComplete: { age: 3600 },      // Keep successful jobs for 1 hour
    removeOnFail: false,                   // QUEUE-02: Preserve in DLQ (failed set)
  }
  ```

Export function `isTransientError(err: Error): boolean`:
- Returns true for errors that should be retried:
  - Network errors: err.message includes 'ECONNREFUSED', 'ECONNRESET', 'ETIMEDOUT', 'ENOTFOUND', 'fetch failed', 'socket hang up'
  - HTTP 429 (rate limit) or 5xx server errors: check for status code patterns in message
  - Timeout errors: err.name === 'ToolTimeoutError' or message includes 'timeout'
- Returns false for:
  - 4xx client errors (except 429)
  - Validation errors
  - KillSwitchActiveError
  - Everything else (be conservative — unknown errors should not retry infinitely)

Export function `wrapWithTransientCheck<T>(fn: () => Promise<T>): Promise<T>`:
- Wraps a function to catch errors and rethrow as `UnrecoverableError` if NOT transient
- Usage: `await wrapWithTransientCheck(() => invokeWithKillCheck(...))`
- If `isTransientError(err)` is false, throw `new UnrecoverableError(err.message)` — this stops BullMQ from retrying
- If transient, rethrow the original error — BullMQ retries with backoff

Update `apps/agent/src/worker.ts`:
- Import `UnrecoverableError` from `bullmq`
- Import `isTransientError` from `./queue/retry-config.js`
- Change `removeOnFail` from `{ age: 86400 }` to `false` (QUEUE-02: preserve failed jobs indefinitely for DLQ)
- In the worker processor, wrap the invokeWithKillCheck call:
  ```
  try {
    const result = await invokeWithKillCheck(killSwitch, registry, db, toolName, input, timeoutMs);
    return result;
  } catch (err) {
    if (err instanceof Error && !isTransientError(err)) {
      throw new UnrecoverableError(err.message);
    }
    throw err; // transient — let BullMQ retry
  }
  ```
- Add `attempts: 5` and `backoff: { type: 'exponential', delay: 1000 }` to the Worker's defaultJobOptions (or apply at the Queue level when adding jobs)

QUEUE-03 note: BullMQ inherently preserves job.data across retries — the job data payload in Redis is immutable. No code change needed; just document this in a comment.
  </action>
  <verify>
`cd /Users/sn0w/Documents/dev/jarvis/apps/agent && npx tsc --noEmit` compiles cleanly. Worker has `removeOnFail: false` and uses `UnrecoverableError` for non-transient failures.
  </verify>
  <done>
Tool-execution worker retries transient failures with exponential backoff (1s, 2s, 4s, 8s, 16s) up to 5 attempts. Non-transient failures throw UnrecoverableError to skip retries. Failed jobs are preserved in BullMQ's failed set for operator inspection (DLQ).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create scheduled/recurring task support and async task helpers</name>
  <files>apps/agent/src/queue/scheduler.ts</files>
  <action>
Create `apps/agent/src/queue/scheduler.ts`:

Import `Queue` from `bullmq`.

Export async function `scheduleRecurringTask(queue: Queue, schedulerId: string, cronPattern: string, jobData: { toolName: string; input: unknown; timeoutMs?: number }): Promise<void>`:
- Uses `queue.upsertJobScheduler(schedulerId, { pattern: cronPattern }, { name: 'tool-execution', data: jobData })`
- QUEUE-04: Creates a cron-based job schedule in Redis that survives process restarts
- The schedulerId is idempotent — calling with the same ID updates the schedule rather than duplicating it
- Examples:
  - `scheduleRecurringTask(queue, 'daily-market-scan', '0 6 * * *', { toolName: 'http', input: { url: '...' } })`
  - `scheduleRecurringTask(queue, 'hourly-health-check', '0 * * * *', { toolName: 'db', input: { query: 'SELECT 1' } })`

Export async function `scheduleFixedInterval(queue: Queue, schedulerId: string, everyMs: number, jobData: { toolName: string; input: unknown; timeoutMs?: number }): Promise<void>`:
- Uses `queue.upsertJobScheduler(schedulerId, { every: everyMs }, { name: 'tool-execution', data: jobData })`
- For sub-minute intervals like health checks

Export async function `removeSchedule(queue: Queue, schedulerId: string): Promise<void>`:
- Uses `queue.removeJobScheduler(schedulerId)` to cancel a recurring schedule

Export async function `listSchedules(queue: Queue): Promise<Array<{ id: string; pattern?: string; every?: number; next?: number }>>`:
- Uses `queue.getJobSchedulers()` (BullMQ v5 API) to list all active schedules
- Returns simplified schedule info for operator visibility

QUEUE-05 note: Long-running tasks (browser automation, web research) are already async by design — they are enqueued as regular BullMQ jobs on the tool-execution queue and processed by the worker. The agent loop does not block waiting for them; it enqueues and moves on. Add a comment documenting this architectural decision.

Export async function `enqueueAsyncTask(queue: Queue, jobData: { toolName: string; input: unknown; timeoutMs?: number }, options?: { priority?: number }): Promise<string>`:
- Enqueues a job with retry options from createRetryJobOptions() and optional priority
- Returns the jobId so the caller can poll for completion
- Uses: `const job = await queue.add('tool-execution', jobData, { ...createRetryJobOptions(), priority: options?.priority }); return job.id!;`
  </action>
  <verify>
`cd /Users/sn0w/Documents/dev/jarvis/apps/agent && npx tsc --noEmit` compiles cleanly. All scheduler functions are importable.
  </verify>
  <done>
Recurring tasks can be scheduled via cron patterns or fixed intervals using BullMQ's upsertJobScheduler (survives restarts). Long-running tasks execute asynchronously on the tool-execution queue. Schedules can be listed and removed for operator control.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/sn0w/Documents/dev/jarvis && npx turbo build` — monorepo builds
2. Worker processor wraps errors with UnrecoverableError for non-transient failures
3. `removeOnFail: false` is set on the worker (DLQ preservation)
4. `upsertJobScheduler` is called correctly for recurring tasks
5. Job data immutability across retries is documented (QUEUE-03)
</verification>

<success_criteria>
- External calls retry with exponential backoff on transient failures (QUEUE-01)
- Exhausted retries preserved in failed set for operator review (QUEUE-02)
- Job data immutable across retries (QUEUE-03 — inherent to BullMQ, documented)
- Cron-based recurring tasks via upsertJobScheduler (QUEUE-04)
- Long-running tasks execute asynchronously via queue (QUEUE-05)
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-autonomous-loop/03-04-SUMMARY.md`
</output>
