---
phase: 03-autonomous-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/goals.ts
  - packages/db/src/schema/sub-goals.ts
  - packages/db/src/schema/index.ts
  - packages/db/drizzle.config.ts
  - packages/ai/src/provider.ts
  - packages/ai/src/openrouter.ts
  - packages/ai/src/router.ts
  - packages/ai/src/tool-schema.ts
  - packages/ai/src/index.ts
autonomous: true
requirements:
  - LOOP-01
  - MULTI-05

must_haves:
  truths:
    - "Goals and sub-goals can be persisted to Postgres with dependency tracking"
    - "ModelRouter can send tool-calling requests to OpenRouter and receive tool_calls in the response"
    - "Existing tool registry Zod schemas can be converted to OpenAI JSON Schema format for LLM tool-calling"
  artifacts:
    - path: "packages/db/src/schema/goals.ts"
      provides: "Goal lifecycle table with source, status, priority, replanCount"
      contains: "pgTable('goals'"
    - path: "packages/db/src/schema/sub-goals.ts"
      provides: "Sub-goal decomposition table with dependsOn JSONB, status, outcome, agentJobId"
      contains: "pgTable('sub_goals'"
    - path: "packages/ai/src/provider.ts"
      provides: "Extended AiProvider interface with completeWithTools method"
      contains: "completeWithTools"
    - path: "packages/ai/src/openrouter.ts"
      provides: "OpenRouterProvider tool-calling implementation"
      contains: "completeWithTools"
    - path: "packages/ai/src/router.ts"
      provides: "ModelRouter.completeWithTools routing + logging"
      contains: "completeWithTools"
    - path: "packages/ai/src/tool-schema.ts"
      provides: "Zod-to-OpenAI JSON Schema converter for tool definitions"
      exports: ["toolDefinitionsToOpenAI"]
  key_links:
    - from: "packages/ai/src/router.ts"
      to: "packages/ai/src/provider.ts"
      via: "completeWithTools delegation"
      pattern: "this\\.provider\\.completeWithTools"
    - from: "packages/ai/src/openrouter.ts"
      to: "openai SDK chat.completions.create"
      via: "tools parameter in create call"
      pattern: "this\\.client\\.chat\\.completions\\.create.*tools"
    - from: "packages/db/src/schema/sub-goals.ts"
      to: "packages/db/src/schema/goals.ts"
      via: "goalId foreign key reference"
      pattern: "references.*goals\\.id"
---

<objective>
Create the database schema for goal/sub-goal lifecycle tracking and extend the AI provider layer with tool-calling support. This is the foundation for the entire autonomous loop — goals need a place to live, and the agent needs to be able to call tools through the LLM.

Purpose: Without goal persistence, the agent cannot track what it is working on across cycles. Without tool-calling, the agent cannot take actions in the world via LLM decisions.
Output: Two new DB tables (goals, sub_goals), extended AiProvider/OpenRouterProvider/ModelRouter with completeWithTools, and a Zod-to-OpenAI schema converter.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-autonomous-loop/03-RESEARCH.md

@packages/db/src/schema/agent-state.ts
@packages/db/src/schema/planning-cycles.ts
@packages/db/src/schema/ai-calls.ts
@packages/db/src/schema/index.ts
@packages/db/drizzle.config.ts
@packages/ai/src/provider.ts
@packages/ai/src/openrouter.ts
@packages/ai/src/router.ts
@packages/ai/src/config.ts
@packages/ai/src/index.ts
@packages/tools/src/types.ts
@packages/tools/src/registry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create goals and sub_goals database schema</name>
  <files>
    packages/db/src/schema/goals.ts
    packages/db/src/schema/sub-goals.ts
    packages/db/src/schema/index.ts
    packages/db/drizzle.config.ts
  </files>
  <action>
Create `packages/db/src/schema/goals.ts`:
- `goals` table with columns: id (integer, PK, generatedAlwaysAsIdentity), source (varchar(32), notNull — 'operator-injected' | 'agent-discovered'), description (text, notNull), status (varchar(32), notNull, default 'active' — 'active' | 'paused' | 'completed' | 'abandoned'), replanCount (integer, notNull, default 0), priority (integer, notNull, default 50 — 0=highest), pauseReason (text, nullable — operator-visible when paused), createdAt (timestamp, defaultNow, notNull), updatedAt (timestamp, defaultNow, notNull)
- Export Goal and NewGoal inferred types

Create `packages/db/src/schema/sub-goals.ts`:
- `sub_goals` table with columns: id (integer, PK, generatedAlwaysAsIdentity), goalId (integer, references goals.id, notNull), description (text, notNull), dependsOn (jsonb, notNull, default [] — array of sub_goal IDs), status (varchar(32), notNull, default 'pending' — 'pending' | 'in-progress' | 'completed' | 'failed' | 'skipped'), outcome (jsonb, nullable — what the sub-goal produced), agentJobId (varchar(128), nullable — BullMQ job ID if delegated to sub-agent), priority (integer, notNull, default 50), createdAt (timestamp, defaultNow, notNull), completedAt (timestamp, nullable)
- Export SubGoal and NewSubGoal inferred types

Update `packages/db/src/schema/index.ts`: Add `export * from './goals.js'` and `export * from './sub-goals.js'`

Update `packages/db/drizzle.config.ts`: Add `'./src/schema/goals.ts'` and `'./src/schema/sub-goals.ts'` to the schema array

Run `cd packages/db && npx drizzle-kit push` to push schema to the running database. If DB is not running, just verify TypeScript compiles cleanly with `cd packages/db && npx tsc --noEmit`.

Follow existing patterns:
- Use `integer('id').primaryKey().generatedAlwaysAsIdentity()` (same as all other tables)
- Import from 'drizzle-orm/pg-core' directly (schema files are in @jarvis/db, not downstream)
- The goalId FK in sub_goals does NOT need AnyPgColumn (it's not self-referential)
  </action>
  <verify>
`cd /Users/sn0w/Documents/dev/jarvis/packages/db && npx tsc --noEmit` compiles cleanly. The goals and sub_goals tables are importable: `import { goals, subGoals } from '@jarvis/db'` resolves.
  </verify>
  <done>
goals and sub_goals tables exist in the schema with all specified columns, are exported from @jarvis/db, and are registered in drizzle.config.ts. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend AiProvider and OpenRouterProvider with tool-calling support</name>
  <files>
    packages/ai/src/provider.ts
    packages/ai/src/openrouter.ts
  </files>
  <action>
Extend `packages/ai/src/provider.ts`:
- Import `ChatCompletionMessageParam`, `ChatCompletionTool`, `ChatCompletionMessage` from `openai/resources/chat/completions` (these types are in the installed openai SDK v4.104)
- Add `ToolCompletionRequest` interface: `{ messages: ChatCompletionMessageParam[]; model: string; tools: ChatCompletionTool[]; temperature?: number; maxTokens?: number }`
- Add `ToolCompletionResponse` interface: `{ message: ChatCompletionMessage; finishReason: string; model: string; usage: CompletionUsage }`
- Add `completeWithTools(req: ToolCompletionRequest): Promise<ToolCompletionResponse>` to the `AiProvider` interface
- Keep the existing `CompletionRequest` messages type as-is (simple role/content) for backward compatibility — `ToolCompletionRequest` uses the proper OpenAI message param types which support tool_calls

Extend `packages/ai/src/openrouter.ts`:
- Add `completeWithTools` method to `OpenRouterProvider`:
  - Call `this.client.chat.completions.create({ model, messages, tools, tool_choice: 'auto', stream: false, temperature, max_tokens })`
  - Extract `choice = response.choices[0]`
  - Validate choice exists (throw if empty)
  - Extract usage with costUsd via the same `(usage as unknown as { cost?: number }).cost ?? 0` pattern
  - Return `{ message: choice.message, finishReason: choice.finish_reason ?? 'stop', model: response.model, usage: { promptTokens, completionTokens, totalTokens, costUsd } }`
  - CRITICAL: Do NOT check `choice.message.content === null` like `complete()` does — tool_calls responses have content=null and that is valid

Note: The existing `complete()` method stays unchanged. `completeWithTools()` is a separate code path that returns the full message object (including tool_calls) rather than just content.
  </action>
  <verify>
`cd /Users/sn0w/Documents/dev/jarvis/packages/ai && npx tsc --noEmit` compiles cleanly. The new types and methods are importable.
  </verify>
  <done>
AiProvider interface has completeWithTools method. OpenRouterProvider implements it using the openai SDK with tools parameter. Both ToolCompletionRequest and ToolCompletionResponse types are exported.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add ModelRouter.completeWithTools and Zod-to-OpenAI schema converter</name>
  <files>
    packages/ai/src/router.ts
    packages/ai/src/tool-schema.ts
    packages/ai/src/index.ts
  </files>
  <action>
Create `packages/ai/src/tool-schema.ts`:
- Export function `toolDefinitionsToOpenAI(registry: { list(): Array<{ name: string; description: string }>; get(name: string): { inputSchema: unknown } | undefined }): ChatCompletionTool[]`
  - Accept a duck-typed registry interface (not ToolRegistry directly — avoid @jarvis/ai depending on @jarvis/tools)
  - For each tool in `registry.list()`:
    - Get the full tool definition via `registry.get(name)`
    - For the inputSchema (a Zod schema), manually construct the JSON Schema parameters object. Since zod-to-json-schema is NOT installed and there are only 4-6 tools, use a manual approach: call `inputSchema.safeParse({})` to discover required fields, or since the tools have simple schemas (shell: {command: string}, http: {url, method?, headers?, body?}, file: {operation, path, content?}, db: {query: string}), write a simple `zodToJsonSchema` helper that handles ZodObject, ZodString, ZodNumber, ZodBoolean, ZodOptional, ZodDefault, ZodEnum, ZodRecord, ZodArray, and ZodUnknown
    - Build `{ type: 'function', function: { name, description, parameters: jsonSchema } }` per OpenAI format
  - IMPORTANT: The JSON Schema output must be `{ type: 'object', properties: {...}, required: [...] }` format
  - Export helper `zodToJsonSchema(schema: z.ZodType): Record<string, unknown>` for reuse

Extend `packages/ai/src/router.ts`:
- Import `ChatCompletionMessageParam`, `ChatCompletionTool` from `openai/resources/chat/completions`
- Import `ToolCompletionResponse` from `./provider.js`
- Add `completeWithTools(messages: ChatCompletionMessageParam[], tier: Tier, tools: ChatCompletionTool[], context?: { goalId?: number }): Promise<ToolCompletionResponse>` method:
  - Assert kill switch active (same as `complete()`)
  - Resolve tier to model ID
  - Call `this.provider.completeWithTools({ messages, model: modelId, tools })`
  - Log to ai_calls table (same logging pattern as `complete()`)
  - Return the full ToolCompletionResponse

Update `packages/ai/src/index.ts`: Add `export * from './tool-schema.js'`
  </action>
  <verify>
`cd /Users/sn0w/Documents/dev/jarvis/packages/ai && npx tsc --noEmit` compiles cleanly. `toolDefinitionsToOpenAI` is importable from `@jarvis/ai`. `ModelRouter.completeWithTools` exists.
  </verify>
  <done>
ModelRouter has completeWithTools that routes through the tier system with kill switch enforcement and cost logging. toolDefinitionsToOpenAI converts the tool registry's Zod schemas to OpenAI-format ChatCompletionTool arrays without any new dependencies.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/sn0w/Documents/dev/jarvis && npx turbo build` — full monorepo build passes
2. `import { goals, subGoals } from '@jarvis/db'` — tables are accessible
3. `import { toolDefinitionsToOpenAI, ModelRouter } from '@jarvis/ai'` — new exports resolve
4. TypeScript types for ChatCompletionTool, ChatCompletionMessage compile without errors
</verification>

<success_criteria>
- goals and sub_goals tables exist with all columns per research schema design
- AiProvider/OpenRouterProvider/ModelRouter all have completeWithTools methods
- Tool schema converter produces valid OpenAI JSON Schema from Zod inputSchemas
- Full monorepo TypeScript compilation passes
- No new npm dependencies added (uses only installed openai SDK types)
</success_criteria>

<output>
After completion, create `.planning/phases/03-autonomous-loop/03-01-SUMMARY.md`
</output>
