---
phase: 01-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - pnpm-workspace.yaml
  - turbo.json
  - docker-compose.yml
  - Dockerfile
  - .env.example
  - .gitignore
  - packages/typescript-config/base.json
  - packages/typescript-config/package.json
  - packages/db/package.json
  - packages/db/tsconfig.json
  - packages/db/drizzle.config.ts
  - packages/db/src/index.ts
  - packages/db/src/client.ts
  - packages/db/src/schema/index.ts
  - packages/db/src/schema/agent-state.ts
  - packages/db/src/schema/memory-facts.ts
  - packages/db/src/schema/tool-calls.ts
  - packages/db/src/schema/decision-log.ts
  - packages/db/src/schema/planning-cycles.ts
autonomous: true
requirements:
  - DATA-01
  - DATA-02
  - DATA-05
  - LOG-04
  - LOG-05

must_haves:
  truths:
    - "Postgres container starts via docker compose and accepts connections"
    - "Redis container starts via docker compose and responds to PING"
    - "Drizzle schema defines all 5 tables (tool_calls, decision_log, planning_cycles, memory_facts, agent_state) with JSONB columns"
    - "drizzle-kit push applies the schema to the running Postgres instance"
    - "agent_state table supports key-value JSONB storage that persists across container restarts"
    - "db.execute(sql.raw('CREATE TABLE ...')) succeeds for runtime DDL"
  artifacts:
    - path: "packages/db/src/schema/tool-calls.ts"
      provides: "Tool call log schema with JSONB input/output columns"
      contains: "pgTable"
    - path: "packages/db/src/schema/decision-log.ts"
      provides: "Decision log schema with JSONB reasoning column"
      contains: "pgTable"
    - path: "packages/db/src/schema/planning-cycles.ts"
      provides: "Planning cycle schema with JSONB goals/outcomes"
      contains: "pgTable"
    - path: "packages/db/src/schema/memory-facts.ts"
      provides: "Long-term memory facts schema with JSONB body"
      contains: "pgTable"
    - path: "packages/db/src/schema/agent-state.ts"
      provides: "Agent state key-value schema with JSONB value"
      contains: "pgTable"
    - path: "packages/db/src/client.ts"
      provides: "Drizzle db instance + connection pool"
      exports: ["db", "pool"]
    - path: "docker-compose.yml"
      provides: "Postgres and Redis containers with healthchecks"
      contains: "service_healthy"
  key_links:
    - from: "packages/db/src/client.ts"
      to: "packages/db/src/schema/index.ts"
      via: "drizzle(pool, { schema })"
      pattern: "drizzle.*schema"
    - from: "docker-compose.yml"
      to: "packages/db/src/client.ts"
      via: "DATABASE_URL environment variable"
      pattern: "DATABASE_URL"
---

<objective>
Scaffold the Turborepo monorepo structure, create the @jarvis/db package with all Drizzle schemas, and set up Docker Compose for Postgres + Redis.

Purpose: This is the foundation everything else builds on. The monorepo structure establishes package boundaries. The database schemas define the tables used by logging, memory, and state persistence. Docker Compose provides the runtime dependencies.

Output: Working monorepo with `@jarvis/db` package, all 5 Postgres table schemas defined and pushed, Docker Compose running Postgres 16 and Redis 7 with health checks.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Turborepo monorepo with shared config and Docker Compose</name>
  <files>
    package.json
    pnpm-workspace.yaml
    turbo.json
    docker-compose.yml
    Dockerfile
    .env.example
    .gitignore
    packages/typescript-config/base.json
    packages/typescript-config/package.json
  </files>
  <action>
    Create the monorepo root structure:

    1. **Root `package.json`**: Set `"name": "jarvis"`, `"private": true`, `"type": "module"`. Add devDependency on `turbo`. Add scripts: `"build": "turbo build"`, `"dev": "turbo dev"`, `"lint": "turbo lint"`, `"typecheck": "turbo typecheck"`, `"db:push": "pnpm --filter @jarvis/db run db:push"`, `"db:generate": "pnpm --filter @jarvis/db run db:generate"`, `"docker:up": "docker compose up -d"`, `"docker:down": "docker compose down"`.

    2. **`pnpm-workspace.yaml`**: Define packages `['apps/*', 'packages/*']`.

    3. **`turbo.json`**: Standard Turborepo config per research. Tasks: `build` (dependsOn `^build`, outputs `dist/**`), `dev` (persistent, no cache), `lint` (dependsOn `^build`), `typecheck` (dependsOn `^build`), `db:push` (cache false), `db:generate` (cache false).

    4. **`packages/typescript-config/package.json`**: `"name": "@jarvis/typescript-config"`, `"private": true`. No dependencies.

    5. **`packages/typescript-config/base.json`**: Shared tsconfig with `"target": "ES2022"`, `"module": "NodeNext"`, `"moduleResolution": "NodeNext"`, `"esModuleInterop": true`, `"strict": true`, `"skipLibCheck": true`, `"outDir": "dist"`, `"rootDir": "src"`, `"declaration": true`, `"declarationMap": true`, `"sourceMap": true`.

    6. **`docker-compose.yml`**: Per research example exactly. Postgres 16-alpine with healthcheck (`pg_isready`), Redis 7-alpine with healthcheck (`redis-cli ping`). Volume for postgres_data. Environment: `POSTGRES_USER=jarvis`, `POSTGRES_PASSWORD=jarvis`, `POSTGRES_DB=jarvis`. Expose ports 5432 and 6379 to host for local development.

    7. **`Dockerfile`**: Multi-stage build. Stage 1 (builder): `node:22-alpine`, install pnpm, copy workspace files, `pnpm install --frozen-lockfile`, `pnpm build`. Stage 2 (runner): copy dist and node_modules, `CMD ["node", "apps/agent/dist/index.js"]`. This is a placeholder — will be refined when apps/agent exists.

    8. **`.env.example`**: Document required env vars: `DATABASE_URL=postgres://jarvis:jarvis@localhost:5432/jarvis`, `REDIS_URL=redis://localhost:6379`.

    9. **`.gitignore`**: Standard Node.js gitignore + `node_modules/`, `dist/`, `.env`, `.turbo/`, `*.tsbuildinfo`.

    Run `pnpm install` at root after creating files to initialize the workspace.
  </action>
  <verify>
    - `pnpm install` completes without errors
    - `docker compose up -d` starts Postgres and Redis containers
    - `docker compose ps` shows both services as healthy
    - `docker compose exec postgres pg_isready -U jarvis` succeeds
    - `docker compose exec redis redis-cli ping` returns PONG
  </verify>
  <done>
    Monorepo root exists with Turborepo config, shared TypeScript config package, Docker Compose runs Postgres 16 and Redis 7 with passing health checks, and `.env.example` documents required environment variables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Scaffold @jarvis/db package with config, client, and barrel exports</name>
  <files>
    packages/db/package.json
    packages/db/tsconfig.json
    packages/db/drizzle.config.ts
    packages/db/src/client.ts
    packages/db/src/index.ts
    packages/db/src/schema/index.ts
  </files>
  <action>
    Scaffold the `@jarvis/db` package structure and client:

    1. **`packages/db/package.json`**: `"name": "@jarvis/db"`, `"type": "module"`, `"main": "dist/index.js"`, `"types": "dist/index.d.ts"`, `"exports": { ".": { "import": "./dist/index.js", "types": "./dist/index.d.ts" } }`. Dependencies: `drizzle-orm`, `pg`. DevDependencies: `drizzle-kit`, `tsx`, `@types/pg`, `@jarvis/typescript-config` (workspace:*). Scripts: `"build": "tsc"`, `"db:push": "drizzle-kit push"`, `"db:generate": "drizzle-kit generate"`, `"db:migrate": "drizzle-kit migrate"`.

    2. **`packages/db/tsconfig.json`**: Extends `@jarvis/typescript-config/base.json`. Set `"outDir": "dist"`, `"rootDir": "src"`. Include `["src/**/*.ts"]`.

    3. **`packages/db/drizzle.config.ts`**: Use `defineConfig` from `drizzle-kit`. Set `schema: './src/schema/index.ts'`, `out: './drizzle'`, `dialect: 'postgresql'`, `dbCredentials: { url: process.env.DATABASE_URL! }`.

    4. **`packages/db/src/client.ts`**: Create and export `pool` (new Pool with `connectionString: process.env.DATABASE_URL!`, `max: 20`, `idleTimeoutMillis: 30_000`, `connectionTimeoutMillis: 2_000`) and `db` (drizzle(pool, { schema })). Export `type DbClient = typeof db`. Add a `shutdown()` function that calls `pool.end()` for graceful shutdown.

    5. **`packages/db/src/schema/index.ts`**: Create as empty barrel file (will be populated by Task 3). Add a placeholder comment: `// Schema exports added by Task 3`.

    6. **`packages/db/src/index.ts`**: Re-export everything: `export * from './client.js'`, `export * from './schema/index.js'`, `export { sql } from 'drizzle-orm'`.

    Run `pnpm install` from root after creating packages/db/package.json.
  </action>
  <verify>
    - `pnpm install` completes without errors with the new workspace package
    - `pnpm --filter @jarvis/db run build` compiles without errors (schema is empty but valid)
    - Directory structure exists: packages/db/src/schema/
  </verify>
  <done>
    @jarvis/db package scaffolded with package.json, tsconfig, drizzle config, client with connection pool, and barrel exports. Ready for schema files in Task 3.
  </done>
</task>

<task type="auto">
  <name>Task 3: Define all 5 Drizzle schemas, push to Postgres, and verify persistence</name>
  <files>
    packages/db/src/schema/agent-state.ts
    packages/db/src/schema/memory-facts.ts
    packages/db/src/schema/tool-calls.ts
    packages/db/src/schema/decision-log.ts
    packages/db/src/schema/planning-cycles.ts
    packages/db/src/schema/index.ts
  </files>
  <action>
    Create all 5 schema files and update the barrel export:

    1. **Schema files** — follow the research code examples exactly:

       **`agent-state.ts`** (DATA-01): `pgTable('agent_state', {...})` with fields: `id` (integer, primaryKey, generatedAlwaysAsIdentity), `key` (varchar 256, notNull, unique), `value` (jsonb, notNull), `updatedAt` (timestamp, defaultNow, notNull).

       **`memory-facts.ts`** (DATA-05): `pgTable('memory_facts', {...})` with fields: `id` (integer, primaryKey, generatedAlwaysAsIdentity), `subject` (text, notNull), `body` (jsonb, notNull — contains learned, confidence, source), `isStale` (boolean, default false, notNull), `createdAt` (timestamp, defaultNow, notNull).

       **`tool-calls.ts`** (LOG-02, LOG-04): `pgTable('tool_calls', {...})` with fields: `id` (integer, primaryKey, generatedAlwaysAsIdentity), `toolName` (varchar 128, notNull), `status` (varchar 32, notNull, default 'started'), `input` (jsonb, notNull), `output` (jsonb), `error` (text), `durationMs` (integer), `startedAt` (timestamp, defaultNow, notNull), `completedAt` (timestamp). **Note on LOG-05:** Use the two-row approach for strict append-only compliance. The "started" row is never updated; a separate "completed" row is inserted with a `parentId` foreign key referencing the started row. Add field: `parentId` (integer, references self, nullable). Document this interpretation in a code comment.

       **`decision-log.ts`** (LOG-01, LOG-04): `pgTable('decision_log', {...})` with fields: `id` (integer, primaryKey, generatedAlwaysAsIdentity), `cycleId` (integer, nullable), `reasoning` (jsonb, notNull — full chain-of-thought), `decision` (text, notNull), `createdAt` (timestamp, defaultNow, notNull).

       **`planning-cycles.ts`** (LOG-03, LOG-04): `pgTable('planning_cycles', {...})` with fields: `id` (integer, primaryKey, generatedAlwaysAsIdentity), `goals` (jsonb, notNull), `status` (varchar 32, notNull, default 'active'), `outcomes` (jsonb), `startedAt` (timestamp, defaultNow, notNull), `completedAt` (timestamp). **LOG-05 note:** Like tool_calls, planning_cycles uses two-row pattern. Active row is never updated; completion creates a new row with `parentId`. Add `parentId` (integer, references self, nullable).

    2. **Update `schema/index.ts`**: Replace placeholder with re-exports from all schema files using `export * from './agent-state.js'` etc.

    3. **Push schema to Postgres:** Run `DATABASE_URL=postgres://jarvis:jarvis@localhost:5432/jarvis pnpm --filter @jarvis/db run db:push` to apply all schemas.

    4. **Verify persistence:** After pushing the schema, run a quick verification script (inline via `tsx -e`):
       - Insert a row into `agent_state` with key='test', value='{"alive": true}'
       - Read it back
       - Run `db.execute(sql.raw('CREATE TABLE IF NOT EXISTS agent_dynamic_test (id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY, payload JSONB)'))` to verify DATA-02
       - Drop the test table
       - Clean up the test row
  </action>
  <verify>
    - `pnpm --filter @jarvis/db run build` compiles without errors
    - `DATABASE_URL=... pnpm --filter @jarvis/db run db:push` creates all 5 tables
    - Connect to Postgres and verify tables exist: `docker compose exec postgres psql -U jarvis -d jarvis -c '\dt'` shows tool_calls, decision_log, planning_cycles, memory_facts, agent_state
    - Verify JSONB columns: `docker compose exec postgres psql -U jarvis -d jarvis -c "\d tool_calls"` shows jsonb type for input/output columns
    - The inline tsx verification script succeeds for CRUD + DDL operations
  </verify>
  <done>
    All 5 Drizzle schema files defined and pushed to Postgres. JSONB columns verified. agent_state supports key-value persistence (DATA-01), raw DDL works via db.execute (DATA-02), memory_facts table stores structured knowledge (DATA-05), all log tables use JSONB and are SQL-queryable (LOG-04), and append-only two-row pattern is implemented for tool_calls and planning_cycles (LOG-05).
  </done>
</task>

</tasks>

<verification>
1. `docker compose ps` shows postgres and redis as healthy
2. `pnpm --filter @jarvis/db run build` succeeds
3. `\dt` in psql shows all 5 tables
4. Insert + select on agent_state works (DATA-01)
5. `CREATE TABLE` via raw SQL works (DATA-02)
6. memory_facts table has JSONB body column (DATA-05)
7. All log tables have JSONB columns (LOG-04)
8. No UPDATE or DELETE functions exist in the schema module (LOG-05 — enforced by two-row pattern)
</verification>

<success_criteria>
- Monorepo with Turborepo builds successfully
- Docker Compose brings up Postgres 16 and Redis 7 with passing healthchecks
- @jarvis/db compiles and all 5 schemas are pushed to Postgres
- Agent state round-trips through Postgres (write, restart container, read back)
- Runtime DDL (CREATE TABLE, ALTER TABLE) executes successfully
- All tables use JSONB columns for structured data
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-01-SUMMARY.md`
</output>
