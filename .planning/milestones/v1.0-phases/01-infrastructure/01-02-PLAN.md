---
phase: 01-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/logging/package.json
  - packages/logging/tsconfig.json
  - packages/logging/src/index.ts
  - packages/logging/src/tool-logger.ts
  - packages/logging/src/decision-logger.ts
  - packages/logging/src/cycle-logger.ts
  - packages/tools/package.json
  - packages/tools/tsconfig.json
  - packages/tools/src/redis.ts
  - packages/tools/src/session.ts
autonomous: true
requirements:
  - TOOL-05
  - LOG-01
  - LOG-02
  - LOG-03
  - DATA-04

must_haves:
  truths:
    - "A tool call log row is inserted BEFORE the tool actually executes (pre-execution logging)"
    - "A tool call completion row is inserted AFTER execution with output, duration, and success/failure status"
    - "Every agent decision is logged with full chain-of-thought reasoning as JSONB"
    - "Every planning cycle start/end is logged with goals set and outcomes"
    - "Session state written to Redis is retrievable and has a distinct TTL from Postgres data"
    - "Losing Redis does not lose any data stored in Postgres"
  artifacts:
    - path: "packages/logging/src/tool-logger.ts"
      provides: "Pre-execution and post-execution tool call logging"
      exports: ["logToolStart", "logToolComplete", "logToolFailure"]
    - path: "packages/logging/src/decision-logger.ts"
      provides: "Agent decision logging with full reasoning"
      exports: ["logDecision"]
    - path: "packages/logging/src/cycle-logger.ts"
      provides: "Planning cycle start/end logging"
      exports: ["logCycleStart", "logCycleComplete"]
    - path: "packages/tools/src/redis.ts"
      provides: "ioredis client with commandTimeout and error handling"
      exports: ["redis", "shutdownRedis"]
    - path: "packages/tools/src/session.ts"
      provides: "Session memory get/set/delete with TTL"
      exports: ["getSession", "setSession", "deleteSession"]
  key_links:
    - from: "packages/logging/src/tool-logger.ts"
      to: "packages/db/src/schema/tool-calls.ts"
      via: "db.insert(toolCalls) for pre and post rows"
      pattern: "insert.*toolCalls"
    - from: "packages/logging/src/decision-logger.ts"
      to: "packages/db/src/schema/decision-log.ts"
      via: "db.insert(decisionLog)"
      pattern: "insert.*decisionLog"
    - from: "packages/logging/src/cycle-logger.ts"
      to: "packages/db/src/schema/planning-cycles.ts"
      via: "db.insert(planningCycles)"
      pattern: "insert.*planningCycles"
    - from: "packages/tools/src/redis.ts"
      to: "docker-compose.yml Redis service"
      via: "REDIS_URL environment variable"
      pattern: "REDIS_URL"
---

<objective>
Create the @jarvis/logging package for structured audit trail writes, and set up Redis session memory in @jarvis/tools.

Purpose: The logging package is the mandatory intermediary between tool execution and the database — every tool invocation, every decision, and every planning cycle must flow through these loggers. The Redis session layer provides the hot-state memory tier (DATA-04) that is distinct from Postgres long-term storage.

Output: @jarvis/logging package with 3 logger modules (tool, decision, cycle), @jarvis/tools package initialized with Redis client and session helpers.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure/01-RESEARCH.md
@.planning/phases/01-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create @jarvis/logging package with tool, decision, and cycle loggers</name>
  <files>
    packages/logging/package.json
    packages/logging/tsconfig.json
    packages/logging/src/index.ts
    packages/logging/src/tool-logger.ts
    packages/logging/src/decision-logger.ts
    packages/logging/src/cycle-logger.ts
  </files>
  <action>
    Create the `@jarvis/logging` package:

    1. **`packages/logging/package.json`**: `"name": "@jarvis/logging"`, `"type": "module"`, `"main": "dist/index.js"`, `"types": "dist/index.d.ts"`, exports field like @jarvis/db. Dependencies: `@jarvis/db` (workspace:*). DevDependencies: `@jarvis/typescript-config` (workspace:*), `tsx`. Scripts: `"build": "tsc"`.

    2. **`packages/logging/tsconfig.json`**: Extends `@jarvis/typescript-config/base.json`.

    3. **`packages/logging/src/tool-logger.ts`** — Implements the two-row append-only pattern for LOG-05:

       **`logToolStart(db, params: { toolName: string, input: unknown })`**: Inserts a row into `tool_calls` with `status='started'`, `input` as JSONB, `startedAt` as now. Returns the inserted row's `id`. This function MUST be called BEFORE the tool executes (TOOL-05).

       **`logToolComplete(db, params: { parentId: number, output: unknown, durationMs: number })`**: Inserts a NEW row (not UPDATE — LOG-05 append-only) into `tool_calls` with `status='success'`, `parentId` referencing the started row, `output` as JSONB, `durationMs`, `completedAt` as now. The original started row is NEVER modified.

       **`logToolFailure(db, params: { parentId: number, error: string, durationMs: number })`**: Same as complete but `status='failure'` and `error` field instead of `output`.

       All functions accept the Drizzle db client as first argument (dependency injection, not imported singleton).

    4. **`packages/logging/src/decision-logger.ts`** (LOG-01):

       **`logDecision(db, params: { cycleId?: number, reasoning: unknown, decision: string })`**: Inserts into `decision_log`. `reasoning` is the full LLM chain-of-thought as JSONB — not a summary, the complete reasoning per user decision. Returns the inserted row's `id`.

    5. **`packages/logging/src/cycle-logger.ts`** (LOG-03):

       **`logCycleStart(db, params: { goals: unknown })`**: Inserts into `planning_cycles` with `status='active'`, `goals` as JSONB, `startedAt`. Returns `id`.

       **`logCycleComplete(db, params: { parentId: number, outcomes: unknown })`**: Inserts a NEW row (append-only) with `status='completed'`, `parentId`, `outcomes` as JSONB, `completedAt`. Does NOT update the original active row.

    6. **`packages/logging/src/index.ts`**: Re-export all functions from all logger modules.

    Run `pnpm install` from root after creating the package to link workspace dependencies.
  </action>
  <verify>
    - `pnpm --filter @jarvis/logging run build` compiles without errors
    - Verify via inline script (`tsx -e`): call `logToolStart`, verify row in DB with status='started', then call `logToolComplete` with the returned id, verify second row with status='success' and parentId set. Confirm original row unchanged.
    - Verify `logDecision` inserts a row with JSONB reasoning
    - Verify `logCycleStart` + `logCycleComplete` creates two rows (no updates)
  </verify>
  <done>
    @jarvis/logging package compiles and exports 6 logging functions. Tool logging uses strict two-row append-only pattern (LOG-05). Decision logger captures full chain-of-thought (LOG-01). Cycle logger records goals at start and outcomes at completion (LOG-03). All data stored as structured JSONB in Postgres (LOG-04). Pre-execution logging guaranteed by API design — logToolStart must be called before execution to get the parentId needed by logToolComplete (TOOL-05).
  </done>
</task>

<task type="auto">
  <name>Task 2: Set up Redis client and session memory helpers in @jarvis/tools</name>
  <files>
    packages/tools/package.json
    packages/tools/tsconfig.json
    packages/tools/src/redis.ts
    packages/tools/src/session.ts
  </files>
  <action>
    Initialize the `@jarvis/tools` package (will hold tool implementations in the next plan):

    1. **`packages/tools/package.json`**: `"name": "@jarvis/tools"`, `"type": "module"`, `"main": "dist/index.js"`, `"types": "dist/index.d.ts"`, exports field. Dependencies: `@jarvis/db` (workspace:*), `@jarvis/logging` (workspace:*), `ioredis`, `zod`. DevDependencies: `@jarvis/typescript-config` (workspace:*), `tsx`. Scripts: `"build": "tsc"`.

    2. **`packages/tools/tsconfig.json`**: Extends `@jarvis/typescript-config/base.json`.

    3. **`packages/tools/src/redis.ts`** (DATA-04 foundation):

       Create and export `redis` (new Redis with `process.env.REDIS_URL!`). Configure per research pitfall #5:
       - Set `commandTimeout: 5000` (5s) to prevent hanging commands
       - Set `retryStrategy` to reconnect with exponential backoff (max 3000ms)
       - Attach `redis.on('error', ...)` handler that logs to stderr (not to Postgres — Redis errors happen when DB might also be down)
       - Export `shutdownRedis()` that calls `redis.quit()` for graceful shutdown

    4. **`packages/tools/src/session.ts`** (DATA-04):

       Session memory helpers that wrap Redis with JSON serialization:

       **`setSession(key: string, value: unknown, ttlSeconds?: number)`**: `redis.set(key, JSON.stringify(value))` with optional `EX` TTL. Default TTL: 3600 (1 hour). Namespace all keys with `session:` prefix.

       **`getSession<T>(key: string): Promise<T | null>`**: `redis.get(key)` + `JSON.parse`. Returns null if key missing.

       **`deleteSession(key: string)`**: `redis.del(key)`.

       **`listSessionKeys(pattern?: string): Promise<string[]>`**: `redis.keys('session:' + (pattern || '*'))`. For debugging/inspection.

       All functions use the `session:` prefix to distinguish session data from other Redis usage (BullMQ queues will use their own prefix).

    5. **Do NOT create `packages/tools/src/index.ts` yet** — that will be created in Plan 03 when the tool registry and implementations are added. Only export redis and session for now via a temporary `src/index.ts` that re-exports from `./redis.js` and `./session.js`.

    Run `pnpm install` from root after creating the package.
  </action>
  <verify>
    - `pnpm --filter @jarvis/tools run build` compiles without errors
    - Verify via inline script: `setSession('test:key', { cycle: 1, goals: ['earn money'] }, 60)` succeeds, `getSession('test:key')` returns the object, `deleteSession('test:key')` removes it, `getSession('test:key')` returns null
    - Verify TTL: set a key with 2s TTL, wait 3s, confirm it's gone
    - Verify Redis error handling: stop Redis container, confirm error handler fires and no unhandled rejection crashes the process, restart Redis container
  </verify>
  <done>
    @jarvis/tools package initialized with Redis client (commandTimeout configured, error handler attached) and session memory helpers (get/set/delete with JSON serialization and TTL). Session data is namespaced with `session:` prefix. Redis holds hot state only — losing Redis loses only session data, not Postgres-persisted data (DATA-04).
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @jarvis/logging run build` succeeds
2. `pnpm --filter @jarvis/tools run build` succeeds
3. Tool call pre-log creates row in DB before execution would happen (TOOL-05)
4. Tool call complete/failure creates NEW row with parentId, original row unchanged (LOG-05)
5. Decision log stores full JSONB reasoning (LOG-01)
6. Planning cycle log records start and completion as separate rows (LOG-03)
7. Redis session set/get/delete works with TTL (DATA-04)
8. Redis failure doesn't crash the process
</verification>

<success_criteria>
- @jarvis/logging compiles and all 6 logging functions work against live Postgres
- @jarvis/tools compiles and Redis session helpers work against live Redis
- Two-row append-only pattern verified: no UPDATE statements exist in logging code
- Session data expires based on TTL
- Redis and Postgres are clearly separate storage tiers
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-02-SUMMARY.md`
</output>
