---
phase: 04-wallet-and-financial-governance
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/wallet/src/client/send.ts
autonomous: true
gap_closure: true
requirements:
  - WALLET-05

must_haves:
  truths:
    - "sendSplToken calls checkSpendLimits before any signing or broadcast — governance rejects SPL sends that exceed per-transaction or daily aggregate limits"
    - "A rejected SPL token send is logged to wallet_transactions with status='rejected' and a human-readable rejection_reason"
    - "A rejected SPL token send triggers a non-blocking Discord DM breach notification to the operator"
  artifacts:
    - path: "packages/wallet/src/client/send.ts"
      provides: "SPL token governance check in sendSplToken"
      contains: "checkSpendLimits"
  key_links:
    - from: "packages/wallet/src/client/send.ts"
      to: "packages/wallet/src/governance/limits.ts"
      via: "checkSpendLimits called in sendSplToken before signing"
      pattern: "checkSpendLimits\\(db,.*BigInt\\(amount\\)"
---

<objective>
Add spend governance enforcement to SPL token sends, closing the verification gap where sendSplToken bypassed checkSpendLimits entirely.

Purpose: The phase goal states "every transaction is governed by limits." SOL sends enforce governance; SPL token sends currently skip it. This plan adds the same governance gate to sendSplToken so all outbound transactions pass through spend limit checks before signing.

Output: Updated `packages/wallet/src/client/send.ts` with governance enforcement in sendSplToken matching the sendSol pattern.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-wallet-and-financial-governance/04-03-SUMMARY.md
@packages/wallet/src/client/send.ts
@packages/wallet/src/governance/limits.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add checkSpendLimits governance gate to sendSplToken</name>
  <files>packages/wallet/src/client/send.ts</files>
  <action>
In `sendSplToken`, add a governance check as Step 0 — BEFORE any RPC calls, ATA lookups, or signing. This mirrors the exact pattern from `sendSol` lines 93-121.

Specifically, insert the following block at the very beginning of `sendSplToken`, before the existing Step 1 (RPC URL and config reads):

1. Call `checkSpendLimits(db, BigInt(amount), mintAddress)` — passing the token amount as bigint and the mint address as the optional tokenMint parameter. This allows the governance system to enforce per-transaction and daily aggregate limits against SPL token sends using the same numeric ceiling comparison as SOL. The tokenMint parameter is already accepted by checkSpendLimits (currently unused but passed through for future per-token limit support).

2. If `governanceResult.allowed === false`:
   - Insert a `wallet_transactions` row with `tokenMint: mintAddress`, `destinationAddress: destination`, `amountLamports: amount`, `purpose`, `status: 'rejected'`, `rejectionReason: reason` — exactly matching the sendSol rejection logging pattern.
   - Fire a non-blocking `notifySpendLimitBreach(reason, BigInt(amount), purpose)` with `.catch()` error logging to stderr — matching sendSol.
   - Return `{ success: false, error: reason, transactionId }`.

3. Update the JSDoc comment for `sendSplToken` to reflect that governance IS now enforced. Remove the "NOTE on governance" block (lines 212-215 of current code) that says governance is skipped. Replace it with a note explaining that governance compares raw token base units against the same lamport-denominated limits — a coarse safety net that prevents unbounded SPL sends, with USD-denominated per-token limits deferred to a future phase with oracle pricing.

4. Update the flow description in the JSDoc (line 209) from "Same governance check skipped for SPL (see NOTE)" to indicate governance is now enforced.

Do NOT change any other logic in sendSplToken. The governance check is purely additive — all existing steps (token program detection, mint decimals, ATA creation, signing, broadcast, logging) remain unchanged.

Build verification: `pnpm --filter @jarvis/wallet build` must pass with zero TypeScript errors.
  </action>
  <verify>
Run `pnpm --filter @jarvis/wallet build` — must compile with zero errors.

Grep for `checkSpendLimits` in send.ts — must appear in BOTH sendSol AND sendSplToken functions.

Grep for "governance check skipped" or "governance skipped" in send.ts — must return zero matches (old skip comment removed).
  </verify>
  <done>
sendSplToken calls checkSpendLimits before any signing. Rejected SPL sends are logged with rejection_reason and trigger a non-blocking breach notification. The JSDoc accurately reflects that governance is enforced. TypeScript compilation passes.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @jarvis/wallet build` passes — no TypeScript errors
2. `grep -n checkSpendLimits packages/wallet/src/client/send.ts` shows calls in BOTH sendSol and sendSplToken
3. `grep -c "governance.*skip" packages/wallet/src/client/send.ts` returns 0 — no skip language remains
4. The sendSplToken function has a governance rejection path that inserts a wallet_transactions row with status='rejected' before the function reaches any signing code
</verification>

<success_criteria>
- checkSpendLimits is called in sendSplToken before any RPC or signing operations
- Rejected SPL sends produce a wallet_transactions row with status='rejected' and rejection_reason
- Breach notification fires on rejection (non-blocking, fire-and-forget)
- TypeScript compiles cleanly
- WALLET-05 requirement fully satisfied (both SOL and SPL governed)
</success_criteria>

<output>
After completion, create `.planning/phases/04-wallet-and-financial-governance/04-04-SUMMARY.md`
</output>
