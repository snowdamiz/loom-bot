---
phase: 04-wallet-and-financial-governance
plan: 02
type: execute
wave: 2
depends_on:
  - 04-01
files_modified:
  - packages/wallet/src/client/balance.ts
  - packages/wallet/src/client/config.ts
  - packages/wallet/src/governance/limits.ts
  - packages/wallet/src/governance/notify.ts
  - packages/wallet/src/index.ts
  - packages/wallet/package.json
autonomous: true
requirements:
  - WALLET-01
  - WALLET-05

must_haves:
  truths:
    - "Agent can query SOL balance in lamports for its wallet address"
    - "Agent can query all SPL token balances across both TOKEN_PROGRAM_ID and TOKEN_2022_PROGRAM_ID"
    - "Balance results include token mint address, amount, and decimals for each holding"
    - "Spend governance rejects a transaction that exceeds the per-transaction limit"
    - "Spend governance rejects a transaction that would push daily aggregate spending over the limit"
    - "Governance breach triggers Discord DM notification to operator"
    - "Wallet config is read from the DB wallet_config table, not from environment variables"
  artifacts:
    - path: "packages/wallet/src/client/balance.ts"
      provides: "SOL and SPL token balance queries"
      contains: "getBalances"
    - path: "packages/wallet/src/client/config.ts"
      provides: "DB-backed wallet configuration reader"
      contains: "getWalletConfig"
    - path: "packages/wallet/src/governance/limits.ts"
      provides: "Per-tx and daily aggregate spend limit enforcement"
      contains: "checkSpendLimits"
    - path: "packages/wallet/src/governance/notify.ts"
      provides: "Discord DM on limit breach or high-value transaction"
      contains: "notifyOperator"
  key_links:
    - from: "packages/wallet/src/client/balance.ts"
      to: "packages/db/src/schema/wallet-config.ts"
      via: "reads RPC URL from wallet_config table"
      pattern: "getWalletConfig.*rpc_url"
    - from: "packages/wallet/src/governance/limits.ts"
      to: "packages/db/src/schema/spend-limits.ts"
      via: "reads active spend limits from DB"
      pattern: "spendLimits.*active"
    - from: "packages/wallet/src/governance/limits.ts"
      to: "packages/db/src/schema/wallet-transactions.ts"
      via: "sums today's spending from transaction log"
      pattern: "walletTransactions.*created_at"
---

<objective>
Build the balance reading system and spend governance layer for the Solana wallet.

Purpose: The agent needs to know what it has (balance reading) and be constrained in what it can spend (governance). Balance queries use the @solana/kit and @solana/spl-token libraries to fetch SOL and all SPL token balances. Governance checks per-transaction and daily aggregate limits from the DB before any send is allowed, with Discord notification on breach.

Output: Balance query functions, wallet config reader, spend limit enforcement, and operator breach notifications — all in @jarvis/wallet.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-wallet-and-financial-governance/04-RESEARCH.md
@.planning/phases/04-wallet-and-financial-governance/04-01-SUMMARY.md

@packages/wallet/src/index.ts
@packages/wallet/package.json
@packages/db/src/schema/wallet-transactions.ts
@packages/db/src/schema/spend-limits.ts
@packages/db/src/schema/wallet-config.ts
@packages/ai/src/discord.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Balance reading and wallet config</name>
  <files>
    packages/wallet/src/client/balance.ts
    packages/wallet/src/client/config.ts
    packages/wallet/src/index.ts
    packages/wallet/package.json
  </files>
  <action>
    **Add Solana dependencies to @jarvis/wallet package.json:**
    - Add `@solana/spl-token` (latest) — for SPL token account queries, ATA management, TOKEN_PROGRAM_ID/TOKEN_2022_PROGRAM_ID constants
    - Add `@solana/web3.js` (^1.x) — required by @solana/spl-token for Connection class (spl-token uses v1 API surface)
    - Note: @solana/kit was already added in Plan 01 for the signer. Both coexist fine in Node.js.
    - Run `pnpm install` after updating package.json.

    **Wallet config reader (config.ts):**
    - `getWalletConfig(db: DbClient, key: string): Promise<string | null>` — reads a single config value from wallet_config table where key matches and active=true. Returns null if not found.
    - `getRequiredWalletConfig(db: DbClient, key: string): Promise<string>` — like getWalletConfig but throws if null (for required configs like rpc_url, wallet_public_key).
    - `setWalletConfig(db: DbClient, key: string, value: string, description?: string): Promise<void>` — upsert pattern: if key exists, update value + updatedAt; if not, insert. This allows the AI to update its own config.
    - Import `db` types from @jarvis/db (using DbClient type). Import `walletConfig, eq` from @jarvis/db.
    - Common config keys (document as constants):
      - `rpc_url`: Solana RPC HTTP endpoint (e.g., mainnet-beta)
      - `wss_url`: Solana RPC WebSocket endpoint
      - `wallet_public_key`: The agent's wallet public key (base58)
      - `balance_poll_interval_ms`: Polling interval (default 60000)
      - `jupiter_api_key`: Optional Jupiter API key

    **Balance reading (balance.ts):**
    - Types:
      - `TokenBalance`: `{ mint: string; amount: string; decimals: number; uiAmount: number }` (amount as string for BigInt safety, uiAmount as convenience float)
      - `WalletBalances`: `{ sol: { lamports: string; sol: number }; tokens: TokenBalance[] }`
    - `getBalances(db: DbClient): Promise<WalletBalances>` — reads RPC URL and wallet public key from wallet_config table via getRequiredWalletConfig, then:
      1. **SOL balance:** Use @solana/kit `createSolanaRpc(rpcUrl)` then `rpc.getBalance(address(publicKey)).send()`. Return lamports as string and SOL as number (lamports / 1e9).
      2. **SPL token balances:** Use @solana/web3.js v1 `Connection` + `getParsedTokenAccountsByOwner` against both `TOKEN_PROGRAM_ID` and `TOKEN_2022_PROGRAM_ID`. This returns parsed account data with mint, amount, and decimals. Map to TokenBalance[].
      3. Combine into WalletBalances and return.
    - Error handling: wrap RPC calls in try/catch. On RPC failure, throw descriptive error (include RPC URL minus any API key query params). Do NOT retry — the agent's decision loop handles retries.

    **Update index.ts:** Re-export getBalances, getWalletConfig, getRequiredWalletConfig, setWalletConfig, TokenBalance, WalletBalances.

    **Update package.json:** Run `pnpm install` after adding deps, then `pnpm --filter @jarvis/wallet build` to verify.
  </action>
  <verify>
    - `pnpm --filter @jarvis/wallet build` succeeds with no TypeScript errors
    - balance.ts imports compile correctly against @solana/kit and @solana/spl-token
    - config.ts functions accept DbClient and use correct drizzle operators
    - Types TokenBalance and WalletBalances are exported from the package index
  </verify>
  <done>
    Agent can query SOL balance (via @solana/kit) and all SPL token balances (via @solana/spl-token with both TOKEN_PROGRAM_ID and TOKEN_2022_PROGRAM_ID). Wallet configuration (RPC URL, public key) is read from the wallet_config DB table, not from environment variables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Spend governance with limit enforcement and Discord notification</name>
  <files>
    packages/wallet/src/governance/limits.ts
    packages/wallet/src/governance/notify.ts
    packages/wallet/src/index.ts
  </files>
  <action>
    **Spend limit enforcement (limits.ts):**
    - `SpendCheckResult`: `{ allowed: boolean; reason?: string }`
    - `checkSpendLimits(db: DbClient, amountLamports: bigint, tokenMint?: string): Promise<SpendCheckResult>`:
      1. Load the active spend limit row from `spend_limits` table (where active=true). If no active limit exists, return `{ allowed: true }` — no limits configured means allow everything (per locked decision: "high generous defaults").
      2. **Per-transaction check:** If amountLamports > BigInt(limits.perTransactionLamports), return `{ allowed: false, reason: 'Exceeds per-transaction limit of X lamports' }`.
      3. **Daily aggregate check:** Query `wallet_transactions` table for sum of amount_lamports where status IN ('submitted', 'confirmed') AND created_at >= NOW() - INTERVAL '24 hours'. This is a rolling 24-hour window (per research Pitfall 5 recommendation — avoids timezone ambiguity). Use `sql` template tag from @jarvis/db for the interval arithmetic.
         - If todaySpent + amountLamports > BigInt(limits.dailyAggregateLamports), return `{ allowed: false, reason: 'Would exceed daily aggregate limit of X lamports' }`.
      4. Return `{ allowed: true }`.
    - `getActiveSpendLimit(db: DbClient): Promise<SpendLimit | null>` — helper that returns the active limit row or null.
    - `getTodaySpentLamports(db: DbClient): Promise<bigint>` — helper that calculates rolling 24h aggregate.

    **Operator notification (notify.ts):**
    - `notifySpendLimitBreach(reason: string, amountLamports: bigint, purpose: string): Promise<void>`:
      - Reads DISCORD_BOT_TOKEN and DISCORD_OPERATOR_USER_ID from env vars (same pattern as Phase 2/3)
      - If either is missing, log to stderr and return (non-fatal, per established pattern)
      - Sends Discord DM using the existing `sendOperatorDm` from @jarvis/ai: message format is "[WALLET] Spend limit breached: {reason}. Transaction: {amount} lamports for '{purpose}'"
      - Wrap in try/catch — Discord failure must never block governance decisions (non-fatal pattern)
    - `notifyHighValueTransaction(amountLamports: bigint, destination: string, purpose: string, db: DbClient): Promise<void>`:
      - Reads the active spend limit's notifyAboveLamports threshold from DB
      - If amountLamports > threshold, sends Discord DM: "[WALLET] High-value transaction: {amount} lamports to {destination} for '{purpose}'"
      - Same non-fatal Discord pattern

    NOTE: notify.ts must import sendOperatorDm from @jarvis/ai. This means @jarvis/wallet needs @jarvis/ai as a dependency. Add `"@jarvis/ai": "workspace:*"` to package.json dependencies and run `pnpm install`.

    **Update index.ts:** Re-export checkSpendLimits, SpendCheckResult, getActiveSpendLimit, getTodaySpentLamports, notifySpendLimitBreach, notifyHighValueTransaction.

    Run `pnpm --filter @jarvis/wallet build` to verify compilation.
  </action>
  <verify>
    - `pnpm --filter @jarvis/wallet build` succeeds
    - limits.ts uses BigInt comparisons consistently (no parseFloat on lamport amounts)
    - limits.ts uses rolling 24-hour window for daily aggregate (not calendar day)
    - notify.ts handles missing Discord env vars gracefully (stderr log, no throw)
    - All governance functions are exported from package index
  </verify>
  <done>
    Spend governance enforces per-transaction and daily aggregate limits from the DB. On limit breach, transaction is rejected with a clear reason and operator receives a Discord DM. High-value transactions (above configurable threshold) also trigger operator notification. All limits are runtime-mutable via the spend_limits DB table.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @jarvis/wallet build` compiles with no errors
2. Balance query types (WalletBalances, TokenBalance) are exported
3. Governance check returns `{ allowed: false }` when amount exceeds limits (verifiable in future integration test)
4. Daily aggregate uses rolling 24-hour window, not calendar-day reset
5. Operator notification is non-fatal (Discord failure does not throw)
</verification>

<success_criteria>
- Balance queries can fetch SOL and all SPL token balances via RPC
- Wallet config is read from DB table (not env vars) per locked decision
- Spend limit check rejects per-tx violations and daily aggregate violations
- Discord DM fires on limit breach and high-value transactions (non-fatal if Discord is unavailable)
</success_criteria>

<output>
After completion, create `.planning/phases/04-wallet-and-financial-governance/04-02-SUMMARY.md`
</output>
