---
phase: 04-wallet-and-financial-governance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/wallet-transactions.ts
  - packages/db/src/schema/spend-limits.ts
  - packages/db/src/schema/wallet-config.ts
  - packages/db/src/schema/index.ts
  - packages/db/drizzle.config.ts
  - packages/wallet/package.json
  - packages/wallet/tsconfig.json
  - packages/wallet/src/index.ts
  - packages/wallet/src/signer/protocol.ts
  - packages/wallet/src/signer/server.ts
  - packages/wallet/src/client/signer-client.ts
autonomous: true
requirements:
  - WALLET-04
  - WALLET-06

user_setup:
  - service: solana-signer
    why: "Signing co-process needs a private key and shared secret"
    env_vars:
      - name: SOLANA_PRIVATE_KEY
        source: "Solana CLI keypair export (JSON array-of-numbers format) or base58 string"
      - name: SIGNER_SHARED_SECRET
        source: "Generate with: openssl rand -hex 32"
      - name: SIGNER_SOCKET_PATH
        source: "Auto-generated default: /tmp/jarvis-signer.sock (override if needed)"

must_haves:
  truths:
    - "Wallet transaction schema exists with tx_signature, destination, amount, purpose, and status tracking"
    - "Spend limits schema exists with per-transaction and daily aggregate limits stored in DB"
    - "Wallet config schema stores Solana configuration (RPC URL, etc.) in DB, not in env vars"
    - "Signing co-process loads private key from env and signs arbitrary Solana transactions"
    - "Agent-side signer client sends unsigned tx bytes and receives signed tx bytes via Unix socket IPC"
    - "Private key never appears outside the signer process — not in IPC messages, not in logs"
    - "IPC authentication uses HMAC-SHA256 with timing-safe comparison"
  artifacts:
    - path: "packages/db/src/schema/wallet-transactions.ts"
      provides: "Transaction audit table with status enum"
      contains: "walletTransactions"
    - path: "packages/db/src/schema/spend-limits.ts"
      provides: "Runtime-mutable spend governance limits"
      contains: "spendLimits"
    - path: "packages/db/src/schema/wallet-config.ts"
      provides: "Key-value Solana config stored in DB"
      contains: "walletConfig"
    - path: "packages/wallet/src/signer/server.ts"
      provides: "Unix socket signing co-process"
      contains: "createServer"
    - path: "packages/wallet/src/client/signer-client.ts"
      provides: "Agent-side IPC client for signing"
      contains: "SignerClient"
    - path: "packages/wallet/src/signer/protocol.ts"
      provides: "Zod-validated IPC wire format"
      contains: "SignRequest"
  key_links:
    - from: "packages/wallet/src/client/signer-client.ts"
      to: "packages/wallet/src/signer/server.ts"
      via: "Unix socket IPC with HMAC auth"
      pattern: "createConnection.*SOCKET_PATH"
    - from: "packages/db/src/schema/index.ts"
      to: "packages/db/src/schema/wallet-transactions.ts"
      via: "barrel re-export"
      pattern: "export.*wallet-transactions"
---

<objective>
Create the database schemas for wallet governance and transaction audit, scaffold the @jarvis/wallet package, and build the IPC signing co-process with its agent-side client.

Purpose: Establishes the financial data foundation (transaction log, spend limits, config) and the critical trust boundary — the signing co-process holds the private key in isolation, communicates only via authenticated Unix socket IPC, and never exposes key material to the agent process.

Output: Three new DB schema files pushed to Postgres, a new @jarvis/wallet package with the signing server and client, and a Zod-validated IPC protocol.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-wallet-and-financial-governance/04-RESEARCH.md

@packages/db/src/schema/operating-costs.ts
@packages/db/src/schema/index.ts
@packages/db/drizzle.config.ts
@packages/db/package.json
@packages/tools/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: DB schemas for wallet transactions, spend limits, and config</name>
  <files>
    packages/db/src/schema/wallet-transactions.ts
    packages/db/src/schema/spend-limits.ts
    packages/db/src/schema/wallet-config.ts
    packages/db/src/schema/index.ts
    packages/db/drizzle.config.ts
  </files>
  <action>
    Create three new schema files following the project's established Drizzle patterns (see operating-costs.ts for reference):

    **wallet-transactions.ts:**
    - pgEnum `wallet_tx_status` with values: `submitted`, `confirmed`, `failed`, `rejected`
    - pgTable `wallet_transactions` with columns:
      - `id`: integer PK, generatedAlwaysAsIdentity
      - `tx_signature`: text, nullable (null until submitted to network)
      - `token_mint`: text, notNull, default 'sol' (mint address for SPL tokens, 'sol' for native)
      - `destination_address`: text, nullable (null for rejected/inbound)
      - `amount_lamports`: text, notNull (text not BigInt — matches research guidance on precision)
      - `purpose`: text, notNull (AI self-reported free text — WALLET-06)
      - `status`: txStatusEnum, notNull, default 'submitted'
      - `rejection_reason`: text, nullable
      - `created_at`: timestamp with timezone, defaultNow, notNull
      - `confirmed_at`: timestamp with timezone, nullable
    - Export WalletTransaction and NewWalletTransaction types

    **spend-limits.ts:**
    - pgTable `spend_limits` with columns:
      - `id`: integer PK, generatedAlwaysAsIdentity
      - `per_transaction_lamports`: text, notNull (text for BigInt safety)
      - `daily_aggregate_lamports`: text, notNull
      - `notify_above_lamports`: text, notNull (operator notification threshold)
      - `active`: boolean, notNull, default true (only one row should be active)
      - `description`: text, nullable
      - `created_at`: timestamp with timezone, defaultNow, notNull
      - `updated_at`: timestamp with timezone, defaultNow, notNull
    - Export SpendLimit and NewSpendLimit types

    **wallet-config.ts:**
    - pgTable `wallet_config` with columns:
      - `id`: integer PK, generatedAlwaysAsIdentity
      - `key`: text, notNull, unique (e.g. 'rpc_url', 'wss_url', 'wallet_public_key', 'jupiter_api_key')
      - `value`: text, notNull
      - `description`: text, nullable
      - `active`: boolean, notNull, default true
      - `updated_at`: timestamp with timezone, defaultNow, notNull
    - Export WalletConfig and NewWalletConfig types

    Per locked decision: All Solana configuration stored in DB, not env vars. Mainnet-beta only.

    **Update schema/index.ts:** Add three new barrel re-exports.
    **Update drizzle.config.ts:** Add three new schema file paths to the schema array. Per decision 01-01: enumerate individual files, not barrel.

    Run `pnpm --filter @jarvis/db build` then `pnpm --filter @jarvis/db db:push` to push schemas to Postgres.
  </action>
  <verify>
    - `pnpm --filter @jarvis/db build` succeeds with no TypeScript errors
    - `pnpm --filter @jarvis/db db:push` succeeds (tables created in Postgres)
    - `psql` query confirms `wallet_transactions`, `spend_limits`, `wallet_config` tables exist
    - `psql` query confirms `wallet_tx_status` enum exists with 4 values
  </verify>
  <done>
    Three new tables (wallet_transactions, spend_limits, wallet_config) exist in Postgres with correct columns and types. All types are exported from @jarvis/db. drizzle.config.ts includes all three new schema files.
  </done>
</task>

<task type="auto">
  <name>Task 2: @jarvis/wallet package with IPC signing service and client</name>
  <files>
    packages/wallet/package.json
    packages/wallet/tsconfig.json
    packages/wallet/src/index.ts
    packages/wallet/src/signer/protocol.ts
    packages/wallet/src/signer/server.ts
    packages/wallet/src/client/signer-client.ts
  </files>
  <action>
    **Scaffold @jarvis/wallet package:**
    - package.json: name "@jarvis/wallet", type "module", main/types pointing to dist/, exports map matching @jarvis/db pattern. Scripts: "build": "tsc", "signer": "tsx src/signer/server.ts" (dev runner for the signer process).
    - Dependencies: `@jarvis/db` (workspace:*), `zod` (^3.24.2), `bs58` (latest). The signer server uses only node:net, node:crypto, and @solana/kit for signing — add `@solana/kit` as a dependency.
    - devDependencies: @jarvis/typescript-config (workspace:*), tsx, typescript (match existing packages)
    - tsconfig.json: extends @jarvis/typescript-config with outDir dist/, rootDir src/, composite true (match @jarvis/db pattern)

    **IPC Protocol (protocol.ts):**
    - Zod schemas for the wire format:
      - `SignRequest`: object with `hmac` (string, length 64 hex), `txBase64` (string, min 1), `requestId` (string uuid for log correlation — never logged by signer)
      - `SignResponse`: discriminated union on `ok` field:
        - Success: `{ ok: true, signedTxBase64: string, requestId: string }`
        - Error: `{ ok: false, error: 'auth_failed' | 'sign_error' | 'invalid_tx', requestId: string }`
    - Export types and schemas

    **Signer Server (server.ts):**
    - Standalone Node.js process — this file is the entry point (run directly via `tsx` or `node`)
    - Reads env vars at startup: `SIGNER_SOCKET_PATH` (default /tmp/jarvis-signer.sock), `SIGNER_SHARED_SECRET`, `SOLANA_PRIVATE_KEY`
    - Validates all env vars present, exits with clear error if missing
    - Loads keypair: parse SOLANA_PRIVATE_KEY (support both JSON array-of-numbers and base58 formats). Use @solana/kit `createKeyPairFromBytes` to get the signing key. If the format is base58, use bs58.decode first.
    - CRITICAL: Never log the private key or any key material. Only log the public key address at startup for verification.
    - Clean stale socket file if exists (unlinkSync)
    - Create Unix socket server (node:net createServer)
    - On connection: buffer data until newline delimiter, parse JSON, validate with SignRequest Zod schema
    - HMAC verification: compute HMAC-SHA256 of txBase64 using SHARED_SECRET, compare with `timingSafeEqual` (node:crypto). On mismatch: respond with `{ ok: false, error: 'auth_failed' }`.
    - Sign the transaction: decode txBase64 from base64, use @solana/kit transaction signing to sign the bytes, re-encode as base64.
      - NOTE: @solana/kit's signing API works with KeyPairSigner. Use `signTransaction` from the signer. The transaction is already fully constructed — the signer just adds its signature.
    - Write response as JSON + newline
    - Register SIGTERM/SIGINT handlers: unlink socket file, close server, exit cleanly
    - Set socket file permissions to 0o600 after server.listen (defense in depth alongside HMAC)
    - After server.listen succeeds, send IPC ready message: `if (process.send) process.send('ready')` — this allows the parent process (agent) to know when the signer is accepting connections. Guard with `if (process.send)` so the server can also run standalone without IPC.

    **Signer Client (signer-client.ts):**
    - `SignerClient` class with constructor taking `socketPath: string` and `sharedSecret: string`
    - Method `signTransaction(txBase64: string): Promise<string>` — returns signed tx base64
      - Generates a UUID requestId for log correlation
      - Computes HMAC-SHA256 of txBase64 using sharedSecret
      - Opens Unix socket connection to socketPath
      - Sends JSON `{ hmac, txBase64, requestId }` + newline
      - Buffers response until newline, parses JSON, validates with SignResponse Zod schema
      - On `ok: true`: returns signedTxBase64
      - On `ok: false`: throws Error with the error code
      - Implements a 10-second timeout (socket.setTimeout) — throws on timeout
      - Always destroys the socket in a finally block
    - Method `ping(): Promise<boolean>` — attempts a connection to verify signer is running (connect then immediately destroy; returns true on success, false on error)

    **Index (index.ts):**
    - Re-export: SignerClient, SignRequest, SignResponse, and types

    Run `pnpm install` from workspace root (registers new package), then `pnpm --filter @jarvis/wallet build` to verify TypeScript compilation.
  </action>
  <verify>
    - `pnpm install` succeeds (new workspace package registered)
    - `pnpm --filter @jarvis/wallet build` succeeds with no TypeScript errors
    - packages/wallet/dist/ contains compiled .js and .d.ts files
    - server.ts contains no instances of logging the private key (grep for PRIVATE_KEY in console.log/stderr.write should only find the env var read, not any output)
    - protocol.ts Zod schemas parse valid inputs and reject invalid inputs
  </verify>
  <done>
    @jarvis/wallet package exists with a compilable signing server (Unix socket + HMAC auth), a client that can sign transactions over IPC, and a Zod-validated protocol. Private key is loaded only inside the signer process and never exposed in any IPC message, log output, or export.
  </done>
</task>

</tasks>

<verification>
1. All three DB tables exist and are queryable: `SELECT * FROM wallet_transactions LIMIT 0; SELECT * FROM spend_limits LIMIT 0; SELECT * FROM wallet_config LIMIT 0;`
2. @jarvis/wallet builds without errors: `pnpm --filter @jarvis/wallet build`
3. No private key material in any log statement: `grep -r 'PRIVATE_KEY' packages/wallet/src/ | grep -v 'process.env'` should show no console/stderr output lines
4. IPC protocol types are importable: `import { SignerClient, SignRequest, SignResponse } from '@jarvis/wallet'`
</verification>

<success_criteria>
- wallet_transactions, spend_limits, wallet_config tables pushed to Postgres with correct columns
- @jarvis/wallet package compiles and exports SignerClient + IPC protocol
- Signer server loads keypair from env, listens on Unix socket with HMAC auth
- No private key leakage in any code path outside the signer process
</success_criteria>

<output>
After completion, create `.planning/phases/04-wallet-and-financial-governance/04-01-SUMMARY.md`
</output>
