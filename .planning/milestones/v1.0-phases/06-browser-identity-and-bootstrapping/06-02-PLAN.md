---
phase: 06-browser-identity-and-bootstrapping
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - packages/tools/src/identity/index.ts
  - packages/tools/src/identity/credential-vault.ts
  - packages/tools/src/identity/create-identity.ts
  - packages/tools/src/identity/temp-email.ts
  - packages/tools/src/identity/retire-identity.ts
  - packages/tools/src/identity/operator-escalation.ts
  - packages/tools/src/index.ts
  - packages/tools/package.json
autonomous: true
requirements:
  - IDENT-01
  - IDENT-02
  - IDENT-03
  - IDENT-04
  - IDENT-05

must_haves:
  truths:
    - "Agent can store a credential encrypted with pgcrypto and retrieve it decrypted"
    - "Every credential access is logged in the audit trail with who, when, why"
    - "Agent can generate a full synthetic persona with name, email, backstory, address"
    - "Agent can create a temporary email address and poll for received messages"
    - "Agent can retire an identity and its credentials are archived"
    - "Agent can request operator credentials via Discord DM escalation"
  artifacts:
    - path: "packages/tools/src/identity/credential-vault.ts"
      provides: "storeCredential + retrieveCredential with pgcrypto encrypt/decrypt and audit logging"
      exports: ["storeCredential", "retrieveCredential", "listCredentials", "rotateCredential"]
    - path: "packages/tools/src/identity/create-identity.ts"
      provides: "identity_create ToolDefinition with faker persona generation"
      exports: ["createIdentityTool"]
    - path: "packages/tools/src/identity/temp-email.ts"
      provides: "temp_email_create and temp_email_check ToolDefinitions via Guerrilla Mail API"
      exports: ["createTempEmailTool", "checkTempEmailTool"]
    - path: "packages/tools/src/identity/retire-identity.ts"
      provides: "identity_retire ToolDefinition with status transition and credential archival"
      exports: ["retireIdentityTool"]
    - path: "packages/tools/src/identity/operator-escalation.ts"
      provides: "request_operator_credentials ToolDefinition with Discord DM"
      exports: ["requestOperatorCredentialsTool"]
  key_links:
    - from: "packages/tools/src/identity/credential-vault.ts"
      to: "pgcrypto"
      via: "sql template tag calling pgp_sym_encrypt/decrypt"
      pattern: "pgp_sym_encrypt|pgp_sym_decrypt"
    - from: "packages/tools/src/identity/credential-vault.ts"
      to: "packages/db/src/schema/credential-audit.ts"
      via: "insert audit row on every credential access"
      pattern: "credentialAccessAudit"
    - from: "packages/tools/src/identity/create-identity.ts"
      to: "@faker-js/faker"
      via: "faker.person/internet/location for persona generation"
      pattern: "faker\\."
    - from: "packages/tools/src/identity/temp-email.ts"
      to: "api.guerrillamail.com"
      via: "HTTP fetch to Guerrilla Mail JSON API"
      pattern: "guerrillamail"
---

<objective>
Create the identity management tool group: encrypted credential vault with audit trail, synthetic persona generation, temporary email, identity retirement, and operator escalation.

Purpose: These tools give the agent the ability to create and manage synthetic identities, securely store credentials, and handle verification flows autonomously. This is the identity half of Phase 6's core capability.

Output: 6 ToolDefinitions (identity_create, credential_store, credential_retrieve, temp_email_create, temp_email_check, identity_retire, request_operator_credentials) in packages/tools/src/identity/.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-browser-identity-and-bootstrapping/06-RESEARCH.md
@.planning/phases/06-browser-identity-and-bootstrapping/06-01-SUMMARY.md
@packages/tools/src/types.ts
@packages/tools/src/index.ts
@packages/tools/src/registry.ts
@packages/tools/src/wallet/index.ts
@packages/db/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create credential vault with pgcrypto encryption and audit logging</name>
  <files>
    packages/tools/src/identity/credential-vault.ts
    packages/tools/package.json
  </files>
  <action>
Create packages/tools/src/identity/credential-vault.ts — the encrypted credential vault.

This module provides functions (NOT ToolDefinitions) that identity tools call internally. It also exports two ToolDefinitions (credential_store, credential_retrieve) for direct agent use.

**Core functions:**

`storeCredential(db, params)`: params = { identityId?: string, service: string, key: string, value: string, expiresAt?: Date }
- Gets CREDENTIAL_ENCRYPTION_KEY from process.env (throw if missing with clear error)
- Executes raw SQL via db.execute(sql`INSERT INTO credentials (id, identity_id, service, key, encrypted_value, status, created_at, expires_at) VALUES (gen_random_uuid(), ${identityId}, ${service}, ${key}, pgp_sym_encrypt(${value}, ${encKey}, 'cipher-algo=aes256'), 'active', now(), ${expiresAt})`)
- Returns the credential id
- IMPORTANT: import sql from '@jarvis/db' (not drizzle-orm — pnpm strict isolation, @jarvis/tools does not depend on drizzle-orm)

`retrieveCredential(db, params)`: params = { identityId: string, service: string, key: string, accessedBy: string, purpose: string }
- Gets CREDENTIAL_ENCRYPTION_KEY from process.env
- Executes: SELECT id, pgp_sym_decrypt(encrypted_value::bytea, ${encKey}) as value FROM credentials WHERE identity_id = ${identityId} AND service = ${service} AND key = ${key} AND status = 'active'
- BEFORE returning, insert audit row: INSERT INTO credential_access_audit (id, credential_id, accessed_by, purpose, identity_id, accessed_at) VALUES (gen_random_uuid(), ${credId}, ${accessedBy}, ${purpose}, ${identityId}, now())
- Returns { value: string, credentialId: string } or null if not found

`listCredentials(db, identityId)`: SELECT id, service, key, status, created_at, expires_at FROM credentials WHERE identity_id = ${identityId} (no decrypt — metadata only for dashboard/agent overview)

`rotateCredential(db, params)`: params = { credentialId: string, newValue: string }
- UPDATE existing credential status = 'rotated'
- INSERT new credential row with same identity_id/service/key but new encrypted value
- Returns new credential id

**ToolDefinitions:**

`createCredentialStoreTool(db)`: factory returning ToolDefinition. Name: 'credential_store'. Input schema: { identityId?: string, service: string, key: string, value: string, expiresAt?: string (ISO date) }. Calls storeCredential. Returns { credentialId }.

`createCredentialRetrieveTool(db)`: factory returning ToolDefinition. Name: 'credential_retrieve'. Input schema: { identityId: string, service: string, key: string, purpose: string }. Calls retrieveCredential with accessedBy='agent-tool'. Returns { value } or { error: 'not found' }.

Per locked decision: agent gets full access to raw credential values. No redaction.

Add @faker-js/faker as a dependency to packages/tools/package.json (needed by Task 2's create-identity, adding here to avoid package.json conflict).

IMPORTANT: The sql import must come from '@jarvis/db'. The schema table references (for typed inserts via drizzle) should be imported from '@jarvis/db' as well. However, for pgcrypto operations, use raw SQL via db.execute(sql`...`) since Drizzle doesn't natively support pgcrypto functions.
  </action>
  <verify>
1. `pnpm --filter @jarvis/tools run build` exits 0
2. Run verification script against live DB:
```
pnpm --filter @jarvis/tools exec tsx -e "
import { db } from '@jarvis/db';
import { storeCredential, retrieveCredential, listCredentials } from './src/identity/credential-vault.js';
// Requires CREDENTIAL_ENCRYPTION_KEY env var
process.env.CREDENTIAL_ENCRYPTION_KEY = 'test-key-for-verification';
const cred = await storeCredential(db, { service: 'test-service', key: 'api_key', value: 'secret-value-123' });
console.log('stored:', cred);
const retrieved = await retrieveCredential(db, { identityId: undefined as any, service: 'test-service', key: 'api_key', accessedBy: 'test', purpose: 'verification' });
console.log('retrieved:', retrieved?.value === 'secret-value-123' ? 'PASS' : 'FAIL');
process.exit(0);
"
```
  </verify>
  <done>
Credential vault stores encrypted credentials via pgcrypto, retrieves them with decryption, logs every access to credential_access_audit, supports rotation and listing. Two ToolDefinitions (credential_store, credential_retrieve) export as factories. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create identity lifecycle tools (create, temp email, retire, operator escalation)</name>
  <files>
    packages/tools/src/identity/create-identity.ts
    packages/tools/src/identity/temp-email.ts
    packages/tools/src/identity/retire-identity.ts
    packages/tools/src/identity/operator-escalation.ts
    packages/tools/src/identity/index.ts
    packages/tools/src/index.ts
  </files>
  <action>
Create four tool modules in packages/tools/src/identity/:

**create-identity.ts**: `createIdentityTool(db)` factory returning ToolDefinition.
- Name: 'identity_create'
- Input: { locale?: string (default 'en'), notes?: string }
- Uses @faker-js/faker to generate full persona:
  - firstName, lastName, fullName via faker.person
  - email via faker.internet.email({ firstName, lastName })
  - phone via faker.phone.number()
  - address (street, city, state, zip, country) via faker.location
  - dateOfBirth via faker.date.birthdate({ min: 25, max: 50, mode: 'age' })
  - bio via faker.person.bio()
  - jobTitle via faker.person.jobTitle()
  - username via faker.internet.username({ firstName, lastName })
  - password via faker.internet.password({ length: 16, memorable: false })
  - profilePictureUrl: 'https://thispersondoesnotexist.com' (per research — returns random AI face per GET)
- Inserts into identities table with persona as JSONB
- Stores the generated password via storeCredential (service: 'identity', key: 'master_password')
- Returns: { identityId, name, email, username }

**temp-email.ts**: Two ToolDefinitions.

`createTempEmailTool()`: factory returning ToolDefinition.
- Name: 'temp_email_create'
- Input: {} (no params)
- Calls Guerrilla Mail API: `fetch('http://api.guerrillamail.com/ajax.php?f=get_email_address')`
- Returns: { emailAddress: string, sidToken: string }
- NOTE: The API returns { email_addr, sid_token }. Map these to camelCase.

`createCheckTempEmailTool()`: factory returning ToolDefinition.
- Name: 'temp_email_check'
- Input: { sidToken: string, timeoutMs?: number (default 60000) }
- Polls Guerrilla Mail for new emails: GET `?f=get_email_list&offset=0&sid_token={sidToken}`
- Uses minimum 5-second delay between polls (per research anti-pattern: tight polling triggers rate limits)
- Maximum 10 attempts before returning null
- If email found, fetches body via `?f=fetch_email&email_id={id}&sid_token={sidToken}`
- Returns: { found: boolean, body?: string, subject?: string } or { found: false } on timeout

**retire-identity.ts**: `createRetireIdentityTool(db)` factory returning ToolDefinition.
- Name: 'identity_retire'
- Input: { identityId: string, reason: string }
- Updates identity status from 'active' to 'retired', sets retiredAt = now(), appends reason to notes
- Updates all credentials for this identity: status = 'archived' (per locked decision: retired identity = archived credentials)
- Returns: { retired: true, credentialsArchived: number }

**operator-escalation.ts**: `createRequestOperatorCredentialsTool(db)` factory returning ToolDefinition.
- Name: 'request_operator_credentials'
- Input: { service: string, credentialType: string, reason: string }
- Sends Discord DM to operator using existing pattern from Phase 3 (sendOperatorDm pattern — create short-lived Discord client from DISCORD_TOKEN env var, send DM to DISCORD_OPERATOR_USER_ID)
- Message format: "Jarvis needs your credentials for {service} ({credentialType}). Reason: {reason}. Reply with the credential value or 'deny'."
- Does NOT wait for reply (the agent will check back later — the Discord DM is fire-and-forget from the tool's perspective)
- Returns: { requested: true, message: 'Operator notified via Discord DM. Check back later.' }
- If Discord env vars not set: returns { requested: false, error: 'DISCORD_TOKEN not configured — cannot reach operator' }

**index.ts**: Barrel export all factories:
```typescript
export { createCredentialStoreTool, createCredentialRetrieveTool, storeCredential, retrieveCredential, listCredentials, rotateCredential } from './credential-vault.js';
export { createIdentityTool } from './create-identity.js';
export { createTempEmailTool, createCheckTempEmailTool } from './temp-email.js';
export { createRetireIdentityTool } from './retire-identity.js';
export { createRequestOperatorCredentialsTool } from './operator-escalation.js';
```

**Update packages/tools/src/index.ts**: Add identity tool exports:
```typescript
// Identity tools (Phase 06)
export { createIdentityTools } from './identity/index.js';
```

Also add a convenience factory `createIdentityTools(db)` in the identity/index.ts that returns all identity ToolDefinitions as an array (pattern: same as createWalletTools).

For all DB operations, use `sql` imported from `'@jarvis/db'`. For schema table references in typed Drizzle queries (select/insert/update), import table objects from `'@jarvis/db'`.
  </action>
  <verify>
1. `pnpm --filter @jarvis/tools run build` exits 0
2. Verify the identity barrel export: `pnpm --filter @jarvis/tools exec tsx -e "import { createIdentityTools } from './src/identity/index.js'; console.log('exported'); process.exit(0);"`
3. Verify faker integration: `pnpm --filter @jarvis/tools exec tsx -e "import { faker } from '@faker-js/faker'; console.log(faker.person.firstName(), faker.person.lastName()); process.exit(0);"`
  </verify>
  <done>
Identity tool group complete: identity_create (faker persona), temp_email_create/check (Guerrilla Mail), identity_retire (status + credential archival), request_operator_credentials (Discord DM), credential_store/retrieve (pgcrypto vault). All exported via createIdentityTools(db) factory. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @jarvis/tools run build` — full package compiles with identity tools
2. Credential store/retrieve round-trip verified against live Postgres with pgcrypto
3. Audit trail row created on credential retrieval
4. All 7 ToolDefinitions accessible via createIdentityTools(db)
</verification>

<success_criteria>
- credential_store encrypts via pgcrypto, credential_retrieve decrypts and logs audit row
- identity_create generates faker persona and inserts into identities table
- temp_email_create returns a Guerrilla Mail address and sid_token
- identity_retire transitions status and archives credentials
- request_operator_credentials sends Discord DM (or degrades gracefully if not configured)
- All tools follow ToolDefinition interface with zod inputSchema
</success_criteria>

<output>
After completion, create `.planning/phases/06-browser-identity-and-bootstrapping/06-02-SUMMARY.md`
</output>
