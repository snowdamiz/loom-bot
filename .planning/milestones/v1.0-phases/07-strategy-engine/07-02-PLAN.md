---
phase: 07-strategy-engine
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - apps/agent/src/strategy/strategy-prompts.ts
  - apps/agent/src/loop/agent-loop.ts
  - apps/agent/src/multi-agent/supervisor.ts
  - apps/agent/src/index.ts
  - apps/dashboard/src/routes/api.ts
  - apps/dashboard/src/app.ts
autonomous: true
requirements:
  - STRAT-01
  - STRAT-02
  - STRAT-03
  - STRAT-04
  - STRAT-05
  - STRAT-06
  - STRAT-08

must_haves:
  truths:
    - "Agent receives strategy portfolio context in every sub-goal system prompt"
    - "Portfolio context lists strategies with status and hypothesis only — no financial data"
    - "Portfolio context is domain-agnostic — no money-specific guidance"
    - "Supervisor passes strategy context to each AgentLoop it spawns"
    - "StrategyManager is wired into agent startup and accessible during execution"
    - "Operator can seed a goal via dashboard API that becomes the first strategy"
    - "evaluator.ts is NOT modified"
  artifacts:
    - path: "apps/agent/src/strategy/strategy-prompts.ts"
      provides: "Domain-agnostic portfolio context prompt builder"
      exports: ["buildPortfolioContextPrompt"]
    - path: "apps/agent/src/loop/agent-loop.ts"
      provides: "Strategy context injection into executeSubGoal system prompt"
      contains: "strategyContext"
    - path: "apps/agent/src/multi-agent/supervisor.ts"
      provides: "Strategy context passed to spawned AgentLoops"
      contains: "strategyManager"
    - path: "apps/agent/src/index.ts"
      provides: "StrategyManager wired at startup"
      contains: "StrategyManager"
    - path: "apps/dashboard/src/routes/api.ts"
      provides: "Goal seeding endpoint for operator"
      contains: "strategies"
  key_links:
    - from: "apps/agent/src/strategy/strategy-prompts.ts"
      to: "apps/agent/src/loop/agent-loop.ts"
      via: "buildPortfolioContextPrompt called and injected into system prompt"
      pattern: "buildPortfolioContextPrompt"
    - from: "apps/agent/src/multi-agent/supervisor.ts"
      to: "apps/agent/src/strategy/strategy-manager.ts"
      via: "Supervisor uses StrategyManager to get strategy list per goal"
      pattern: "strategyManager"
    - from: "apps/agent/src/index.ts"
      to: "apps/agent/src/strategy/strategy-manager.ts"
      via: "StrategyManager instantiated at startup"
      pattern: "new StrategyManager"
    - from: "apps/dashboard/src/app.ts"
      to: "apps/dashboard/src/routes/api.ts"
      via: "Route mounted with app.route('/api', apiRoute)"
      pattern: "app\\.route.*apiRoute"
---

<objective>
Wire the strategy engine into the agent's autonomous loop so the LLM receives a domain-agnostic portfolio context in every planning cycle, and the operator can seed goals via the dashboard.

Purpose: The data model from Plan 01 is inert without integration. This plan makes strategies visible to the LLM by injecting a simple portfolio listing into every sub-goal prompt and wires the StrategyManager into the agent's startup sequence. The operator can seed the initial goal that triggers the agent's autonomous strategy discovery.

The portfolio context is intentionally minimal and domain-agnostic: it lists what the agent is pursuing and in what state. The agent uses its own LLM reasoning and existing tools (db, http, browser, shell) to evaluate strategies, research opportunities, and make all decisions. No domain-specific logic is baked into the wiring.

Output: Portfolio prompt builder, agent-loop strategy context injection, supervisor strategy wiring, startup integration, and a goal-seeding dashboard API endpoint.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-strategy-engine/07-RESEARCH.md
@.planning/phases/07-strategy-engine/07-01-SUMMARY.md

@apps/agent/src/loop/agent-loop.ts
@apps/agent/src/multi-agent/supervisor.ts
@apps/agent/src/index.ts
@apps/agent/src/strategy/strategy-manager.ts
@apps/dashboard/src/app.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create domain-agnostic portfolio prompt builder and inject strategy context into agent loop</name>
  <files>
    apps/agent/src/strategy/strategy-prompts.ts
    apps/agent/src/loop/agent-loop.ts
  </files>
  <action>
    **Create `apps/agent/src/strategy/strategy-prompts.ts`:**

    This module builds a compact, domain-agnostic portfolio summary that gets injected into every sub-goal system prompt. Must stay under ~500 tokens to avoid context window overflow (research pitfall #5).

    ```typescript
    import type { Strategy } from '@jarvis/db';
    ```

    **`buildPortfolioContextPrompt(strategies: Strategy[]): string`**

    Takes plain `Strategy[]`. The prompt contains zero domain-specific data. The agent queries whatever it needs via its tools when its LLM reasoning decides to.

    If strategies array is empty, return:
    ```
    ACTIVE STRATEGIES: None.
    You have no active strategies. Analyze your goal and discover opportunities to pursue it.
    Use your available tools (web research, browser, db queries) to gather information and form hypotheses.
    ```

    If strategies exist, build a compact summary:
    ```
    ACTIVE STRATEGIES:
      [1] HYPOTHESIS: "Research freelance platforms for data analysis gigs"
          Goal #5 | Since: 2026-02-18
      [2] ACTIVE: "Monitor competitor pricing on 3 e-commerce sites"
          Goal #8 | Since: 2026-02-17
      [3] PAUSED: "Build Twitter bot for automated engagement"
          Goal #12 | Since: 2026-02-16 | Reason: Rate limited, waiting 24h

    You can use the db tool to query detailed information about any strategy.
    Evaluate your strategies, scale what works, kill what doesn't, and discover new approaches.
    ```

    Keep it to one line per strategy with status and hypothesis. Truncate hypothesis text to 80 chars. Show `lastTransitionReason` only for paused/killed strategies. The agent can always query the `db` tool for full details.

    **IMPORTANT: No domain-specific data in the prompt.** No financial figures, no metrics, no domain-specific guidance. The agent figures out evaluation criteria based on its goal using its own reasoning.

    **Modify `apps/agent/src/loop/agent-loop.ts`:**

    Add an optional `strategyContext?: string` parameter to the `AgentLoop` constructor (add it to `AgentLoopConfig` or as a separate constructor param — use a config field for cleanliness):

    Add to `AgentLoopConfig`:
    ```typescript
    /** Strategy portfolio context to inject into sub-goal system prompts */
    strategyContext?: string;
    ```

    Store as `private readonly strategyContext: string | undefined` in the constructor.

    In `executeSubGoal()`, inject the strategy context into the system prompt AFTER the sub-goal description and BEFORE the constraints section. Only inject if `this.strategyContext` is defined and non-empty.

    The existing system prompt in `executeSubGoal()` is a single `content: [...]..join('\n')` array. Replace it with the dynamic version:

    ```typescript
    const systemParts = [
      `You are an autonomous AI agent executing a specific sub-goal.`,
      ``,
      `SUB-GOAL: ${subGoal.description}`,
      ``,
    ];

    if (this.strategyContext) {
      systemParts.push(this.strategyContext, '');
    }

    systemParts.push(
      `CONSTRAINTS:`,
      `- Execute the sub-goal using the available tools.`,
      `- Be efficient: only call tools that are necessary.`,
      `- When the sub-goal is complete, respond with a final message summarizing what was accomplished.`,
      `- Do not ask clarifying questions — make reasonable decisions and proceed.`,
      ``,
      `AVAILABLE TOOLS:`,
      this.registry.list().map((t) => `- ${t.name}: ${t.description}`).join('\n'),
    );
    ```

    **IMPORTANT preservation note:** Keep the full AVAILABLE TOOLS section (`this.registry.list()` map) at the end of systemParts, and ALL existing constraint bullet points unchanged. Only insert the strategy context block between the SUB-GOAL line and the CONSTRAINTS header. The final `content` value is `systemParts.join('\n')`.

    **Do NOT modify `evaluator.ts`.** The evaluator continues to work exactly as it does today.

    **Do NOT:**
    - Add any domain-specific data to the portfolio prompt
    - Add any domain-specific guidance (money, monitoring, social media, etc.)
    - Modify the evaluator in any way
    - Make strategyContext a required parameter — backwards compatibility with non-strategy goals

    **Run `pnpm --filter @jarvis/agent build`** to verify TypeScript compilation.
  </action>
  <verify>
    `pnpm --filter @jarvis/agent build` succeeds with no TypeScript errors.
    `buildPortfolioContextPrompt` is exported from `strategy-prompts.ts` and takes `Strategy[]`.
    `AgentLoop` constructor accepts `strategyContext` via config.
    `executeSubGoal()` system prompt includes strategy context when provided.
    `evaluator.ts` is NOT modified.
    Portfolio prompt contains NO domain-specific data.
  </verify>
  <done>
    Domain-agnostic portfolio prompt builder creates compact strategy summaries with status and hypothesis only. AgentLoop injects strategy context into every sub-goal system prompt. Evaluator is untouched. All changes are backwards-compatible — non-strategy goals work exactly as before.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire StrategyManager into Supervisor, agent startup, and add goal-seeding API</name>
  <files>
    apps/agent/src/multi-agent/supervisor.ts
    apps/agent/src/index.ts
    apps/dashboard/src/routes/api.ts
    apps/dashboard/src/app.ts
  </files>
  <action>
    **Modify `apps/agent/src/multi-agent/supervisor.ts`:**

    Add `StrategyManager` as an optional constructor parameter (keeps backwards compat). Import:
    ```typescript
    import type { StrategyManager } from '../strategy/strategy-manager.js';
    import { buildPortfolioContextPrompt } from '../strategy/strategy-prompts.js';
    ```

    Add to constructor: `private readonly strategyManager?: StrategyManager` (add as the last parameter before `config?`).

    Modify `spawnMainAgent()`:
    - Before creating the `AgentLoop`, check if a strategy exists for this goal via `strategyManager.getStrategyByGoalId(goalId)`
    - If a strategy exists, get all strategies: `const allStrategies = await strategyManager.getStrategies();` then `const strategyContext = buildPortfolioContextPrompt(allStrategies);`
    - Pass `strategyContext` to the `AgentLoop` constructor via the config parameter
    - If no strategy exists for this goal (e.g., a plain goal without strategy metadata), pass `undefined` for strategyContext — the AgentLoop works the same as before

    The existing `AgentLoop` constructor already accepts config as the last param. Pass `strategyContext` in the config object:
    ```typescript
    const agentLoop = new AgentLoop(
      this.router,
      this.registry,
      this.killSwitch,
      this.db,
      this.goalManager,
      this.tools,
      this.evaluator,
      this.replanner,
      { strategyContext },
    );
    ```

    **Modify `apps/agent/src/index.ts`:**

    Import StrategyManager:
    ```typescript
    import { StrategyManager } from './strategy/strategy-manager.js';
    ```

    After the GoalManager creation (`const goalManager = new GoalManager(db, router);`), create the StrategyManager:
    ```typescript
    const strategyManager = new StrategyManager(db, goalManager);
    ```

    Pass `strategyManager` to the Supervisor constructor (add as additional arg before the config param — align with the updated constructor signature):
    ```typescript
    const supervisor = new Supervisor(
      db, router, registry, killSwitch, goalManager,
      evaluator, replanner, openAITools, strategyManager,
    );
    ```

    Add a stderr log line after creation:
    ```typescript
    process.stderr.write('[agent] StrategyManager wired into Supervisor.\n');
    ```

    **Create `apps/dashboard/src/routes/api.ts`:**

    First, check if this file exists by reading it. If it doesn't exist, create it as a new Hono route file following the existing pattern in `apps/dashboard/src/routes/` (e.g., `identities.ts`).

    Add a `POST /goals` route for operator goal seeding that accepts `{ description: string, isStrategy?: boolean }`:
    - Creates a goal via direct DB insert using `goals` table
    - If `isStrategy` is true, also creates a strategy row with `status: 'hypothesis'` and `hypothesis: description`
    - Returns `{ goalId, strategyId? }` as JSON

    Since the dashboard API may not have direct access to GoalManager (it's in apps/agent), use direct DB operations:
    ```typescript
    import { db, goals, strategies } from '@jarvis/db';
    ```

    The route:
    ```typescript
    app.post('/goals', async (c) => {
      const { description, isStrategy } = await c.req.json<{ description: string; isStrategy?: boolean }>();

      if (!description || typeof description !== 'string') {
        return c.json({ error: 'description is required' }, 400);
      }

      const [goal] = await db.insert(goals).values({
        description,
        source: 'operator-injected',
        priority: 50,
      }).returning();

      let strategyId: number | undefined;
      if (isStrategy && goal) {
        const [strategy] = await db.insert(strategies).values({
          goalId: goal.id,
          hypothesis: description,
          status: 'hypothesis',
        }).returning();
        strategyId = strategy?.id;
      }

      return c.json({ goalId: goal?.id, strategyId });
    });
    ```

    Also add a `GET /strategies` route that returns the strategy list (plain data, no P&L enrichment):
    ```typescript
    app.get('/strategies', async (c) => {
      const rows = await db.select().from(strategies).orderBy(asc(strategies.createdAt));
      return c.json(rows);
    });
    ```

    Import `asc` from `@jarvis/db`.

    **Modify `apps/dashboard/src/app.ts`:**

    Import and mount the new API route file. Follow the existing pattern used for other route files (e.g., `statusRoute`, `pnlRoute`):

    At the top of the file, add:
    ```typescript
    import apiRoute from './routes/api.js';
    ```

    After the existing route mounts (after the `app.route('/api', identitiesRoute);` line), add:
    ```typescript
    // Phase 7: Strategy engine — goal seeding + strategy listing
    app.route('/api', apiRoute);
    ```

    This makes `POST /api/goals` and `GET /api/strategies` reachable. The route file defines sub-paths (`/goals`, `/strategies`) and the `/api` prefix is applied by `app.route()`.

    **Run `pnpm --filter @jarvis/agent build && pnpm --filter @jarvis/dashboard build`** to verify everything compiles.
  </action>
  <verify>
    `pnpm --filter @jarvis/agent build` succeeds with no TypeScript errors.
    `pnpm --filter @jarvis/dashboard build` succeeds with no TypeScript errors.
    Supervisor constructor accepts optional StrategyManager parameter.
    Supervisor.spawnMainAgent builds strategy context and passes it to AgentLoop when a strategy exists for the goal.
    StrategyManager is instantiated in apps/agent/src/index.ts and passed to Supervisor.
    `POST /api/goals` creates a goal (and optionally a strategy) and returns IDs.
    `GET /api/strategies` returns plain strategy rows.
  </verify>
  <done>
    Supervisor passes domain-agnostic portfolio context to every AgentLoop it spawns for strategy-backed goals. StrategyManager is wired at agent startup. Dashboard API has POST /api/goals for operator goal seeding (with optional strategy creation) and GET /api/strategies for plain strategy listing. The agent receives portfolio context in every sub-goal prompt — status and hypothesis only, no financial data. The agent uses its own tools and LLM reasoning for all evaluation, financial analysis, and decision-making.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @jarvis/db build && pnpm --filter @jarvis/agent build && pnpm --filter @jarvis/dashboard build` — all compile clean
2. `AgentLoop.executeSubGoal()` system prompt includes portfolio context when available
3. Portfolio context contains ONLY strategy status and hypothesis — NO financial data
4. Supervisor resolves strategy context per-goal before spawning AgentLoop
5. StrategyManager wired in agent startup (apps/agent/src/index.ts)
6. `POST /api/goals` creates goal + optional strategy
7. `GET /api/strategies` returns plain strategy rows
8. `evaluator.ts` is NOT modified
9. No hard-coded kill triggers or domain-specific logic exist anywhere
10. Non-strategy goals continue to work exactly as before (backwards compatible)
</verification>

<success_criteria>
- Agent receives domain-agnostic strategy portfolio context in every sub-goal prompt
- Portfolio context lists status and hypothesis only — zero domain-specific data
- Evaluator is untouched
- Supervisor resolves and passes portfolio context to each AgentLoop
- StrategyManager wired at startup
- Operator can seed goals via dashboard API
- All changes backwards-compatible with existing non-strategy goals
- No domain-specific logic anywhere in Phase 7 code
</success_criteria>

<output>
After completion, create `.planning/phases/07-strategy-engine/07-02-SUMMARY.md`
</output>
