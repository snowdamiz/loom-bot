---
phase: 07-strategy-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/strategies.ts
  - packages/db/src/schema/operating-costs.ts
  - packages/db/src/schema/revenue.ts
  - packages/db/src/schema/pnl-view.ts
  - packages/db/src/schema/index.ts
  - packages/db/drizzle.config.ts
  - apps/agent/src/strategy/strategy-manager.ts
autonomous: true
requirements:
  - STRAT-03
  - STRAT-06
  - STRAT-07

must_haves:
  truths:
    - "A strategy row can be created with a 1:1 reference to a goal row"
    - "Operating costs can be attributed to a specific strategy via strategyId FK"
    - "Revenue can be attributed to a specific strategy via integer strategyId FK"
    - "getPnl() returns P&L filtered by strategyId when the parameter is provided"
    - "StrategyManager can create a strategy+goal pair, transition lifecycle states, and list active strategies"
    - "strategies table has NO domain-specific columns — all domain data lives in metadata jsonb"
  artifacts:
    - path: "packages/db/src/schema/strategies.ts"
      provides: "strategies table with lifecycle state, hypothesis, goalId FK, metadata jsonb"
      contains: "pgTable('strategies'"
    - path: "packages/db/src/schema/operating-costs.ts"
      provides: "strategyId FK column on operating_costs"
      contains: "strategyId"
    - path: "packages/db/src/schema/revenue.ts"
      provides: "integer strategyId FK replacing text strategyId"
      contains: "strategies"
    - path: "packages/db/src/schema/pnl-view.ts"
      provides: "getPnl with strategyId filter parameter"
      contains: "strategyId"
    - path: "apps/agent/src/strategy/strategy-manager.ts"
      provides: "StrategyManager class with domain-agnostic CRUD and lifecycle transitions"
      exports: ["StrategyManager"]
  key_links:
    - from: "packages/db/src/schema/strategies.ts"
      to: "packages/db/src/schema/goals.ts"
      via: "goalId FK reference"
      pattern: "references.*goals\\.id"
    - from: "packages/db/src/schema/operating-costs.ts"
      to: "packages/db/src/schema/strategies.ts"
      via: "strategyId FK reference"
      pattern: "references.*strategies\\.id"
    - from: "packages/db/src/schema/revenue.ts"
      to: "packages/db/src/schema/strategies.ts"
      via: "strategyId FK reference"
      pattern: "references.*strategies\\.id"
---

<objective>
Create the strategy data model and StrategyManager that make strategies first-class tracked entities.

Purpose: Strategies need a persistence layer before the agent loop can discover, track, and evaluate them. The `strategies` table tracks lifecycle state and hypothesis text. Attribution FKs on `operating_costs` and `revenue` enable per-strategy cost/revenue querying via the existing `getPnl()` function — but the strategy engine itself does NOT consume P&L data. The agent queries P&L via its `db` tool when it decides to, using its own LLM reasoning.

The strategy engine is domain-agnostic. It tracks what the agent is pursuing and in what state. All domain-specific data (capital, platform, approach, etc.) lives in the `metadata` jsonb column — the schema has no money-specific or domain-specific columns.

Output: `strategies` table in Postgres, attribution FKs on cost/revenue tables (passive data layer for STRAT-07), extended P&L queries, and a domain-agnostic `StrategyManager` class.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-strategy-engine/07-RESEARCH.md

@packages/db/src/schema/goals.ts
@packages/db/src/schema/operating-costs.ts
@packages/db/src/schema/revenue.ts
@packages/db/src/schema/pnl-view.ts
@packages/db/src/schema/decision-log.ts
@packages/db/src/schema/index.ts
@packages/db/drizzle.config.ts
@packages/db/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create strategies table and wire attribution FKs on operating_costs and revenue</name>
  <files>
    packages/db/src/schema/strategies.ts
    packages/db/src/schema/operating-costs.ts
    packages/db/src/schema/revenue.ts
    packages/db/src/schema/pnl-view.ts
    packages/db/src/schema/index.ts
    packages/db/drizzle.config.ts
  </files>
  <action>
    **Create `packages/db/src/schema/strategies.ts`:**

    Define the `strategies` table using the same patterns as `goals.ts`:
    - `id`: integer primary key, generatedAlwaysAsIdentity
    - `goalId`: integer FK to `goals.id`, NOT NULL (1:1 mapping — a strategy IS a goal with metadata)
    - `hypothesis`: text NOT NULL — LLM-generated description of what this strategy is and why it will work
    - `status`: varchar(32) NOT NULL default 'hypothesis' — lifecycle state. Valid states: 'hypothesis', 'testing', 'active', 'paused', 'killed', 'completed'
    - `lastTransitionReason`: text nullable — LLM-supplied reasoning for the most recent lifecycle transition
    - `metadata`: jsonb nullable — free-form strategy-specific context. The agent stores whatever domain data it needs here (capital allocated, platform, approach, metrics, etc.). NO domain-specific columns on the table itself.
    - `createdAt`: timestamp defaultNow NOT NULL
    - `updatedAt`: timestamp defaultNow NOT NULL

    Export `Strategy` and `NewStrategy` inferred types.

    IMPORTANT: NO `capitalAllocatedUsd` column, NO P&L columns, NO money-specific columns. The strategy engine is domain-agnostic. If the agent is pursuing a money-making goal, it stores capital data in `metadata`. If it's pursuing a monitoring goal, it stores monitoring config in `metadata`. The schema doesn't know or care.

    Co-locate the strategies table definition in its own file. The FK to `goals.id` is a forward reference (not self-referential), so plain `.references(() => goals.id)` works — no need for `AnyPgColumn`. Import `goals` from `./goals.js`.

    **Modify `packages/db/src/schema/operating-costs.ts`:**

    Add a nullable `strategyId` column:
    ```typescript
    strategyId: integer('strategy_id').references(() => strategies.id),
    ```
    Import `strategies` from `./strategies.js`. This is a cross-file FK import. Since `operating-costs.ts` is already listed individually in `drizzle.config.ts`, drizzle-kit's CJS bundler can resolve it as long as `strategies.ts` is also listed. Keep the import at the top level.

    NOTE: This FK exists as a passive data layer for STRAT-07 (per-strategy cost attribution). The strategy engine does NOT query or consume this data. The agent can query it via its `db` tool when its LLM reasoning decides it needs cost information.

    **Modify `packages/db/src/schema/revenue.ts`:**

    Change the existing `strategyId: text('strategy_id').notNull()` to an integer FK referencing `strategies.id`. Make it NULLABLE (existing rows and revenue not tied to a strategy get NULL):
    ```typescript
    strategyId: integer('strategy_id').references(() => strategies.id),
    ```
    Remove the `.notNull()` constraint. Import `strategies` from `./strategies.js`. Note: this is a breaking schema change from text to integer. Since the project uses `db:push` (not migrations), existing `revenue` rows with text `strategyId` will need the column dropped and re-created. Drizzle-kit handles this automatically with `db:push --force` but will warn. The existing data (if any) has no real strategy references (Phase 2 stubbed this as text), so data loss is acceptable.

    Also import `integer` if not already imported (it is already imported in the current file).

    **Modify `packages/db/src/schema/pnl-view.ts`:**

    Extend `getPnl()` to accept an optional `strategyId?: number` parameter:
    - Add `strategyId` to the options object type: `options?: { since?: Date; until?: Date; strategyId?: number }`
    - When `strategyId` is provided, add `eq(operatingCosts.strategyId, strategyId)` to `costConditions`
    - When `strategyId` is provided, add `eq(revenue.strategyId, strategyId)` to `revenueConditions`
    - Import `eq` from `drizzle-orm` if not already imported (it's available via the existing `and, gte, lte, sql` import — add `eq` to the destructure)

    Also extend `getRevenueTotal()` to accept `strategyId?: number` (integer) instead of `strategyId?: string` (text). Update the condition to use `eq(revenue.strategyId, strategyId)` instead of the sql template.

    NOTE: These getPnl extensions exist so the agent's `db` tool can query per-strategy P&L when the LLM decides to. The StrategyManager does NOT call getPnl. The agent reasons about finances using its own tools, not hard-coded logic.

    **Update `packages/db/src/schema/index.ts`:**

    Add `export * from './strategies.js';` — place it after the `goals.js` export.

    **Update `packages/db/drizzle.config.ts`:**

    Add `'./src/schema/strategies.ts'` to the schema array. Place it after `'./src/schema/goals.ts'` for readability.

    **Run `pnpm --filter @jarvis/db build`** to verify TypeScript compilation.
    Then run `pnpm --filter @jarvis/db db:push` (with DATABASE_URL set) to verify schema pushes cleanly. If the revenue column type change causes issues, note it — the executor should use `db:push` which handles column type changes.
  </action>
  <verify>
    `pnpm --filter @jarvis/db build` succeeds with no TypeScript errors.
    `strategies` table and type exports are accessible: `import { strategies, Strategy, NewStrategy } from '@jarvis/db'` resolves.
    `strategies` table has NO `capitalAllocatedUsd` column or any other domain-specific column.
    `operating_costs.strategy_id` and `revenue.strategy_id` columns exist as integer FKs.
    `getPnl(db, { strategyId: 1 })` compiles without errors.
  </verify>
  <done>
    strategies table exists with goalId FK to goals, lifecycle status, hypothesis, metadata jsonb columns. No domain-specific columns. operating_costs and revenue both have integer strategyId FK columns referencing strategies.id (passive data layer). getPnl() accepts optional strategyId filter for agent db tool queries. All types exported from @jarvis/db. Schema pushes to Postgres without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create StrategyManager with domain-agnostic CRUD and lifecycle transitions</name>
  <files>
    apps/agent/src/strategy/strategy-manager.ts
  </files>
  <action>
    **Create `apps/agent/src/strategy/strategy-manager.ts`:**

    Follow the `GoalManager` class pattern from `apps/agent/src/loop/goal-manager.ts`.

    ```typescript
    import { strategies, eq, asc, sql } from '@jarvis/db';
    import type { DbClient, Strategy, NewStrategy, Goal } from '@jarvis/db';
    import type { GoalManager } from '../loop/goal-manager.js';
    ```

    NOTE: No `getPnl` import. The StrategyManager does NOT query P&L. The agent queries P&L via its `db` tool when its LLM reasoning decides to.

    Note: `not` operator is not currently re-exported from `@jarvis/db`. For filtering out killed strategies, use `sql` template: `` sql`${strategies.status} != 'killed'` ``. Import `sql` from `@jarvis/db`.

    **StrategyManager class:**

    Constructor takes `(db: DbClient, goalManager: GoalManager)`.

    Methods:

    1. `async createStrategy(hypothesis: string, metadata?: Record<string, unknown>): Promise<{ strategy: Strategy; goal: Goal }>`
       - Create a goal via `goalManager.createGoal(`Strategy: ${hypothesis}`, 'agent-discovered', 50)`
       - Insert a `strategies` row with `goalId`, `hypothesis`, `status: 'hypothesis'`, `metadata`
       - Return both the strategy and goal

    2. `async transitionStatus(strategyId: number, newStatus: string, reason: string): Promise<void>`
       - Update `strategies` set `status`, `lastTransitionReason`, `updatedAt` where `id = strategyId`
       - This is a direct update on the `strategies` table (NOT append-only — strategies table is a living registry per research pitfall #3)

    3. `async updateMetadata(strategyId: number, metadata: Record<string, unknown>): Promise<void>`
       - Merge new metadata keys into existing metadata jsonb
       - The agent uses this to store domain-specific data (capital, platform, metrics, etc.)

    4. `async getStrategies(includeKilled = false): Promise<Strategy[]>`
       - Select all strategies, optionally filtering out `status = 'killed'`
       - Order by `createdAt` ascending
       - Returns plain Strategy rows — NO P&L enrichment

    5. `async getStrategyByGoalId(goalId: number): Promise<Strategy | null>`
       - Select from strategies where `goalId = goalId`, limit 1
       - Return the strategy or null (not all goals have strategies)

    6. `async getActiveStrategies(): Promise<Strategy[]>`
       - Select from strategies where status NOT IN ('killed', 'completed')
       - Order by createdAt asc

    **Do NOT:**
    - Import or call `getPnl` — the StrategyManager has no P&L awareness
    - Add any `StrategyWithPnl` interface — no financial data enrichment
    - Add any `capitalAllocatedUsd` parameter or field — capital is domain data stored in metadata by the agent
    - Add any hard-coded P&L thresholds or auto-kill logic
    - Build a separate executor — `AgentLoop` already IS the executor

    **Run `pnpm --filter @jarvis/agent build`** to verify TypeScript compilation.
  </action>
  <verify>
    `pnpm --filter @jarvis/agent build` succeeds with no TypeScript errors.
    `StrategyManager` class exports from `apps/agent/src/strategy/strategy-manager.ts`.
    All 6 methods are implemented with correct signatures.
    No `getPnl` import exists in the file.
    No `StrategyWithPnl` type exists.
    No hard-coded thresholds, auto-kill triggers, or P&L logic exist in the code.
  </verify>
  <done>
    StrategyManager class exists with createStrategy (creates goal + strategy pair), transitionStatus, updateMetadata, getStrategies, getStrategyByGoalId, and getActiveStrategies. Fully domain-agnostic — no P&L awareness, no financial logic, no domain-specific fields. All lifecycle decisions are left to the LLM.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @jarvis/db build` — TypeScript compiles clean
2. `pnpm --filter @jarvis/agent build` — TypeScript compiles clean (StrategyManager imports resolve)
3. `strategies` table schema has: id, goalId (FK), hypothesis, status, lastTransitionReason, metadata, createdAt, updatedAt — NO capitalAllocatedUsd, NO domain-specific columns
4. `operating_costs` has nullable `strategy_id` integer FK column (passive data layer)
5. `revenue` has nullable `strategy_id` integer FK column (passive data layer)
6. `getPnl(db, { strategyId: 1 })` returns filtered P&L for that strategy (available to agent's db tool)
7. `StrategyManager` has NO getPnl imports, NO P&L enrichment, NO financial logic
</verification>

<success_criteria>
- strategies table created with domain-agnostic schema and FK to goals
- Attribution FKs wired on operating_costs and revenue (passive data layer for STRAT-07)
- getPnl() extended with strategyId filter (for agent db tool access, not strategy engine consumption)
- StrategyManager provides domain-agnostic CRUD, lifecycle transitions, and metadata updates
- No P&L logic, no financial logic, no domain-specific logic in strategy engine code
- All TypeScript compiles without errors across both packages
</success_criteria>

<output>
After completion, create `.planning/phases/07-strategy-engine/07-01-SUMMARY.md`
</output>
