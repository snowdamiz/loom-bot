---
phase: 07-strategy-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/strategies.ts
  - packages/db/src/schema/operating-costs.ts
  - packages/db/src/schema/revenue.ts
  - packages/db/src/schema/pnl-view.ts
  - packages/db/src/schema/index.ts
  - packages/db/drizzle.config.ts
  - apps/agent/src/strategy/strategy-manager.ts
autonomous: true
requirements:
  - STRAT-03
  - STRAT-06
  - STRAT-07

must_haves:
  truths:
    - "A strategy row can be created with a 1:1 reference to a goal row"
    - "Operating costs can be attributed to a specific strategy via strategyId FK"
    - "Revenue can be attributed to a specific strategy via integer strategyId FK"
    - "getPnl() returns P&L filtered by strategyId when the parameter is provided"
    - "StrategyManager can create a strategy+goal pair, transition lifecycle states, and build portfolio context with P&L"
  artifacts:
    - path: "packages/db/src/schema/strategies.ts"
      provides: "strategies table with lifecycle state, capital, hypothesis, goalId FK"
      contains: "pgTable('strategies'"
    - path: "packages/db/src/schema/operating-costs.ts"
      provides: "strategyId FK column on operating_costs"
      contains: "strategyId"
    - path: "packages/db/src/schema/revenue.ts"
      provides: "integer strategyId FK replacing text strategyId"
      contains: "strategies"
    - path: "packages/db/src/schema/pnl-view.ts"
      provides: "getPnl with strategyId filter parameter"
      contains: "strategyId"
    - path: "apps/agent/src/strategy/strategy-manager.ts"
      provides: "StrategyManager class with CRUD, lifecycle transitions, portfolio context"
      exports: ["StrategyManager"]
  key_links:
    - from: "packages/db/src/schema/strategies.ts"
      to: "packages/db/src/schema/goals.ts"
      via: "goalId FK reference"
      pattern: "references.*goals\\.id"
    - from: "packages/db/src/schema/operating-costs.ts"
      to: "packages/db/src/schema/strategies.ts"
      via: "strategyId FK reference"
      pattern: "references.*strategies\\.id"
    - from: "packages/db/src/schema/revenue.ts"
      to: "packages/db/src/schema/strategies.ts"
      via: "strategyId FK reference"
      pattern: "references.*strategies\\.id"
    - from: "apps/agent/src/strategy/strategy-manager.ts"
      to: "packages/db/src/schema/pnl-view.ts"
      via: "getPnl with strategyId for portfolio context"
      pattern: "getPnl.*strategyId"
---

<objective>
Create the strategy data model and StrategyManager that make strategies first-class tracked entities with per-strategy P&L attribution.

Purpose: Strategies need a persistence layer before the agent loop can discover, track, and evaluate them. The `strategies` table, attribution FKs on `operating_costs` and `revenue`, and the extended `getPnl()` function form the foundation that Plan 02 wires into the agent loop.

Output: `strategies` table in Postgres, attribution FKs on cost/revenue tables, extended P&L queries, and a `StrategyManager` class that handles strategy CRUD, lifecycle transitions, and portfolio context building.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-strategy-engine/07-RESEARCH.md

@packages/db/src/schema/goals.ts
@packages/db/src/schema/operating-costs.ts
@packages/db/src/schema/revenue.ts
@packages/db/src/schema/pnl-view.ts
@packages/db/src/schema/decision-log.ts
@packages/db/src/schema/index.ts
@packages/db/drizzle.config.ts
@packages/db/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create strategies table and wire attribution FKs on operating_costs and revenue</name>
  <files>
    packages/db/src/schema/strategies.ts
    packages/db/src/schema/operating-costs.ts
    packages/db/src/schema/revenue.ts
    packages/db/src/schema/pnl-view.ts
    packages/db/src/schema/index.ts
    packages/db/drizzle.config.ts
  </files>
  <action>
    **Create `packages/db/src/schema/strategies.ts`:**

    Define the `strategies` table using the same patterns as `goals.ts`:
    - `id`: integer primary key, generatedAlwaysAsIdentity
    - `goalId`: integer FK to `goals.id`, NOT NULL (1:1 mapping — a strategy IS a goal with metadata)
    - `hypothesis`: text NOT NULL — LLM-generated description of what this strategy is and why it will work
    - `status`: varchar(32) NOT NULL default 'hypothesis' — lifecycle state. Valid states: 'hypothesis', 'testing', 'scaling', 'paused', 'killed', 'completed'
    - `capitalAllocatedUsd`: numeric(12, 4) NOT NULL default '0' — informational (for LLM context), NOT enforced. Per user decision: no strategy-level spend limits
    - `lastTransitionReason`: text nullable — LLM-supplied reasoning for the most recent lifecycle transition
    - `metadata`: jsonb nullable — free-form strategy-specific context (platform, approach, etc.)
    - `createdAt`: timestamp defaultNow NOT NULL
    - `updatedAt`: timestamp defaultNow NOT NULL

    Export `Strategy` and `NewStrategy` inferred types.

    IMPORTANT: Co-locate the strategies table definition in its own file. The FK to `goals.id` is a forward reference (not self-referential), so plain `.references(() => goals.id)` works — no need for `AnyPgColumn`. Import `goals` from `./goals.js`.

    **Modify `packages/db/src/schema/operating-costs.ts`:**

    Add a nullable `strategyId` column:
    ```typescript
    strategyId: integer('strategy_id').references(() => strategies.id),
    ```
    Import `strategies` from `./strategies.js`. This is a cross-file FK import. Since `operating-costs.ts` is already listed individually in `drizzle.config.ts`, drizzle-kit's CJS bundler can resolve it as long as `strategies.ts` is also listed. Keep the import at the top level.

    **Modify `packages/db/src/schema/revenue.ts`:**

    Change the existing `strategyId: text('strategy_id').notNull()` to an integer FK referencing `strategies.id`. Make it NULLABLE (existing rows and revenue not tied to a strategy get NULL):
    ```typescript
    strategyId: integer('strategy_id').references(() => strategies.id),
    ```
    Remove the `.notNull()` constraint. Import `strategies` from `./strategies.js`. Note: this is a breaking schema change from text to integer. Since the project uses `db:push` (not migrations), existing `revenue` rows with text `strategyId` will need the column dropped and re-created. Drizzle-kit handles this automatically with `db:push --force` but will warn. The existing data (if any) has no real strategy references (Phase 2 stubbed this as text), so data loss is acceptable.

    Also import `integer` if not already imported (it is already imported in the current file).

    **Modify `packages/db/src/schema/pnl-view.ts`:**

    Extend `getPnl()` to accept an optional `strategyId?: number` parameter:
    - Add `strategyId` to the options object type: `options?: { since?: Date; until?: Date; strategyId?: number }`
    - When `strategyId` is provided, add `eq(operatingCosts.strategyId, strategyId)` to `costConditions`
    - When `strategyId` is provided, add `eq(revenue.strategyId, strategyId)` to `revenueConditions`
    - Import `eq` from `drizzle-orm` if not already imported (it's available via the existing `and, gte, lte, sql` import — add `eq` to the destructure)

    Also extend `getRevenueTotal()` to accept `strategyId?: number` (integer) instead of `strategyId?: string` (text). Update the condition to use `eq(revenue.strategyId, strategyId)` instead of the sql template.

    **Update `packages/db/src/schema/index.ts`:**

    Add `export * from './strategies.js';` — place it after the `goals.js` export.

    **Update `packages/db/drizzle.config.ts`:**

    Add `'./src/schema/strategies.ts'` to the schema array. Place it after `'./src/schema/goals.ts'` for readability.

    **Run `pnpm --filter @jarvis/db build`** to verify TypeScript compilation.
    Then run `pnpm --filter @jarvis/db db:push` (with DATABASE_URL set) to verify schema pushes cleanly. If the revenue column type change causes issues, note it — the executor should use `db:push` which handles column type changes.
  </action>
  <verify>
    `pnpm --filter @jarvis/db build` succeeds with no TypeScript errors.
    `strategies` table and type exports are accessible: `import { strategies, Strategy, NewStrategy } from '@jarvis/db'` resolves.
    `operating_costs.strategy_id` and `revenue.strategy_id` columns exist as integer FKs.
    `getPnl(db, { strategyId: 1 })` compiles without errors.
  </verify>
  <done>
    strategies table exists with goalId FK to goals, lifecycle status, capital, hypothesis, metadata columns. operating_costs and revenue both have integer strategyId FK columns referencing strategies.id. getPnl() accepts optional strategyId filter. All types exported from @jarvis/db. Schema pushes to Postgres without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create StrategyManager with CRUD, lifecycle transitions, and portfolio context</name>
  <files>
    apps/agent/src/strategy/strategy-manager.ts
  </files>
  <action>
    **Create `apps/agent/src/strategy/strategy-manager.ts`:**

    Follow the `GoalManager` class pattern from `apps/agent/src/loop/goal-manager.ts`.

    ```typescript
    import { strategies, goals, eq, and, asc, isNull } from '@jarvis/db';
    import type { DbClient, Strategy, NewStrategy, Goal } from '@jarvis/db';
    import { getPnl } from '@jarvis/db';
    import type { GoalManager } from '../loop/goal-manager.js';
    ```

    Note: `not` operator is not currently re-exported from `@jarvis/db`. For filtering out killed strategies, use `sql` template: `` sql`${strategies.status} != 'killed'` ``. Import `sql` from `@jarvis/db`.

    **StrategyWithPnl interface:**
    ```typescript
    export interface StrategyWithPnl extends Strategy {
      netPnlUsd: number;
      totalCostsUsd: number;
      totalRevenueUsd: number;
    }
    ```

    **StrategyManager class:**

    Constructor takes `(db: DbClient, goalManager: GoalManager)`.

    Methods:

    1. `async createStrategy(hypothesis: string, capitalAllocatedUsd = 0, metadata?: Record<string, unknown>): Promise<{ strategy: Strategy; goal: Goal }>`
       - Create a goal via `goalManager.createGoal(`Strategy: ${hypothesis}`, 'agent-discovered', 50)`
       - Insert a `strategies` row with `goalId`, `hypothesis`, `status: 'hypothesis'`, `capitalAllocatedUsd: capitalAllocatedUsd.toString()`, `metadata`
       - Return both the strategy and goal

    2. `async transitionStatus(strategyId: number, newStatus: string, reason: string): Promise<void>`
       - Update `strategies` set `status`, `lastTransitionReason`, `updatedAt` where `id = strategyId`
       - This is a direct update on the `strategies` table (NOT append-only — strategies table is a living registry per research pitfall #3)

    3. `async updateCapitalAllocation(strategyId: number, capitalUsd: number): Promise<void>`
       - Update `capitalAllocatedUsd` on the strategy row
       - This is informational only — no enforcement (per locked decision: no strategy-level spend limits)

    4. `async getPortfolioContext(includeKilled = false): Promise<StrategyWithPnl[]>`
       - Select all strategies, optionally filtering out `status = 'killed'`
       - For each strategy, call `getPnl(db, { strategyId: s.id })` to get P&L
       - Return array of `StrategyWithPnl` objects
       - Order by `createdAt` ascending

    5. `async getStrategyByGoalId(goalId: number): Promise<Strategy | null>`
       - Select from strategies where `goalId = goalId`, limit 1
       - Return the strategy or null (not all goals have strategies)

    6. `async getActiveStrategies(): Promise<Strategy[]>`
       - Select from strategies where status NOT IN ('killed', 'completed')
       - Order by createdAt asc

    **Do NOT:**
    - Add any hard-coded P&L thresholds or auto-kill logic (per locked decision: LLM evaluates and decides)
    - Add per-strategy spend limits or capital enforcement (per locked decision: Phase 4 limits only)
    - Build a separate executor — `AgentLoop` already IS the executor

    **Run `pnpm --filter @jarvis/agent build`** to verify TypeScript compilation.
  </action>
  <verify>
    `pnpm --filter @jarvis/agent build` succeeds with no TypeScript errors.
    `StrategyManager` class exports from `apps/agent/src/strategy/strategy-manager.ts`.
    All 6 methods are implemented with correct signatures.
    No hard-coded thresholds or auto-kill triggers exist in the code.
  </verify>
  <done>
    StrategyManager class exists with createStrategy (creates goal + strategy pair), transitionStatus, updateCapitalAllocation, getPortfolioContext (with P&L from getPnl), getStrategyByGoalId, and getActiveStrategies. No hard-coded evaluation logic — all lifecycle decisions are left to the LLM.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @jarvis/db build` — TypeScript compiles clean
2. `pnpm --filter @jarvis/agent build` — TypeScript compiles clean (StrategyManager imports resolve)
3. `strategies` table schema has: id, goalId (FK), hypothesis, status, capitalAllocatedUsd, lastTransitionReason, metadata, createdAt, updatedAt
4. `operating_costs` has nullable `strategy_id` integer FK column
5. `revenue` has nullable `strategy_id` integer FK column (changed from text)
6. `getPnl(db, { strategyId: 1 })` returns filtered P&L for that strategy
7. `StrategyManager.getPortfolioContext()` returns strategies with P&L data attached
</verification>

<success_criteria>
- strategies table created with correct schema and FK to goals
- Attribution FKs wired on operating_costs and revenue
- getPnl() extended with strategyId filter
- StrategyManager provides full CRUD, lifecycle transitions, and portfolio context building
- All TypeScript compiles without errors across both packages
</success_criteria>

<output>
After completion, create `.planning/phases/07-strategy-engine/07-01-SUMMARY.md`
</output>
