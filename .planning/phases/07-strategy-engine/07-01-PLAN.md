---
phase: 07-strategy-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/strategies.ts
  - packages/db/src/schema/index.ts
  - packages/db/drizzle.config.ts
  - apps/agent/src/strategy/strategy-manager.ts
autonomous: true
requirements:
  - STRAT-03
  - STRAT-06

must_haves:
  truths:
    - "A strategy row can be created with a 1:1 reference to a goal row"
    - "StrategyManager can create a strategy+goal pair, transition lifecycle states, and list active strategies"
    - "strategies table has NO domain-specific columns — all domain data lives in metadata jsonb"
  artifacts:
    - path: "packages/db/src/schema/strategies.ts"
      provides: "strategies table with lifecycle state, hypothesis, goalId FK, metadata jsonb"
      contains: "pgTable('strategies'"
    - path: "apps/agent/src/strategy/strategy-manager.ts"
      provides: "StrategyManager class with domain-agnostic CRUD and lifecycle transitions"
      exports: ["StrategyManager"]
  key_links:
    - from: "packages/db/src/schema/strategies.ts"
      to: "packages/db/src/schema/goals.ts"
      via: "goalId FK reference"
      pattern: "references.*goals\\.id"
---

<objective>
Create the strategy data model and StrategyManager that make strategies first-class tracked entities.

Purpose: Strategies need a persistence layer before the agent loop can discover, track, and evaluate them. The `strategies` table tracks lifecycle state and hypothesis text. All domain-specific data (capital, platform, approach, metrics, etc.) lives in the `metadata` jsonb column — the schema has no domain-specific columns.

The strategy engine is domain-agnostic. It tracks what the agent is pursuing and in what state. If the agent needs financial tracking, schema extensions, or any other domain-specific capability, it builds those itself via self-extension (Phase 8).

Output: `strategies` table in Postgres and a domain-agnostic `StrategyManager` class.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-strategy-engine/07-RESEARCH.md

@packages/db/src/schema/goals.ts
@packages/db/src/schema/index.ts
@packages/db/drizzle.config.ts
@packages/db/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create strategies table, export from index, register in drizzle config</name>
  <files>
    packages/db/src/schema/strategies.ts
    packages/db/src/schema/index.ts
    packages/db/drizzle.config.ts
  </files>
  <action>
    **Create `packages/db/src/schema/strategies.ts`:**

    Define the `strategies` table using the same patterns as `goals.ts`:
    - `id`: integer primary key, generatedAlwaysAsIdentity
    - `goalId`: integer FK to `goals.id`, NOT NULL (1:1 mapping — a strategy IS a goal with metadata)
    - `hypothesis`: text NOT NULL — LLM-generated description of what this strategy is and why it will work
    - `status`: varchar(32) NOT NULL default 'hypothesis' — lifecycle state. Valid states: 'hypothesis', 'testing', 'active', 'paused', 'killed', 'completed'
    - `lastTransitionReason`: text nullable — LLM-supplied reasoning for the most recent lifecycle transition
    - `metadata`: jsonb nullable — free-form strategy-specific context. The agent stores whatever domain data it needs here (capital allocated, platform, approach, metrics, etc.). NO domain-specific columns on the table itself.
    - `createdAt`: timestamp defaultNow NOT NULL
    - `updatedAt`: timestamp defaultNow NOT NULL

    Export `Strategy` and `NewStrategy` inferred types.

    IMPORTANT: The strategy engine is domain-agnostic. No financial columns, no domain-specific columns. If the agent is pursuing a money-making goal, it stores capital data in `metadata`. If it's pursuing a monitoring goal, it stores monitoring config in `metadata`. The schema doesn't know or care.

    Co-locate the strategies table definition in its own file. The FK to `goals.id` is a forward reference (not self-referential), so plain `.references(() => goals.id)` works — no need for `AnyPgColumn`. Import `goals` from `./goals.js`.

    **Do NOT modify `operating-costs.ts`, `revenue.ts`, or `pnl-view.ts`.** No attribution FKs, no query extensions. If the agent needs per-strategy financial tracking, it will build those schema extensions itself via self-extension.

    **Update `packages/db/src/schema/index.ts`:**

    Add `export * from './strategies.js';` — place it after the `goals.js` export.

    **Update `packages/db/drizzle.config.ts`:**

    Add `'./src/schema/strategies.ts'` to the schema array. Place it after `'./src/schema/goals.ts'` for readability.

    **Run `pnpm --filter @jarvis/db build`** to verify TypeScript compilation.
    Then run `pnpm --filter @jarvis/db db:push` (with DATABASE_URL set) to verify schema pushes cleanly.
  </action>
  <verify>
    `pnpm --filter @jarvis/db build` succeeds with no TypeScript errors.
    `strategies` table and type exports are accessible: `import { strategies, Strategy, NewStrategy } from '@jarvis/db'` resolves.
    `strategies` table has NO domain-specific columns — only id, goalId, hypothesis, status, lastTransitionReason, metadata, createdAt, updatedAt.
    `operating-costs.ts`, `revenue.ts`, and `pnl-view.ts` are NOT modified.
  </verify>
  <done>
    strategies table exists with goalId FK to goals, lifecycle status, hypothesis, metadata jsonb columns. No domain-specific columns. No other schema files modified. All types exported from @jarvis/db. Schema pushes to Postgres without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create StrategyManager with domain-agnostic CRUD and lifecycle transitions</name>
  <files>
    apps/agent/src/strategy/strategy-manager.ts
  </files>
  <action>
    **Create `apps/agent/src/strategy/strategy-manager.ts`:**

    Follow the `GoalManager` class pattern from `apps/agent/src/loop/goal-manager.ts`.

    ```typescript
    import { strategies, eq, asc, sql } from '@jarvis/db';
    import type { DbClient, Strategy, NewStrategy, Goal } from '@jarvis/db';
    import type { GoalManager } from '../loop/goal-manager.js';
    ```

    Note: `not` operator is not currently re-exported from `@jarvis/db`. For filtering out killed strategies, use `sql` template: `` sql`${strategies.status} != 'killed'` ``. Import `sql` from `@jarvis/db`.

    **StrategyManager class:**

    Constructor takes `(db: DbClient, goalManager: GoalManager)`.

    Methods:

    1. `async createStrategy(hypothesis: string, metadata?: Record<string, unknown>): Promise<{ strategy: Strategy; goal: Goal }>`
       - Create a goal via `goalManager.createGoal(`Strategy: ${hypothesis}`, 'agent-discovered', 50)`
       - Insert a `strategies` row with `goalId`, `hypothesis`, `status: 'hypothesis'`, `metadata`
       - Return both the strategy and goal

    2. `async transitionStatus(strategyId: number, newStatus: string, reason: string): Promise<void>`
       - Update `strategies` set `status`, `lastTransitionReason`, `updatedAt` where `id = strategyId`
       - This is a direct update on the `strategies` table (NOT append-only — strategies table is a living registry per research pitfall #3)

    3. `async updateMetadata(strategyId: number, metadata: Record<string, unknown>): Promise<void>`
       - Merge new metadata keys into existing metadata jsonb
       - The agent uses this to store domain-specific data (capital, platform, metrics, etc.)

    4. `async getStrategies(includeKilled = false): Promise<Strategy[]>`
       - Select all strategies, optionally filtering out `status = 'killed'`
       - Order by `createdAt` ascending

    5. `async getStrategyByGoalId(goalId: number): Promise<Strategy | null>`
       - Select from strategies where `goalId = goalId`, limit 1
       - Return the strategy or null (not all goals have strategies)

    6. `async getActiveStrategies(): Promise<Strategy[]>`
       - Select from strategies where status NOT IN ('killed', 'completed')
       - Order by createdAt asc

    **Do NOT:**
    - Import or reference any financial modules
    - Add any domain-specific interfaces or types
    - Add any hard-coded evaluation logic — all lifecycle decisions are left to the LLM
    - Build a separate executor — `AgentLoop` already IS the executor

    **Run `pnpm --filter @jarvis/agent build`** to verify TypeScript compilation.
  </action>
  <verify>
    `pnpm --filter @jarvis/agent build` succeeds with no TypeScript errors.
    `StrategyManager` class exports from `apps/agent/src/strategy/strategy-manager.ts`.
    All 6 methods are implemented with correct signatures.
    No domain-specific logic exists in the code.
  </verify>
  <done>
    StrategyManager class exists with createStrategy (creates goal + strategy pair), transitionStatus, updateMetadata, getStrategies, getStrategyByGoalId, and getActiveStrategies. Fully domain-agnostic. All lifecycle decisions are left to the LLM.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @jarvis/db build` — TypeScript compiles clean
2. `pnpm --filter @jarvis/agent build` — TypeScript compiles clean (StrategyManager imports resolve)
3. `strategies` table schema has: id, goalId (FK), hypothesis, status, lastTransitionReason, metadata, createdAt, updatedAt — no domain-specific columns
4. `operating-costs.ts`, `revenue.ts`, `pnl-view.ts` are NOT modified
5. `StrategyManager` has no domain-specific logic
</verification>

<success_criteria>
- strategies table created with domain-agnostic schema and FK to goals
- StrategyManager provides domain-agnostic CRUD, lifecycle transitions, and metadata updates
- No financial modules touched or referenced
- All TypeScript compiles without errors across both packages
</success_criteria>

<output>
After completion, create `.planning/phases/07-strategy-engine/07-01-SUMMARY.md`
</output>
