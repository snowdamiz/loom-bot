---
phase: 04-wallet-and-financial-governance
plan: 03
type: execute
wave: 3
depends_on:
  - 04-01
  - 04-02
files_modified:
  - packages/wallet/src/client/send.ts
  - packages/wallet/src/client/subscribe.ts
  - packages/wallet/src/index.ts
  - packages/tools/src/wallet/index.ts
  - packages/tools/src/index.ts
  - apps/agent/src/index.ts
  - apps/agent/src/shutdown.ts
  - apps/agent/package.json
autonomous: true
requirements:
  - WALLET-02
  - WALLET-03
  - WALLET-06

must_haves:
  truths:
    - "Agent can send SOL to a specified address, and the transaction is logged with destination, amount, and purpose"
    - "Agent can send SPL tokens to a specified address, with automatic ATA creation if needed"
    - "Every send goes through governance check before signing — rejected sends are logged with rejection reason"
    - "Confirmed transactions have tx_signature stored in the wallet_transactions table"
    - "Agent is notified of inbound SOL and token transfers via WebSocket subscription"
    - "Wallet tools (get_balance, send_sol, send_token, get_tx_history) are registered in the tool registry"
    - "Signer co-process is started as a child process by the agent and shut down gracefully on SIGTERM"
  artifacts:
    - path: "packages/wallet/src/client/send.ts"
      provides: "SOL and SPL token send functions with governance + signing + logging"
      contains: "sendSol"
    - path: "packages/wallet/src/client/subscribe.ts"
      provides: "WebSocket subscription for inbound token monitoring"
      contains: "subscribeToWallet"
    - path: "packages/tools/src/wallet/index.ts"
      provides: "Agent-facing wallet tool definitions"
      contains: "createWalletTools"
    - path: "apps/agent/src/index.ts"
      provides: "Signer co-process lifecycle and wallet tool registration"
      contains: "signer"
  key_links:
    - from: "packages/wallet/src/client/send.ts"
      to: "packages/wallet/src/governance/limits.ts"
      via: "checkSpendLimits called before signing"
      pattern: "checkSpendLimits.*amountLamports"
    - from: "packages/wallet/src/client/send.ts"
      to: "packages/wallet/src/client/signer-client.ts"
      via: "SignerClient.signTransaction for IPC signing"
      pattern: "signerClient\\.signTransaction"
    - from: "packages/wallet/src/client/send.ts"
      to: "packages/db/src/schema/wallet-transactions.ts"
      via: "inserts transaction record on send and updates on confirm/fail"
      pattern: "walletTransactions.*insert"
    - from: "packages/tools/src/wallet/index.ts"
      to: "packages/wallet/src/client/balance.ts"
      via: "get_balance tool calls getBalances"
      pattern: "getBalances"
    - from: "packages/tools/src/wallet/index.ts"
      to: "packages/wallet/src/client/send.ts"
      via: "send_sol/send_token tools call sendSol/sendSplToken"
      pattern: "sendSol|sendSplToken"
    - from: "apps/agent/src/index.ts"
      to: "packages/wallet/src/signer/server.ts"
      via: "child_process.fork to start signer co-process"
      pattern: "fork.*signer"
---

<objective>
Build the send transaction pipeline (SOL + SPL tokens), inbound token monitoring, agent-facing wallet tools, and wire everything into the agent process lifecycle.

Purpose: This is the culmination of the wallet phase — the agent can now actually move money. Every transaction flows through governance -> signing -> broadcast -> logging. The agent process manages the signer co-process lifecycle and registers wallet tools so the AI can use them in planning decisions.

Output: Complete send pipeline, inbound monitoring, 4 wallet tools in the tool registry, and full agent process integration with signer co-process lifecycle management.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-wallet-and-financial-governance/04-RESEARCH.md
@.planning/phases/04-wallet-and-financial-governance/04-01-SUMMARY.md
@.planning/phases/04-wallet-and-financial-governance/04-02-SUMMARY.md

@packages/wallet/src/index.ts
@packages/wallet/src/client/signer-client.ts
@packages/wallet/src/client/balance.ts
@packages/wallet/src/governance/limits.ts
@packages/wallet/src/governance/notify.ts
@packages/tools/src/index.ts
@packages/tools/src/types.ts
@apps/agent/src/index.ts
@apps/agent/src/shutdown.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: SOL/SPL send pipeline and inbound monitoring</name>
  <files>
    packages/wallet/src/client/send.ts
    packages/wallet/src/client/subscribe.ts
    packages/wallet/src/index.ts
  </files>
  <action>
    **SOL and SPL send functions (send.ts):**

    Imports: SignerClient (from signer-client), checkSpendLimits + notifySpendLimitBreach + notifyHighValueTransaction (from governance), getRequiredWalletConfig (from config), DbClient + walletTransactions + sql (from @jarvis/db), @solana/kit for transaction building, @solana/spl-token for SPL operations, @solana-program/system for SOL transfers.

    Add `@solana-program/system` as a dependency to @jarvis/wallet package.json.

    **`sendSol(db, signerClient, destination, amountLamports, purpose): Promise<SendResult>`**
    - `SendResult`: `{ success: boolean; txSignature?: string; error?: string; transactionId: number }`
    - Flow:
      1. **Governance check:** Call `checkSpendLimits(db, BigInt(amountLamports))`. If not allowed:
         - Log rejected transaction to wallet_transactions with status='rejected', rejection_reason=result.reason
         - Call notifySpendLimitBreach (async, non-blocking — do not await, fire-and-forget with .catch(stderr))
         - Return `{ success: false, error: result.reason, transactionId }`
      2. **Build unsigned transaction:**
         - Read RPC URL and wallet public key from wallet_config via getRequiredWalletConfig
         - Create RPC client: `createSolanaRpc(rpcUrl)`
         - Get latest blockhash: `rpc.getLatestBlockhash().send()`
         - Build transaction using @solana/kit pipe pattern:
           - `createTransactionMessage({ version: 0 })`
           - `setTransactionMessageFeePayer(address(publicKey), msg)`
           - `setTransactionMessageLifetimeUsingBlockhash(blockhash, msg)`
           - `appendTransactionMessageInstruction(getTransferSolInstruction({...}), msg)`
         - Compile to wire format and encode as base64
      3. **Log as 'submitted':** Insert row into wallet_transactions with status='submitted', destination, amount, purpose. Get the inserted row ID.
      4. **Sign via IPC:** `signerClient.signTransaction(unsignedBase64)`
      5. **Broadcast:** `rpc.sendTransaction(signedBase64, { encoding: 'base64' }).send()` — returns tx signature
      6. **Update transaction record:** Update the wallet_transactions row with tx_signature and status='confirmed' (for simplicity in Phase 4, treat successful send as confirmed; full confirmation polling can be added later)
      7. **Notify high-value:** Call notifyHighValueTransaction (async, non-blocking)
      8. Return `{ success: true, txSignature, transactionId }`
    - Wrap entire flow in try/catch. On error after submission: update status to 'failed', return error.

    **`sendSplToken(db, signerClient, destination, mintAddress, amount, purpose): Promise<SendResult>`**
    - Similar flow to sendSol but:
      1. Auto-detect token program (TOKEN_PROGRAM_ID vs TOKEN_2022_PROGRAM_ID) by checking mint account owner
      2. Get/create source and destination ATAs using @solana/spl-token
      3. Build `createTransferCheckedInstruction` with correct program ID and mint decimals
      4. Same governance -> sign -> broadcast -> log pipeline
    - NOTE: ATA creation costs ~0.002 SOL (per research anti-pattern). The governance check should account for the total cost (transfer amount + ATA creation fee). For Phase 4, this is acceptable as a known limitation — document it in code comments.

    **`getTransactionHistory(db, limit?, offset?): Promise<WalletTransaction[]>`**
    - Query wallet_transactions table ordered by created_at DESC with limit (default 50) and offset (default 0)
    - Returns full transaction records for AI decision-making

    **Inbound monitoring (subscribe.ts):**
    - `subscribeToWallet(db, onInbound): Promise<{ stop: () => void }>`
      - Reads wss_url and wallet_public_key from wallet_config
      - Creates WebSocket subscription via @solana/kit `createSolanaRpcSubscriptions(wssUrl)`
      - Subscribes to `accountNotifications` for the wallet address (SOL balance changes)
      - On notification: calls `onInbound({ type: 'sol', lamports: newBalance })` callback
      - Returns an object with a `stop()` method that calls the AbortController.abort() to clean up
      - Implements reconnection: if the subscription closes unexpectedly, wait 5 seconds and reconnect. Log reconnection attempts to stderr. Maximum 10 consecutive reconnection attempts before giving up.
    - The `onInbound` callback is intentionally generic — the agent process will wire it to the decision loop in the future. For Phase 4, it just logs to stderr.

    **Update index.ts:** Re-export sendSol, sendSplToken, SendResult, getTransactionHistory, subscribeToWallet.

    **Update package.json:** Add `@solana-program/system` dependency. Run `pnpm install`.

    Run `pnpm --filter @jarvis/wallet build` to verify.
  </action>
  <verify>
    - `pnpm --filter @jarvis/wallet build` succeeds
    - send.ts calls checkSpendLimits before signing (governance-first pattern)
    - send.ts inserts wallet_transactions row on both success and rejection
    - send.ts uses signerClient.signTransaction (IPC), never touches private key directly
    - subscribe.ts implements reconnection logic with maximum retry limit
    - getTransactionHistory returns ordered results with limit/offset
  </verify>
  <done>
    Agent can send SOL and SPL tokens through the full pipeline: governance check -> transaction build -> IPC sign -> broadcast -> DB log. Rejected transactions are logged with reason. Inbound transfers trigger notifications via WebSocket subscription. Transaction history is queryable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Agent-facing wallet tools and process wiring</name>
  <files>
    packages/tools/src/wallet/index.ts
    packages/tools/src/index.ts
    apps/agent/src/index.ts
    apps/agent/src/shutdown.ts
    apps/agent/package.json
  </files>
  <action>
    **Wallet tool definitions (packages/tools/src/wallet/index.ts):**

    Create wallet tools following the established ToolDefinition pattern (see shellTool, httpTool for reference). All wallet tools are created via a factory function since they need DB and SignerClient injection.

    Add `@jarvis/wallet` as a dependency to @jarvis/tools package.json. Run `pnpm install`.

    **`createWalletTools(db: DbClient, signerClient: SignerClient): ToolDefinition[]`** — returns array of 4 tool definitions:

    1. **get_balance** tool:
       - name: 'get_balance'
       - description: 'Get the wallet SOL balance and all SPL token balances. Returns SOL in lamports and SOL units, plus all token holdings with mint address, amount, decimals, and human-readable amount.'
       - inputSchema: z.object({}) (no input needed)
       - timeoutMs: 30_000
       - execute: calls getBalances(db), returns WalletBalances

    2. **send_sol** tool:
       - name: 'send_sol'
       - description: 'Send SOL to a specified Solana address. Amount is in lamports (1 SOL = 1,000,000,000 lamports). Requires a stated purpose for the transaction audit trail. The transaction goes through spend limit governance before signing.'
       - inputSchema: z.object({ destination: z.string(), amountLamports: z.string(), purpose: z.string() })
       - timeoutMs: 60_000
       - execute: calls sendSol(db, signerClient, input.destination, input.amountLamports, input.purpose)

    3. **send_token** tool:
       - name: 'send_token'
       - description: 'Send an SPL token to a specified Solana address. Specify the token mint address and amount in base units (accounting for decimals). Automatically handles ATA creation if the destination has never held this token. Requires a stated purpose for the audit trail.'
       - inputSchema: z.object({ destination: z.string(), mintAddress: z.string(), amount: z.string(), purpose: z.string() })
       - timeoutMs: 60_000
       - execute: calls sendSplToken(db, signerClient, input.destination, input.mintAddress, input.amount, input.purpose)

    4. **get_tx_history** tool:
       - name: 'get_tx_history'
       - description: 'Query the wallet transaction history. Returns past sends with destination, amount, purpose, status, and timestamp. Useful for reviewing past spending and making informed financial decisions.'
       - inputSchema: z.object({ limit: z.number().optional().default(50), offset: z.number().optional().default(0) })
       - timeoutMs: 15_000
       - execute: calls getTransactionHistory(db, input.limit, input.offset)

    NOTE on import pattern: import { SignerClient } from '@jarvis/wallet' — this type import works because @jarvis/tools depends on @jarvis/wallet. Import getBalances, sendSol, sendSplToken, getTransactionHistory from '@jarvis/wallet'.

    **Update packages/tools/src/index.ts:**
    - Export createWalletTools from './wallet/index.js'
    - Add @jarvis/wallet to tools package.json deps

    **Agent process wiring (apps/agent/src/index.ts):**

    Add `@jarvis/wallet` as a dependency to apps/agent/package.json. Run `pnpm install`.

    In the main() function, after Phase 3 bootstrap and before `registerShutdownHandlers`:

    1. **Start signer co-process:**
       - Use `child_process.fork()` to start the signer: `fork(signerServerPath, [], { env: { SIGNER_SOCKET_PATH, SIGNER_SHARED_SECRET, SOLANA_PRIVATE_KEY }, stdio: ['ignore', 'pipe', 'pipe', 'ipc'] })`
       - The signer server path should resolve to the compiled signer server JS file. Use a helper to locate it: `path.resolve(import.meta.dirname, '../../node_modules/@jarvis/wallet/dist/signer/server.js')` or similar.
       - Pipe signer stdout/stderr to agent's stderr with `[signer]` prefix
       - Wait for signer to be ready: the signer should write a "ready" message to IPC (use process.send in server.ts — add this). The agent waits for this message with a 10-second timeout.
       - Read env vars: SIGNER_SOCKET_PATH (default /tmp/jarvis-signer.sock), SIGNER_SHARED_SECRET, SOLANA_PRIVATE_KEY. If SOLANA_PRIVATE_KEY is not set, skip wallet initialization entirely (log warning to stderr, do not crash — wallet features are optional if no key is configured).

    2. **Create SignerClient:**
       - `new SignerClient(socketPath, sharedSecret)`
       - Verify connection with `signerClient.ping()` — log success/failure to stderr

    3. **Create and register wallet tools:**
       - `const walletTools = createWalletTools(db, signerClient)`
       - Register each tool in the registry: `walletTools.forEach(t => registry.register(t))`
       - Log: `[agent] Wallet tools registered: get_balance, send_sol, send_token, get_tx_history`

    4. **Start inbound monitoring:**
       - `const walletSub = await subscribeToWallet(db, (event) => { process.stderr.write('[wallet] Inbound: ' + JSON.stringify(event) + '\n'); })`
       - This is best-effort — if wss_url is not configured in wallet_config, catch the error and log warning (do not crash)

    5. **Update openAITools:** Re-derive `toolDefinitionsToOpenAI(registry)` after adding wallet tools, so the LLM sees the new tools.

    **Shutdown updates (apps/agent/src/shutdown.ts):**
    - Add `signerProcess?: ChildProcess` to ShutdownResources interface (use duck-typed interface: `{ kill(signal?: string): boolean; pid?: number }` to avoid importing child_process types directly if needed)
    - Add `walletSubscription?: { stop: () => void }` to ShutdownResources
    - In gracefulShutdown:
      - Stop wallet subscription (call stop()) before stopping supervisor
      - Kill signer process (signerProcess.kill('SIGTERM')) after closing queues but before closing Redis/Postgres
      - Log each step

    **Pass new resources to registerShutdownHandlers call in index.ts.**

    Run `pnpm --filter @jarvis/agent build` to verify full compilation.
  </action>
  <verify>
    - `pnpm --filter @jarvis/agent build` succeeds with no TypeScript errors
    - `pnpm --filter @jarvis/tools build` succeeds
    - tools/src/wallet/index.ts exports createWalletTools
    - apps/agent/src/index.ts spawns signer process, creates SignerClient, registers 4 wallet tools
    - apps/agent/src/shutdown.ts kills signer process and stops wallet subscription on shutdown
    - Wallet initialization is skipped gracefully if SOLANA_PRIVATE_KEY is not set (no crash)
    - openAITools is re-derived after wallet tool registration so LLM sees all tools
  </verify>
  <done>
    Four wallet tools (get_balance, send_sol, send_token, get_tx_history) are registered in the tool registry and available to the AI for planning decisions. The signer co-process is started as a child process, managed by the agent, and shut down gracefully. Inbound token monitoring is active. The full transaction pipeline is wired end-to-end: AI calls tool -> governance check -> build tx -> IPC sign -> broadcast -> log to DB.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @jarvis/wallet build && pnpm --filter @jarvis/tools build && pnpm --filter @jarvis/agent build` — full build chain succeeds
2. grep for 'get_balance', 'send_sol', 'send_token', 'get_tx_history' in tools/src/wallet/index.ts confirms all 4 tools defined
3. apps/agent/src/index.ts contains signer process fork, SignerClient creation, and wallet tool registration
4. apps/agent/src/shutdown.ts contains signerProcess kill and walletSubscription stop
5. No private key references outside of signer server env var loading
6. Transaction flow: governance (checkSpendLimits) -> sign (signerClient.signTransaction) -> broadcast (rpc.sendTransaction) -> log (wallet_transactions insert)
</verification>

<success_criteria>
- Agent can send SOL and SPL tokens through the governance -> sign -> broadcast -> log pipeline
- Agent can receive tokens and is notified via WebSocket subscription
- All transactions are logged to wallet_transactions with destination, amount, purpose, and tx_signature
- Signer co-process is managed by agent process lifecycle (start on boot, kill on shutdown)
- Wallet features degrade gracefully if SOLANA_PRIVATE_KEY is not configured
- 4 wallet tools are available to the AI for autonomous financial decisions
</success_criteria>

<output>
After completion, create `.planning/phases/04-wallet-and-financial-governance/04-03-SUMMARY.md`
</output>
