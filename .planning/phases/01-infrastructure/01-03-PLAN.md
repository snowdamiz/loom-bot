---
phase: 01-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - packages/tools/src/registry.ts
  - packages/tools/src/types.ts
  - packages/tools/src/timeout.ts
  - packages/tools/src/invoke.ts
  - packages/tools/src/shell/index.ts
  - packages/tools/src/http/index.ts
  - packages/tools/src/file/index.ts
  - packages/tools/src/db-tool/index.ts
  - packages/tools/src/index.ts
autonomous: true
requirements:
  - TOOL-01
  - TOOL-02
  - TOOL-03
  - TOOL-04
  - TOOL-07

must_haves:
  truths:
    - "Shell tool executes commands and returns stdout, stderr, and exit code"
    - "HTTP tool makes GET/POST/PUT/DELETE/PATCH requests and returns status, headers, and body"
    - "File tool reads and writes files on the host filesystem"
    - "DB query tool executes SQL queries against Postgres and returns results"
    - "All tools fail gracefully with an error when they exceed their configured timeout"
    - "Tool registry accepts new tool registrations at runtime (extensible for Phase 8)"
    - "Every tool invocation flows through the logging wrapper automatically"
  artifacts:
    - path: "packages/tools/src/registry.ts"
      provides: "ToolRegistry class with register/invoke/list methods"
      exports: ["ToolRegistry"]
    - path: "packages/tools/src/types.ts"
      provides: "ToolDefinition interface and ToolResult type"
      exports: ["ToolDefinition", "ToolResult"]
    - path: "packages/tools/src/timeout.ts"
      provides: "AbortController-based timeout wrapper"
      exports: ["withTimeout"]
    - path: "packages/tools/src/invoke.ts"
      provides: "Logging-wrapped tool invocation"
      exports: ["invokeWithLogging"]
    - path: "packages/tools/src/shell/index.ts"
      provides: "Shell command execution tool"
      exports: ["shellTool"]
    - path: "packages/tools/src/http/index.ts"
      provides: "HTTP request tool with cookie jar and retry"
      exports: ["httpTool"]
    - path: "packages/tools/src/file/index.ts"
      provides: "File read/write tool"
      exports: ["fileTool"]
    - path: "packages/tools/src/db-tool/index.ts"
      provides: "Database query tool for agent use"
      exports: ["dbTool"]
  key_links:
    - from: "packages/tools/src/invoke.ts"
      to: "packages/logging/src/tool-logger.ts"
      via: "logToolStart/logToolComplete/logToolFailure calls"
      pattern: "logTool(Start|Complete|Failure)"
    - from: "packages/tools/src/registry.ts"
      to: "packages/tools/src/invoke.ts"
      via: "invoke method delegates to invokeWithLogging"
      pattern: "invokeWithLogging"
    - from: "packages/tools/src/shell/index.ts"
      to: "packages/tools/src/types.ts"
      via: "implements ToolDefinition interface"
      pattern: "ToolDefinition"
    - from: "packages/tools/src/timeout.ts"
      to: "packages/tools/src/types.ts"
      via: "wraps ToolDefinition.execute with AbortController"
      pattern: "AbortController"
---

<objective>
Build the tool registry, all four tool implementations (shell, HTTP, file, DB query), and the logging-integrated invocation wrapper.

Purpose: These are the agent's hands — the primitives it uses to interact with the world. The registry pattern makes tools extensible for Phase 8 self-extension. The invocation wrapper ensures every tool call flows through the logging layer automatically.

Output: @jarvis/tools package complete with ToolRegistry, 4 registered tool implementations, timeout enforcement, and automatic logging integration.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure/01-RESEARCH.md
@.planning/phases/01-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-infrastructure/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tool registry, types, timeout wrapper, and invocation layer</name>
  <files>
    packages/tools/src/types.ts
    packages/tools/src/registry.ts
    packages/tools/src/timeout.ts
    packages/tools/src/invoke.ts
  </files>
  <action>
    Build the core tool infrastructure:

    1. **`packages/tools/src/types.ts`** — Core type definitions:

       ```typescript
       import { z } from 'zod';

       export interface ToolDefinition<TInput = unknown, TOutput = unknown> {
         name: string;
         description: string;
         inputSchema: z.ZodType<TInput>;
         timeoutMs: number;          // default timeout, overridable per invocation
         maxOutputBytes?: number;     // output size cap (default 10MB for shell, unlimited for others)
         execute(input: TInput, signal: AbortSignal): Promise<TOutput>;
       }

       export interface ToolResult<T = unknown> {
         success: boolean;
         output?: T;
         error?: string;
         durationMs: number;
         truncated?: boolean;        // true if output was truncated due to size limit
       }
       ```

       Note: `execute` receives an `AbortSignal` so the tool implementation can check for abort and clean up resources. This is the standard Node.js pattern for cancellation.

    2. **`packages/tools/src/timeout.ts`** — AbortController-based timeout (TOOL-07):

       **`withTimeout<T>(fn: (signal: AbortSignal) => Promise<T>, timeoutMs: number): Promise<T>`**

       Creates AbortController, sets setTimeout to call `controller.abort()`, invokes `fn(controller.signal)`. On abort, throws a typed `ToolTimeoutError` with the timeout duration. Always clears the timer in `finally`. The error message should include the tool name and timeout value for debugging.

       Export `ToolTimeoutError` class extending `Error` with a `timeoutMs` property.

    3. **`packages/tools/src/registry.ts`** — ToolRegistry class:

       ```typescript
       class ToolRegistry {
         private tools = new Map<string, ToolDefinition>();

         register(tool: ToolDefinition): void
         unregister(name: string): boolean
         get(name: string): ToolDefinition | undefined
         has(name: string): boolean
         list(): Array<{ name: string; description: string }>
         count(): number
       }
       ```

       `register` throws if a tool with that name already exists (prevent silent overwrites). `unregister` is for Phase 8 when the agent may hot-swap tools. `list()` returns name + description pairs (useful for LLM tool selection).

    4. **`packages/tools/src/invoke.ts`** — Logging-wrapped invocation:

       **`invokeWithLogging(registry, db, toolName, rawInput, overrideTimeoutMs?)`**:

       - Look up tool from registry (throw if not found)
       - Validate input with `tool.inputSchema.parse(rawInput)` (zod validation)
       - Call `logToolStart(db, { toolName, input })` to get `parentId` (TOOL-05: log BEFORE execution)
       - Call `withTimeout(tool.execute, overrideTimeoutMs ?? tool.timeoutMs)` to execute with timeout
       - On success: apply output size limit if `maxOutputBytes` set (truncate + flag), call `logToolComplete(db, { parentId, output, durationMs })`, return `ToolResult` with `success: true`
       - On failure: call `logToolFailure(db, { parentId, error: err.message, durationMs })`, return `ToolResult` with `success: false, error: err.message`
       - On timeout (ToolTimeoutError): same as failure but error message clearly indicates timeout
       - NEVER throw — always return ToolResult. The caller decides how to handle failures.

       For output truncation: if `maxOutputBytes` is set and `JSON.stringify(output).length > maxOutputBytes`, truncate the stringified output and set `truncated: true` in the ToolResult and in the log.
  </action>
  <verify>
    - `pnpm --filter @jarvis/tools run build` compiles without errors
    - Unit-style verification via inline script: create a mock tool that returns after 100ms, register it, invoke with 5000ms timeout — succeeds. Create a mock tool that takes 5000ms, invoke with 100ms timeout — returns ToolResult with `success: false` and error mentioning timeout.
    - Verify logging integration: after invoking a tool, check tool_calls table has both started and completed rows with correct parentId linkage
  </verify>
  <done>
    ToolRegistry supports register/unregister/invoke, ToolDefinition interface includes zod schema and AbortSignal, timeout wrapper enforces configurable limits (TOOL-07), and invokeWithLogging guarantees pre-execution logging (TOOL-05) + post-execution logging (LOG-02) for every invocation. Output truncation prevents memory explosions from large outputs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement shell, HTTP, file, and DB query tools</name>
  <files>
    packages/tools/src/shell/index.ts
    packages/tools/src/http/index.ts
    packages/tools/src/file/index.ts
    packages/tools/src/db-tool/index.ts
    packages/tools/src/index.ts
  </files>
  <action>
    Implement the four tool types. Each tool is a `ToolDefinition` object. Add `got` and `tough-cookie` dependencies to `packages/tools/package.json` if not already present.

    1. **`packages/tools/src/shell/index.ts`** (TOOL-01):

       Input schema (zod): `{ command: string, args?: string[], cwd?: string, env?: Record<string, string> }`
       Default timeout: 30_000ms (30 seconds)
       maxOutputBytes: 10_485_760 (10MB)

       Implementation: Use `child_process.spawn` per research Pattern 3. Pass `signal` from AbortSignal to spawn options. Set `shell: false` always (security — even in unrestricted mode, avoid shell injection from agent-generated commands). Collect stdout and stderr as strings. Return `{ stdout, stderr, exitCode }`.

       **Size limiting:** Track output size as chunks arrive. If stdout + stderr exceeds `maxOutputBytes`, kill the child process and return what was collected with a truncation note.

       Export as `shellTool` (a ToolDefinition object).

    2. **`packages/tools/src/http/index.ts`** (TOOL-02):

       Input schema (zod): `{ method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH', url: string, headers?: Record<string, string>, body?: string, json?: unknown, followRedirects?: boolean, maxRedirects?: number }`
       Default timeout: 30_000ms

       Implementation: Use `got` v14 per research. Create a shared `got` instance with:
       - `CookieJar` from tough-cookie (persistent across requests within session)
       - `followRedirect: true`, `maxRedirects: 10` (defaults, overridable)
       - `throwHttpErrors: false` (return 4xx/5xx as results, not exceptions)
       - `responseType: 'text'`
       - Pass the AbortSignal via `signal` option (got supports this natively)

       If input has `json`, serialize to body and set Content-Type header. Return `{ status: number, headers: Record<string, string>, body: string }`.

       Convenience: If response Content-Type is `application/json`, also include a `parsedBody` field with the parsed JSON (or null if parse fails). This is a discretion item.

       Export as `httpTool`.

    3. **`packages/tools/src/file/index.ts`** (TOOL-03):

       Input schema (zod): `{ operation: 'read' | 'write' | 'append' | 'delete' | 'exists' | 'list', path: string, content?: string, encoding?: string }`
       Default timeout: 10_000ms

       Implementation: Use `fs/promises` API.
       - `read`: `readFile(path, encoding || 'utf-8')`. For files >5MB, use `createReadStream` + `pipeline()` to avoid memory issues.
       - `write`: `writeFile(path, content, encoding || 'utf-8')`. Create parent directories with `mkdir(dirname(path), { recursive: true })`.
       - `append`: `appendFile(path, content, encoding || 'utf-8')`.
       - `delete`: `unlink(path)`.
       - `exists`: `access(path).then(() => true).catch(() => false)`.
       - `list`: `readdir(path)` returning array of filenames.

       Return `{ operation, path, result }` where `result` is the content (for read), `true` (for write/append/delete), boolean (for exists), or string[] (for list).

       Export as `fileTool`.

    4. **`packages/tools/src/db-tool/index.ts`** (TOOL-04):

       Input schema (zod): `{ query: string, params?: unknown[] }`
       Default timeout: 30_000ms

       Implementation: This is the agent-facing database tool — distinct from `@jarvis/db` internal client. Uses `db.execute(sql.raw(query))` for arbitrary SQL. This enables DATA-02 (CREATE TABLE, ALTER TABLE) through the tool interface.

       Return `{ query, rowCount: number, rows: unknown[] }`. For DDL statements (CREATE, ALTER, DROP), `rows` will be empty and `rowCount` indicates affected rows.

       **Important:** This tool uses the same Drizzle `db` instance from `@jarvis/db`. It does NOT create a separate connection pool.

       Export as `dbTool`.

    5. **`packages/tools/src/index.ts`** — Update to re-export everything:
       - Re-export from `./types.js`, `./registry.js`, `./timeout.js`, `./invoke.js`
       - Re-export from `./redis.js`, `./session.js`
       - Re-export from `./shell/index.js`, `./http/index.js`, `./file/index.js`, `./db-tool/index.js`
       - Export a convenience function `createDefaultRegistry(db: DbClient): ToolRegistry` that creates a registry and registers all 4 default tools. This is what `apps/agent` will call.

    Run `pnpm install` from root to pick up new dependencies (got, tough-cookie).
  </action>
  <verify>
    - `pnpm --filter @jarvis/tools run build` compiles without errors
    - **Shell tool**: Invoke `shellTool.execute({ command: 'echo', args: ['hello'] }, signal)` — returns `{ stdout: 'hello\n', stderr: '', exitCode: 0 }`
    - **Shell timeout**: Invoke shell with `{ command: 'sleep', args: ['10'] }` and 100ms timeout — fails with timeout error
    - **HTTP tool**: Invoke `httpTool.execute({ method: 'GET', url: 'https://httpbin.org/get' }, signal)` — returns status 200 with JSON body
    - **File tool**: Write a temp file, read it back, verify content matches, delete it, verify exists returns false
    - **DB query tool**: Execute `SELECT 1 as test` — returns `{ rows: [{ test: 1 }], rowCount: 1 }`
    - **DB DDL tool**: Execute `CREATE TABLE IF NOT EXISTS tool_test (id int)` — succeeds. Execute `DROP TABLE tool_test` — succeeds.
    - **Full integration**: Use `invokeWithLogging` to call shell tool, then verify tool_calls table has started + completed rows with correct data
  </verify>
  <done>
    All four tool types work: shell executes commands and returns stdout/stderr/exitCode (TOOL-01), HTTP makes requests with cookie jar and redirect following (TOOL-02), file reads/writes/deletes on the filesystem (TOOL-03), DB query executes arbitrary SQL including DDL (TOOL-04). All tools respect configurable timeouts via AbortController (TOOL-07). `createDefaultRegistry` provides a ready-to-use registry with all tools registered.
  </done>
</task>

</tasks>

<verification>
1. Shell: `echo hello` returns "hello", `sleep 10` with 100ms timeout fails gracefully (TOOL-01, TOOL-07)
2. HTTP: GET to httpbin.org returns 200 (TOOL-02)
3. File: write + read + delete cycle works (TOOL-03)
4. DB: SELECT and DDL both work through the tool (TOOL-04)
5. All tool invocations via `invokeWithLogging` produce correct log entries in tool_calls table (LOG-02)
6. Registry lists all 4 tools and accepts new registrations
7. Timeout error messages identify which tool and what timeout value
</verification>

<success_criteria>
- All 4 tool types execute successfully and return structured results
- Timeouts work: a slow operation is killed and returns a graceful error
- invokeWithLogging produces pre-execution and post-execution log rows for every invocation
- createDefaultRegistry returns a registry with 4 tools registered
- `pnpm --filter @jarvis/tools run build` compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-03-SUMMARY.md`
</output>
