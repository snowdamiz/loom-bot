---
phase: 06-browser-identity-and-bootstrapping
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - packages/tools/src/browser/navigate.ts
  - packages/tools/src/browser/interact.ts
  - packages/tools/src/browser/screenshot.ts
  - packages/tools/src/browser/session-manage.ts
  - packages/tools/src/browser/index.ts
  - packages/tools/src/browser/_state.ts
  - packages/tools/src/index.ts
  - packages/tools/package.json
autonomous: true
requirements:
  - BROWSER-01
  - BROWSER-02
  - BROWSER-03
  - BROWSER-04

must_haves:
  truths:
    - "Agent can navigate to a URL and get the page title and content"
    - "Agent can fill a form field, click a button, and extract text from a page element"
    - "Agent can opt into human-like typing delays (typeDelay) and human-like click behavior (humanLike flag) per locked stealth decision"
    - "Agent can take a screenshot and receive it as base64"
    - "Agent can save and load browser session state for a specific identity"
    - "Browser sessions use stealth mode by default with Playwright-extra"
  artifacts:
    - path: "packages/tools/src/browser/navigate.ts"
      provides: "browser_navigate ToolDefinition"
      exports: ["createBrowserNavigateTool"]
    - path: "packages/tools/src/browser/interact.ts"
      provides: "browser_click, browser_fill, browser_extract ToolDefinitions with human-like timing options"
      exports: ["createBrowserClickTool", "createBrowserFillTool", "createBrowserExtractTool"]
    - path: "packages/tools/src/browser/screenshot.ts"
      provides: "browser_screenshot ToolDefinition"
      exports: ["createBrowserScreenshotTool"]
    - path: "packages/tools/src/browser/session-manage.ts"
      provides: "browser_session_open, browser_session_close, browser_session_save ToolDefinitions"
      exports: ["createBrowserSessionOpenTool", "createBrowserSessionCloseTool", "createBrowserSessionSaveTool"]
    - path: "packages/tools/src/browser/_state.ts"
      provides: "Shared activeSessions map and getSession helper"
      exports: ["activeSessions", "getSession", "generateSessionId"]
    - path: "packages/tools/src/browser/index.ts"
      provides: "createBrowserTools factory returning all browser ToolDefinitions"
      exports: ["createBrowserTools"]
  key_links:
    - from: "packages/tools/src/browser/navigate.ts"
      to: "@jarvis/browser"
      via: "BrowserSession page navigation"
      pattern: "page\\.goto"
    - from: "packages/tools/src/browser/interact.ts"
      to: "@jarvis/browser"
      via: "BrowserSession page interaction (fill/type/click/locator) with human-like options"
      pattern: "page\\.(fill|type|click|locator)"
    - from: "packages/tools/src/browser/session-manage.ts"
      to: "@jarvis/browser"
      via: "BrowserManager + BrowserSession lifecycle"
      pattern: "BrowserSession|BrowserManager"
---

<objective>
Create the browser automation tool group: navigation, form interaction, content extraction, screenshots, and session lifecycle management.

Purpose: These tools give the agent the ability to interact with any website programmatically. Combined with the identity tools from Plan 02, the agent can create accounts, fill forms, extract data, and persist sessions per identity. This is the browser half of Phase 6's core capability.

Output: 8 ToolDefinitions (browser_navigate, browser_click, browser_fill, browser_extract, browser_screenshot, browser_session_open, browser_session_close, browser_session_save) in packages/tools/src/browser/.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-browser-identity-and-bootstrapping/06-RESEARCH.md
@.planning/phases/06-browser-identity-and-bootstrapping/06-01-SUMMARY.md
@packages/tools/src/types.ts
@packages/tools/src/index.ts
@packages/tools/src/registry.ts
@packages/browser/src/index.ts
@packages/browser/src/manager.ts
@packages/browser/src/session.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create browser navigation and interaction tools</name>
  <files>
    packages/tools/src/browser/navigate.ts
    packages/tools/src/browser/interact.ts
    packages/tools/src/browser/screenshot.ts
    packages/tools/package.json
  </files>
  <action>
The browser tools need a shared state: an active BrowserSession per identity. Use a module-level Map<string, { session: BrowserSession, page: Page }> called `activeSessions` to track open sessions. The session-manage tools (Task 2) control this map. The navigation/interaction tools operate on it.

Create a shared module `packages/tools/src/browser/_state.ts` that exports:
```typescript
import type { BrowserSession } from '@jarvis/browser';
import type { Page } from 'playwright';

export interface ActiveSession {
  session: BrowserSession;
  page: Page;
}

export const activeSessions = new Map<string, ActiveSession>();

export function getSession(sessionId: string): ActiveSession {
  const s = activeSessions.get(sessionId);
  if (!s) throw new Error(`No active browser session with id '${sessionId}'. Call browser_session_open first.`);
  return s;
}
```

Add @jarvis/browser as a dependency to packages/tools/package.json.

NOTE on playwright types: Import `Page` type from 'playwright' (NOT playwright-extra). playwright-extra re-exports Playwright types but the base `playwright` package is the canonical source for type imports. @jarvis/browser depends on playwright so it's available transitively... but under pnpm strict isolation @jarvis/tools can't import playwright transitively. Add `playwright` as a direct dependency of @jarvis/tools as well (it's needed for Page type and for the actual page interactions). Alternatively, if adding playwright as a dep is too heavy, use duck-typed interfaces or import types from @jarvis/browser if it re-exports them. The simplest correct approach: add `playwright` to @jarvis/tools dependencies.

**navigate.ts**: `createBrowserNavigateTool()` factory.
- Name: 'browser_navigate'
- Input: { sessionId: string, url: string, waitUntil?: 'load' | 'domcontentloaded' | 'networkidle' (default 'load') }
- Gets session from activeSessions map via getSession(sessionId)
- Calls page.goto(url, { waitUntil })
- Returns: { url: page.url(), title: await page.title(), status: response?.status() }
- Timeout: 30 seconds (use page.goto timeout option)
- On error: return { error: message } (don't throw -- ToolDefinition pattern)

**interact.ts**: Three ToolDefinitions.

`createBrowserClickTool()`:
- Name: 'browser_click'
- Input: { sessionId: string, selector: string, timeout?: number (default 5000), humanLike?: boolean (default false) }
- If humanLike is true:
  1. Use page.locator(selector).boundingBox() to get the element's position
  2. Calculate a random point within the bounding box (not dead center -- offset by random +-30% from center)
  3. Move mouse to the target with page.mouse.move(x, y, { steps: randomInt(5, 15) }) -- `steps` creates intermediate points simulating a human mouse path
  4. Add a random pre-click delay: await new Promise(r => setTimeout(r, randomInt(50, 200)))
  5. Call page.mouse.click(x, y) instead of page.click(selector)
- If humanLike is false (default): calls page.click(selector, { timeout }) as before
- Returns: { clicked: true, selector }
- If element not found within timeout: returns { clicked: false, error: 'Element not found' }
- Per locked stealth decision: "human-like timing/mouse movements" -- the humanLike flag exposes this capability to the agent, who decides per-situation whether to use it

`createBrowserFillTool()`:
- Name: 'browser_fill'
- Input: { sessionId: string, selector: string, value: string, timeout?: number (default 5000), typeDelay?: number (optional, ms between keystrokes) }
- If typeDelay is provided (> 0):
  1. First click the field: page.click(selector, { timeout }) to focus it
  2. Clear existing content: page.locator(selector).fill('') (clear without typing)
  3. Use page.type(selector, value, { delay: typeDelay }) to simulate human keystroke timing
  4. This fires individual keydown/keypress/keyup events per character, unlike page.fill() which sets the value instantaneously
  5. For realistic behavior, the agent can pass typeDelay: 50-150 (ms) to simulate human typing speed
- If typeDelay is not provided or 0: calls page.fill(selector, value, { timeout }) as before (fast, programmatic)
- Returns: { filled: true, selector }
- If element not found: returns { filled: false, error: 'Element not found' }
- Per locked stealth decision: "human-like timing/mouse movements" -- typeDelay exposes human-like typing to the agent, who decides per-situation whether to use it

`createBrowserExtractTool()`:
- Name: 'browser_extract'
- Input: { sessionId: string, selector: string, attribute?: string, multiple?: boolean (default false) }
- If multiple=false: page.locator(selector).first().textContent() (or getAttribute(attribute) if attribute specified)
- If multiple=true: page.locator(selector).allTextContents() (or allInnerTexts())
- Returns: { content: string | string[] }
- Truncate extracted content to 10000 chars to prevent LLM context overflow

**screenshot.ts**: `createBrowserScreenshotTool()` factory.
- Name: 'browser_screenshot'
- Input: { sessionId: string, fullPage?: boolean (default false), selector?: string }
- If selector: page.locator(selector).screenshot({ type: 'png' })
- Else: page.screenshot({ fullPage, type: 'png' })
- Returns screenshot as base64 string: { screenshot: buffer.toString('base64'), format: 'png' }
- NOTE: Screenshots can be large. Limit output to 500KB of base64 (truncate if larger with a warning).

For all tools, wrap the Playwright operation in try/catch and return { error: message } on failure (never throw from a ToolDefinition execute function -- established pattern from Phase 1).
  </action>
  <verify>
1. `pnpm --filter @jarvis/tools run build` exits 0
2. Verify imports compile: `pnpm --filter @jarvis/tools exec tsx -e "import { createBrowserNavigateTool, createBrowserClickTool, createBrowserFillTool, createBrowserExtractTool, createBrowserScreenshotTool } from './src/browser/navigate.js'; console.log('navigate OK'); process.exit(0);"` -- may need adjustment based on actual file structure
  </verify>
  <done>
Five browser interaction ToolDefinitions compile: browser_navigate, browser_click (with humanLike mouse movement option), browser_fill (with typeDelay keystroke simulation option), browser_extract, browser_screenshot. All operate on shared activeSessions map. All return structured output without throwing. Human-like timing options exposed per locked stealth decision. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create browser session lifecycle tools and barrel export</name>
  <files>
    packages/tools/src/browser/session-manage.ts
    packages/tools/src/browser/index.ts
    packages/tools/src/browser/_state.ts
    packages/tools/src/index.ts
  </files>
  <action>
**_state.ts**: Already defined conceptually in Task 1. Create this file with the activeSessions map and getSession helper. Also add `generateSessionId()` that returns a random 8-char hex string (crypto.randomBytes(4).toString('hex')).

**session-manage.ts**: Three ToolDefinitions for session lifecycle.

`createBrowserSessionOpenTool(browserManager)`: factory taking BrowserManager instance.
- Name: 'browser_session_open'
- Input: {
    identityId?: string (optional -- if not provided, uses 'anonymous'),
    proxy?: { server: string, username?: string, password?: string },
    storageStatePath?: string (path to previously saved session JSON),
    userAgent?: string,
    viewport?: { width: number, height: number }
  }
- Creates a new BrowserSession(manager, identityId, proxy, storageStatePath, etc.)
- Calls session.open() to create the BrowserContext
- Calls session.newPage() to get initial page
- Generates sessionId, stores in activeSessions map
- Returns: { sessionId, identityId, message: 'Browser session opened. Use sessionId in subsequent browser tool calls.' }

`createBrowserSessionCloseTool()`:
- Name: 'browser_session_close'
- Input: { sessionId: string }
- Gets session from activeSessions map
- Calls session.close()
- Removes from activeSessions map
- Returns: { closed: true, sessionId }

`createBrowserSessionSaveTool()`:
- Name: 'browser_session_save'
- Input: { sessionId: string, savePath?: string }
- Gets session from activeSessions map
- Default savePath: `data/sessions/{identityId}.json` (create data/sessions/ dir if not exists)
- Calls session.saveState(savePath)
- Returns: { saved: true, path: savePath }

**index.ts**: Barrel export + convenience factory.

```typescript
export { activeSessions, getSession } from './_state.js';
export { createBrowserNavigateTool } from './navigate.js';
export { createBrowserClickTool, createBrowserFillTool, createBrowserExtractTool } from './interact.js';
export { createBrowserScreenshotTool } from './screenshot.js';
export { createBrowserSessionOpenTool, createBrowserSessionCloseTool, createBrowserSessionSaveTool } from './session-manage.js';

import type { BrowserManager } from '@jarvis/browser';
import type { ToolDefinition } from '../types.js';
// ... import all factories

export function createBrowserTools(browserManager: BrowserManager): ToolDefinition<any, any>[] {
  return [
    createBrowserNavigateTool(),
    createBrowserClickTool(),
    createBrowserFillTool(),
    createBrowserExtractTool(),
    createBrowserScreenshotTool(),
    createBrowserSessionOpenTool(browserManager),
    createBrowserSessionCloseTool(),
    createBrowserSessionSaveTool(),
  ];
}
```

**Update packages/tools/src/index.ts**: Add browser tool exports:
```typescript
// Browser tools (Phase 06)
export { createBrowserTools } from './browser/index.js';
```

After implementation:
1. `pnpm --filter @jarvis/tools run build` to verify
2. Verify the convenience factory compiles and returns correct count
  </action>
  <verify>
1. `pnpm --filter @jarvis/tools run build` exits 0
2. `pnpm --filter @jarvis/tools exec tsx -e "import { createBrowserTools } from './src/browser/index.js'; import { BrowserManager } from '@jarvis/browser'; const mgr = new BrowserManager(); const tools = createBrowserTools(mgr); console.log('Browser tools:', tools.length, tools.map(t => t.name)); process.exit(0);"` -- prints 8 tool names
  </verify>
  <done>
Browser tool group complete: 8 ToolDefinitions (session_open/close/save, navigate, click, fill, extract, screenshot) exported via createBrowserTools(browserManager) factory. Session state managed via activeSessions map. All tools follow ToolDefinition interface. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @jarvis/tools run build` -- full package compiles with browser tools
2. createBrowserTools(mgr) returns 8 ToolDefinitions
3. All tools have zod inputSchema with sessionId parameter
4. browser_click has humanLike?: boolean input option for mouse path simulation
5. browser_fill has typeDelay?: number input option for keystroke timing simulation
6. Session lifecycle: open creates session in map, close removes it, save persists storageState
</verification>

<success_criteria>
- browser_navigate loads URLs and returns title/status
- browser_click interacts with page elements via CSS selectors, with optional humanLike mouse movement (steps-based mouse.move + random offset)
- browser_fill fills form fields, with optional typeDelay for human-like keystroke timing via page.type()
- browser_extract reads text/attributes from page elements
- browser_screenshot captures page as base64 PNG
- browser_session_open creates isolated BrowserContext per identity with optional proxy
- browser_session_save persists cookies/storage to JSON file
- All 8 tools follow ToolDefinition pattern with error handling (no throws)
- Human-like timing/mouse movements available per locked stealth decision (agent chooses when to use)
</success_criteria>

<output>
After completion, create `.planning/phases/06-browser-identity-and-bootstrapping/06-03-SUMMARY.md`
</output>
