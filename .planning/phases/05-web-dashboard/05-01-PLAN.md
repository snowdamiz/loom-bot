---
phase: 05-web-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/dashboard/package.json
  - apps/dashboard/tsconfig.json
  - apps/dashboard/src/index.ts
  - apps/dashboard/src/app.ts
  - apps/dashboard/src/middleware/auth.ts
  - apps/dashboard/src/routes/status.ts
  - apps/dashboard/src/routes/kill-switch.ts
  - apps/dashboard/src/routes/pnl.ts
  - apps/dashboard/src/routes/activity.ts
  - apps/dashboard/src/routes/sse.ts
  - apps/dashboard/src/broadcaster.ts
  - apps/dashboard/src/poller.ts
autonomous: true
requirements:
  - DASH-01
  - DASH-02
  - DASH-03
  - DASH-04
  - DASH-05
  - DASH-06
  - DASH-07

must_haves:
  truths:
    - "GET /api/status returns agent status JSON (kill switch state, system status, active goals)"
    - "POST /api/kill-switch with valid token activates/deactivates kill switch"
    - "GET /api/activity returns cursor-paginated activity entries"
    - "GET /api/pnl returns P&L summary data"
    - "GET /api/sse streams SSE events with status and activity updates"
    - "All /api/* routes reject requests without valid Bearer token"
  artifacts:
    - path: "apps/dashboard/package.json"
      provides: "Dashboard server package definition"
      contains: "@jarvis/dashboard"
    - path: "apps/dashboard/src/app.ts"
      provides: "Hono app factory with middleware and routes"
      exports: ["default"]
    - path: "apps/dashboard/src/routes/status.ts"
      provides: "Agent status endpoint"
      exports: ["default"]
    - path: "apps/dashboard/src/routes/kill-switch.ts"
      provides: "Kill switch control endpoint"
      exports: ["default"]
    - path: "apps/dashboard/src/routes/activity.ts"
      provides: "Activity feed endpoint"
      exports: ["default"]
    - path: "apps/dashboard/src/routes/sse.ts"
      provides: "SSE streaming endpoint"
      exports: ["default"]
    - path: "apps/dashboard/src/broadcaster.ts"
      provides: "EventEmitter singleton for SSE fan-out"
      exports: ["broadcaster"]
  key_links:
    - from: "apps/dashboard/src/routes/kill-switch.ts"
      to: "@jarvis/ai activateKillSwitch/deactivateKillSwitch"
      via: "function import"
      pattern: "activateKillSwitch|deactivateKillSwitch"
    - from: "apps/dashboard/src/routes/status.ts"
      to: "@jarvis/db agentState, goals"
      via: "drizzle query"
      pattern: "agentState|goals"
    - from: "apps/dashboard/src/routes/pnl.ts"
      to: "@jarvis/db getPnl, getAiSpendSummary"
      via: "function import"
      pattern: "getPnl|getAiSpendSummary"
    - from: "apps/dashboard/src/poller.ts"
      to: "apps/dashboard/src/broadcaster.ts"
      via: "EventEmitter emit"
      pattern: "broadcaster\\.emit"
---

<objective>
Create the Hono API server for the dashboard with all REST endpoints, authentication, and SSE real-time streaming.

Purpose: This is the entire backend for the operator dashboard. It exposes agent status, activity feed, P&L data, kill switch control, and an SSE stream for real-time updates. All data comes from existing `@jarvis/db` tables and `@jarvis/ai` functions -- no new DB tables needed.

Output: `apps/dashboard` package with a fully functional Hono API server listening on port 3001.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-web-dashboard/05-RESEARCH.md

@packages/db/src/index.ts
@packages/db/src/schema/pnl-view.ts
@packages/db/src/schema/agent-state.ts
@packages/db/src/schema/goals.ts
@packages/db/src/schema/tool-calls.ts
@packages/db/src/schema/decision-log.ts
@packages/db/src/schema/wallet-transactions.ts
@packages/db/src/schema/planning-cycles.ts
@packages/ai/src/kill-switch.ts
@packages/ai/src/index.ts
@pnpm-workspace.yaml
@packages/typescript-config/base.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dashboard package scaffold + auth + REST routes</name>
  <files>
    apps/dashboard/package.json
    apps/dashboard/tsconfig.json
    apps/dashboard/src/app.ts
    apps/dashboard/src/middleware/auth.ts
    apps/dashboard/src/routes/status.ts
    apps/dashboard/src/routes/kill-switch.ts
    apps/dashboard/src/routes/pnl.ts
    apps/dashboard/src/routes/activity.ts
  </files>
  <action>
    **Package scaffold:**
    - Create `apps/dashboard/package.json`:
      - name: `@jarvis/dashboard`
      - type: `module`
      - scripts: `build` (tsc), `dev` (tsx watch src/index.ts), `start` (node dist/index.js)
      - dependencies: `hono`, `@hono/node-server`, `@hono/zod-validator`, `zod`, `@jarvis/db` (workspace:*), `@jarvis/ai` (workspace:*)
      - devDependencies: `@jarvis/typescript-config` (workspace:*), `tsx`
    - Create `apps/dashboard/tsconfig.json` extending `@jarvis/typescript-config/base.json` with `outDir: "./dist"`, `rootDir: "./src"`, include `["src"]`
    - Run `pnpm install` from workspace root to link dependencies

    **Auth middleware:**
    - Create `src/middleware/auth.ts`:
      - Export `createAuthMiddleware()` that reads `DASHBOARD_TOKEN` from `process.env`
      - If `DASHBOARD_TOKEN` is not set, throw an Error (fail fast at startup)
      - Use `bearerAuth` from `hono/bearer-auth` with `verifyToken` callback comparing incoming token to the env var value
      - Hono's bearerAuth handles timing-safe comparison internally

    **Hono app factory:**
    - Create `src/app.ts`:
      - Import `Hono` from `hono`
      - Import `cors` from `hono/cors` -- configure to allow `Authorization` and `Content-Type` headers, origin `*` in dev
      - Apply `cors` middleware to `/api/*`
      - Apply `createAuthMiddleware()` to `/api/*`
      - Mount routes: `/api/status`, `/api/kill-switch`, `/api/activity`, `/api/pnl`, `/api/sse` (SSE route created in Task 2)
      - Export the app as default

    **Status route (`src/routes/status.ts`):**
    - GET `/` handler:
      - Query `agentState` table for keys `kill_switch` and `system:status`
      - Query `goals` table for active goals (`status = 'active'`)
      - Return JSON: `{ isHalted, haltReason, activatedAt, systemStatus, activeGoals: [{id, description, priority}], uptime }`
      - `uptime`: compute from `system:status` value's `startedAt` field (if present) or null
      - Import db, agentState, goals, eq from `@jarvis/db` -- not from drizzle-orm directly (pnpm strict isolation)

    **Kill switch route (`src/routes/kill-switch.ts`):**
    - POST `/` handler:
      - Validate body with `@hono/zod-validator`: `{ action: z.enum(['activate', 'deactivate']), reason: z.string().min(1).max(500) }`
      - If `action === 'activate'`: call `activateKillSwitch(db, reason, 'dashboard')` from `@jarvis/ai`
      - If `action === 'deactivate'`: call `deactivateKillSwitch(db, reason, 'dashboard')` from `@jarvis/ai`
      - After DB write, import `broadcaster` from `../broadcaster.js` and emit `('update', 'status', { killSwitchAction: action })` for immediate SSE push
      - Return `{ ok: true, action }`

    **P&L route (`src/routes/pnl.ts`):**
    - GET `/` handler:
      - Optional query param `since` (ISO date string) parsed to Date
      - Call `getPnl(db, { since })` and `getAiSpendSummary(db)` from `@jarvis/db` (both exported from pnl-view.ts)
      - Return `{ pnl, aiSpend }`
    - GET `/revenue` handler:
      - Optional query param `strategyId`
      - Call `getRevenueTotal(db, strategyId)` from `@jarvis/db`
      - Return `{ total, strategyId }`

    **Activity feed route (`src/routes/activity.ts`):**
    - GET `/` handler:
      - Query params: `cursor` (last seen id, optional), `limit` (default 50, max 100), `type` (optional filter: 'tool_calls' | 'decisions' | 'wallet' | 'planning'), `search` (optional text search)
      - Query the appropriate table based on `type` filter. Default (no type filter): query `tool_calls` as the primary feed.
      - For `type=decisions`: query `decisionLog` table
      - For `type=wallet`: query `walletTransactions` table
      - For `type=planning`: query `planningCycles` table
      - Apply cursor pagination: `WHERE id < cursor ORDER BY id DESC LIMIT limit`
      - If `search` provided, apply `ILIKE` filter on relevant text columns (toolName for tool_calls, decision for decisionLog, etc.)
      - Return `{ rows, nextCursor, type }`
      - Import all table schemas and `desc, lt` from `@jarvis/db`

    **Critical patterns:**
    - All imports from `@jarvis/db` (not drizzle-orm) for pnpm strict isolation
    - All local imports use `.js` extension (NodeNext module resolution)
    - `db` imported from `@jarvis/db` at module level (singleton pattern established in prior phases)
  </action>
  <verify>
    Run `cd /Users/sn0w/Documents/dev/jarvis && pnpm --filter @jarvis/dashboard exec tsc --noEmit` to verify TypeScript compilation. All routes should type-check without errors.
  </verify>
  <done>
    apps/dashboard package exists with package.json, tsconfig.json, auth middleware, and 4 REST routes (status, kill-switch, pnl, activity) that type-check successfully. All routes use @jarvis/db and @jarvis/ai imports correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: SSE broadcaster + poller + server entry point</name>
  <files>
    apps/dashboard/src/broadcaster.ts
    apps/dashboard/src/poller.ts
    apps/dashboard/src/routes/sse.ts
    apps/dashboard/src/index.ts
  </files>
  <action>
    **SSE Broadcaster (`src/broadcaster.ts`):**
    - Export `broadcaster` as an `EventEmitter` singleton from `node:events`
    - Set `maxListeners` to 100 (dashboard is low-traffic but multiple tabs may connect)
    - This is the central fan-out mechanism: poller emits to broadcaster, SSE route subscribes

    **DB Poller (`src/poller.ts`):**
    - Export `startPoller(db, intervalMs = 2000): NodeJS.Timeout`
    - Accept db as parameter (not import singleton) for testability
    - Every `intervalMs`:
      - Query `agentState` for `kill_switch` and `system:status` keys
      - Query `goals` for active goals
      - Query `toolCalls` for the most recent N entries (e.g., last 5 by id DESC)
      - Query `decisionLog` for the most recent entry
      - Emit `broadcaster.emit('update', 'status', statusPayload)` with kill switch state + system status + active goals
      - Emit `broadcaster.emit('update', 'activity', latestEntries)` with latest tool call and decision entries
    - Wrap entire poll cycle in try/catch -- non-fatal errors logged to stderr, never crashes the poller
    - Import db tables from `@jarvis/db`, broadcaster from `./broadcaster.js`

    **SSE Route (`src/routes/sse.ts`):**
    - GET `/` handler using `streamSSE` from `hono/streaming`:
      - Increment a module-level `clientId` counter
      - Send initial `connected` event with `{ clientId }`
      - Register handler on `broadcaster.on('update', handler)` that calls `stream.writeSSE({ event, data: JSON.stringify(data), id: String(msgId++) })`
      - Set up heartbeat interval at 30 seconds: `stream.writeSSE({ data: '', comment: 'heartbeat' })`
      - On `stream.onAbort()`: remove broadcaster listener, clear heartbeat interval
      - Keep stream open with `await new Promise<void>(resolve => stream.onAbort(resolve))`
    - Export as default Hono app

    **Server entry point (`src/index.ts`):**
    - Import `serve` from `@hono/node-server`
    - Import `serveStatic` from `@hono/node-server/serve-static`
    - Import `app` from `./app.js`
    - Import `startPoller` from `./poller.js`
    - Import `db` from `@jarvis/db`
    - Read `DASHBOARD_PORT` env var (default 3001)
    - Mount `serveStatic({ root: './public' })` on `/*` for production SPA serving
    - Mount SPA fallback: `app.get('/*', serveStatic({ path: './public/index.html' }))` -- AFTER API routes
    - Call `startPoller(db)` to begin DB polling
    - Call `serve({ fetch: app.fetch, port: PORT })` with startup log to stderr
    - Handle SIGTERM/SIGINT for graceful shutdown (clear poller interval)

    **Wire SSE route into app.ts:**
    - Ensure `src/app.ts` imports and mounts SSE route at `/api/sse`

    **Critical patterns:**
    - `stream.onAbort()` is the ONLY reliable cleanup signal -- Vite proxy does not forward TCP close
    - Heartbeat every 30s keeps connection alive through proxies
    - Poller is non-fatal -- errors logged to stderr, never crashes
    - serveStatic MUST come after API routes in app.ts to avoid catching /api/* requests
  </action>
  <verify>
    Run `cd /Users/sn0w/Documents/dev/jarvis && pnpm --filter @jarvis/dashboard exec tsc --noEmit` to verify full compilation. Then run `DASHBOARD_TOKEN=test DASHBOARD_PORT=3001 pnpm --filter @jarvis/dashboard dev` and verify:
    1. Server starts and logs listening message
    2. `curl -H 'Authorization: Bearer test' http://localhost:3001/api/status` returns JSON
    3. `curl http://localhost:3001/api/status` returns 401
    4. `curl -H 'Authorization: Bearer test' -N http://localhost:3001/api/sse` starts streaming SSE events
  </verify>
  <done>
    Dashboard API server runs on port 3001, all 5 endpoints respond correctly, SSE stream delivers real-time updates, unauthenticated requests are rejected with 401.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @jarvis/dashboard exec tsc --noEmit` passes with zero errors
2. Server starts with `DASHBOARD_TOKEN=test pnpm --filter @jarvis/dashboard dev`
3. GET /api/status returns 200 with agent status JSON (requires valid Bearer token)
4. POST /api/kill-switch returns 200 with `{ ok: true }` (requires valid Bearer token + valid body)
5. GET /api/activity returns 200 with `{ rows, nextCursor }` (requires valid Bearer token)
6. GET /api/pnl returns 200 with `{ pnl, aiSpend }` (requires valid Bearer token)
7. GET /api/sse returns text/event-stream with connected event (requires valid Bearer token)
8. Any endpoint without Bearer token returns 401
</verification>

<success_criteria>
- All 5 API endpoints functional and type-safe
- Bearer auth gate rejects unauthenticated requests
- SSE stream delivers real-time status and activity updates
- Existing @jarvis/db and @jarvis/ai integrations work correctly
- Server runs independently with `pnpm --filter @jarvis/dashboard dev`
</success_criteria>

<output>
After completion, create `.planning/phases/05-web-dashboard/05-01-SUMMARY.md`
</output>
