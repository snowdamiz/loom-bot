# Phase 11: Version-Controlled Self-Modification Pipeline - Research

**Researched:** 2026-02-19
**Domain:** GitHub-backed branch/commit/PR orchestration for core self-modification
**Confidence:** HIGH-MEDIUM (current code paths + GitHub REST workflow are clear; merge-policy details remain product decisions)

<user_constraints>
## User Constraints (from CONTEXT.md)

No `11-CONTEXT.md` exists yet, so this research used roadmap + requirements + existing implementation only.

Planning assumptions used for this phase:
- Keep existing stack: TypeScript monorepo, Drizzle/Postgres, Hono-style GitHub helpers, `fetch`-based GitHub API calls.
- Reuse Phase 10 trust model (`setup_state` repo binding + encrypted GitHub OAuth token credential reference).
- Keep `tool_write` as the entry point for built-in/core changes; replace local fast-forward staging with repository PR flow.
- Treat sandbox output as promotion evidence: it must be attached to the PR and reflected in merge gating state.
</user_constraints>

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| SEXT-05 | Every core self-modification must occur on a dedicated branch derived from the repository default branch | Use trusted repo binding (`githubRepoFullName`, `githubRepoDefaultBranch`) and Git refs APIs to create deterministic short-lived branches from default branch HEAD SHA. |
| SEXT-06 | Each proposed change must produce a commit with machine-readable metadata (goal id, cycle id, tool name) | Add execution-context propagation and commit trailers/JSON metadata block generated by the self-extension pipeline. |
| SEXT-07 | System must open/update a PR for candidate changes and attach sandbox test evidence/status | Implement PR upsert by branch head, post structured evidence summary/comment, and set commit status context for sandbox result. |
| SEXT-08 | Merge/promotion must require successful sandbox/regression checks; failed checks prevent merge | Enforce pre-merge guard on required status contexts; call merge endpoint only on success and fail closed on pending/failure states. |
</phase_requirements>

---

## Summary

Phase 10 established repository trust prerequisites (`githubConnected`, bound repo metadata, encrypted OAuth credential pointer) and a fail-closed guard before `builtinModify` execution. However, current built-in modification flow is still local-only: `stageBuiltinChange` creates a timestamp branch locally, commits, runs sandbox checks, then fast-forwards back into the original branch. It does not create GitHub PRs, does not attach evidence in-repo, and does not emit machine-readable commit metadata tied to goal/cycle context.

Phase 11 should convert this path into an explicit repository pipeline:
1. derive deterministic branch identity from execution context,
2. commit candidate change with structured metadata,
3. create or update PR in the bound repo,
4. attach sandbox evidence and status context,
5. merge only when gate checks pass.

This keeps existing self-extension behavior (compile + sandbox before promotion) while satisfying the v1.1 requirement that core changes flow through verifiable GitHub controls.

**Primary recommendation:** Replace local `stageBuiltinChange` fast-forward merge flow with a remote PR pipeline service that uses trusted repo binding + structured commit metadata + status-gated merge.

---

## Standard Stack

### Core

| Library/Capability | Version | Purpose | Why Standard |
|--------------------|---------|---------|--------------|
| GitHub REST Git Database endpoints (`git/refs`, `git/trees`, `git/commits`) | REST API version `2022-11-28` | Create branch + commit objects from trusted default branch | Canonical API path for deterministic branch/commit orchestration without local shell git coupling. |
| GitHub REST Pull Request endpoints (`pulls`) | REST API version `2022-11-28` | PR create/update/list/merge lifecycle | Required API surface for SEXT-07 and SEXT-08. |
| GitHub REST Commit Status endpoints (`statuses`) | REST API version `2022-11-28` | Attach sandbox gate result to commit SHA | Works with OAuth-based repo integrations and maps naturally to merge gates. |
| Existing `tool_write` + sandbox pipeline (`compileTypeScript`, `runInSandbox`) | in-repo | Candidate change validation before promotion | Existing behavior should become the evidence producer for PR status. |
| Existing trust model (`setup_state`, encrypted credentials) | in-repo | Resolve repo and OAuth token safely | Already enforced by `assertGitHubTrustForBuiltinModify`; avoid trust-model duplication. |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Native `fetch` + shared GitHub helpers | Node runtime | Authenticated GitHub REST calls in tools package | Preferred to match current codebase style and minimize dependency churn. |
| `simple-git` | `^3.31.1` (already installed) | Fallback local diff/patch operations | Keep only where local working-tree manipulation is unavoidable; do not use as source-of-truth promotion path. |
| `@octokit/rest` | current ecosystem | Typed GitHub client alternative | Optional if endpoint typing/retry ergonomics become a bottleneck during implementation. |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Git Database API (`refs` + `tree` + `commit`) | Contents API (`PUT /repos/{owner}/{repo}/contents/{path}`) | Contents API is simpler for single-file edits but less flexible for multi-file atomic commits. |
| Commit status contexts | Checks API | Checks often imply GitHub App-centric flows; status contexts are simpler for OAuth-based integration today. |
| Deterministic branch id from execution context | Timestamp-only branch names | Timestamps are unique but not deterministic/replay-safe and do not encode traceability identity. |
| Local branch fast-forward merge | PR merge via GitHub API | Local merge bypasses auditable PR workflow and cannot satisfy SEXT-07/08. |

**Installation (only if choosing Octokit):**
```bash
pnpm add @octokit/rest --filter @jarvis/tools
```

---

## Architecture Patterns

### Recommended Project Structure

```
packages/tools/src/self-extension/
├── github-pipeline.ts          # Branch + commit + PR + merge orchestration
├── github-pipeline-types.ts    # Change metadata and evidence schemas
├── github-token-resolver.ts    # Reuse encrypted credential lookup from trust model
├── staging-deployer.ts         # Retain as compatibility wrapper or replace
└── tool-writer.ts              # Calls pipeline for builtinModify path

packages/tools/src/
├── invoke.ts                   # Add optional execution context propagation
└── invoke-safe.ts

apps/agent/src/loop/agent-loop.ts
└── Pass goal/cycle/sub-goal context into tool invocation path

packages/db/src/schema/
└── (optional) self-extension run/event tables for durable pipeline traceability
```

### Pattern 1: Execution Context Propagation for Metadata (SEXT-06)

**What:** carry `goalId`, `cycleId`, `subGoalId`, and invoking `toolName` from agent loop into self-extension pipeline execution.

**Why:** `tool_write` currently receives only user-declared input; it cannot reliably infer goal/cycle metadata from existing arguments.

**How:**
1. Extend invocation path (`AgentLoop` -> `invokeWithKillCheck` -> `invokeWithLogging`) with optional internal execution context.
2. Keep tool input schema stable for the LLM; inject metadata out-of-band as internal execution envelope.
3. Build commit metadata payload from this envelope and persist it in commit message trailers or a compact JSON footer.

**Machine-readable commit metadata shape (recommended):**
```json
{
  "goalId": 42,
  "cycleId": 903,
  "subGoalId": 1881,
  "toolName": "tool_write",
  "changeKind": "builtin_modify",
  "timestamp": "2026-02-19T23:00:00.000Z"
}
```

### Pattern 2: Deterministic Short-Lived Branch Creation (SEXT-05)

**What:** branch names derive from execution identity, not wall-clock randomness.

**Recommended formula:**
- `agent/sext/g{goalId}-c{cycleId}-sg{subGoalId}-{sha8}`
- `sha8` is a stable short hash of `{toolName}:{filePath}:{normalizedContentHash}`.

**Flow:**
1. Read trusted repo binding and default branch from `setup_state`.
2. Resolve default branch head SHA via Git refs/repo APIs.
3. Create branch if absent; if existing, verify it belongs to same deterministic change identity and is still open.
4. Keep branch short-lived: close PR + delete branch after merge/final failure.

### Pattern 3: Commit and PR Upsert as One Pipeline Unit (SEXT-06, SEXT-07)

**What:** each builtin change attempt creates/updates one PR tied to deterministic branch identity.

**Flow:**
1. Run compile + sandbox locally first (existing code path).
2. On pass, create commit in repo branch with metadata trailers/body block.
3. Upsert PR:
   - query open PRs for `head=<owner>:<branch>`,
   - create if none,
   - update title/body if existing.
4. Attach evidence:
   - condensed sandbox summary in PR body/comment,
   - commit status context set to `success` or `failure`.

### Pattern 4: Promotion Gate Before Merge (SEXT-08)

**What:** merge operation is explicitly blocked until required checks pass.

**Flow:**
1. Evaluate required contexts for candidate SHA (at minimum `jarvis/sandbox`).
2. If any required context is `failure`, `error`, or `pending`, return fail-closed result (no merge).
3. Merge with SHA lock to prevent stale-head merge races.
4. Delete branch only after successful merge and PR close state confirmed.

**Fail-closed principle:** inability to confirm status must block merge.

### Anti-Patterns to Avoid

- Timestamp-only branch names (`Date.now`) with no deterministic identity mapping.
- Local fast-forward merge into runtime branch without creating PR in bound GitHub repo.
- Commit messages with no machine-readable metadata block.
- Creating a new PR on every retry instead of idempotent PR upsert by branch head.
- Posting full raw sandbox logs to PR comments without secret redaction.
- Treating `sandbox passed once` as sufficient when head SHA has changed.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Branch/commit object wiring | Custom git wire protocol implementation | GitHub REST Git endpoints (`refs`, `trees`, `commits`) | Lower protocol risk and easier auditing. |
| PR deduping | Ad hoc local file markers | `list pulls` filtered by `head` branch | Native idempotency by branch identity. |
| Merge gating | Local boolean flags only | Commit status contexts + merge-time SHA check | Aligns gate state with repository truth. |
| Metadata parsing | Unstructured free-form commit text | Commit trailers/JSON metadata envelope | Reliable downstream parsing and analytics. |

**Key insight:** this phase is primarily about auditability and deterministic control surfaces, not just "making git commands work."

---

## Common Pitfalls

### Pitfall 1: Contextless commits
**What goes wrong:** commits contain code changes but no stable link to goal/cycle/tool invocation.
**Why it happens:** tool execution path currently lacks internal execution context propagation.
**How to avoid:** add explicit execution envelope and enforce required metadata before commit creation.
**Warning signs:** commit message parsing cannot recover goal or cycle identity.

### Pitfall 2: Branch drift from default branch
**What goes wrong:** change branches are created from stale or non-default refs, causing noisy rebases and invalid diffs.
**Why it happens:** reusing current local branch head instead of trusted repo default branch head.
**How to avoid:** always resolve base SHA from bound repository default branch before branch creation.
**Warning signs:** PR diff includes unrelated commits or unexpectedly large file deltas.

### Pitfall 3: PR spam and orphan branches
**What goes wrong:** retries create many open PRs and abandoned branches for same logical change.
**Why it happens:** branch identity is non-deterministic and PR creation is always "new".
**How to avoid:** deterministic branch naming + PR upsert policy + cleanup on terminal states.
**Warning signs:** multiple open PRs with similar titles and overlapping changes.

### Pitfall 4: False-positive merge readiness
**What goes wrong:** merge happens despite failing/pending sandbox checks.
**Why it happens:** gate checks rely on local flags rather than repository status contexts.
**How to avoid:** evaluate statuses for target SHA at merge time and fail closed on non-success.
**Warning signs:** merged PR where latest commit has pending/failure status.

### Pitfall 5: Secret leakage in evidence
**What goes wrong:** PR comments include tokens, credentials, or sensitive command output.
**Why it happens:** raw sandbox output is posted without structured redaction.
**How to avoid:** sanitize evidence payload and store full raw diagnostics only in protected internal logs.
**Warning signs:** grep on PR comments reveals secret-like patterns.

---

## Code Examples

### Deterministic Branch Name

```typescript
import { createHash } from 'node:crypto';

export function buildPipelineBranch(input: {
  goalId: number;
  cycleId: number;
  subGoalId: number;
  toolName: string;
  filePath: string;
  newContent: string;
}): string {
  const fingerprint = createHash('sha256')
    .update(`${input.toolName}:${input.filePath}:${input.newContent}`)
    .digest('hex')
    .slice(0, 8);

  return `agent/sext/g${input.goalId}-c${input.cycleId}-sg${input.subGoalId}-${fingerprint}`;
}
```

### Commit Metadata Trailer Block

```text
agent: modify builtin tool shell

Jarvis-Meta: {"goalId":42,"cycleId":903,"subGoalId":1881,"toolName":"tool_write","changeKind":"builtin_modify"}
```

### Merge Guard Check (shape)

```typescript
function canPromote(statuses: Array<{ context: string; state: string }>): boolean {
  const required = ['jarvis/sandbox'];
  return required.every((ctx) => statuses.some((s) => s.context === ctx && s.state === 'success'));
}
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Local-only branch + commit + fast-forward merge | Repository-centered branch + PR + merge API flow | v1.1 Phase 11 target | Produces auditable, reviewable promotion history. |
| Timestamp branch identity | Deterministic branch identity from execution context | v1.1 Phase 11 target | Enables idempotent retries and traceability. |
| Unstructured commit text | Machine-readable metadata trailers/JSON | v1.1 Phase 11 target | Supports downstream analytics and incident forensics. |
| Local pass/fail gating only | Status-context-based merge gate on target SHA | v1.1 Phase 11 target | Prevents stale or failed candidate promotion. |

**Deprecated/outdated for this domain:**
- "merge immediately after local sandbox pass" without PR/state checks in the bound GitHub repository.

---

## Open Questions

1. **Promotion policy owner**
   - What we know: SEXT-08 requires failed checks to block merge.
   - What's unclear: whether merge should be automatic on green or require operator trigger.
   - Recommendation: implement auto-merge with kill-switch-aware config flag so operator can pause promotion later (Phase 13 alignment).

2. **Evidence persistence boundary**
   - What we know: PR must include sandbox evidence/status.
   - What's unclear: how much raw output belongs in PR versus internal logs.
   - Recommendation: keep PR evidence concise/structured and preserve full diagnostics in internal append-only logs.

3. **OAuth vs GitHub App for richer checks**
   - What we know: current trust flow is OAuth app token.
   - What's unclear: whether advanced Checks API usage will require GitHub App migration in later phases.
   - Recommendation: design status abstraction now so backend can switch status provider without changing tool-write semantics.

4. **Single PR per change vs per tool session**
   - What we know: deterministic branch identity enables PR upsert.
   - What's unclear: whether retries should amend same PR or always create new branch.
   - Recommendation: default to one open PR per deterministic change identity; create new identity only when candidate content materially changes.

---

## Sources

### Primary (HIGH confidence)
- Codebase:
  - `packages/tools/src/self-extension/staging-deployer.ts`
  - `packages/tools/src/self-extension/tool-writer.ts`
  - `packages/tools/src/self-extension/github-trust-guard.ts`
  - `packages/tools/src/invoke.ts`
  - `apps/agent/src/loop/agent-loop.ts`
  - `apps/dashboard/src/routes/github-oauth-helpers.ts`
  - `apps/dashboard/src/routes/setup.ts`
  - `packages/db/src/schema/setup-state.ts`
  - `packages/db/src/schema/tool-calls.ts`
  - `packages/db/src/schema/planning-cycles.ts`
- GitHub official REST docs:
  - https://docs.github.com/en/rest/repos/repos#get-a-repository
  - https://docs.github.com/en/rest/git/refs#get-a-reference
  - https://docs.github.com/en/rest/git/refs#create-a-reference
  - https://docs.github.com/en/rest/git/refs#update-a-reference
  - https://docs.github.com/en/rest/git/trees#create-a-tree
  - https://docs.github.com/en/rest/git/commits#create-a-commit
  - https://docs.github.com/en/rest/pulls/pulls#list-pull-requests
  - https://docs.github.com/en/rest/pulls/pulls#create-a-pull-request
  - https://docs.github.com/en/rest/pulls/pulls#update-a-pull-request
  - https://docs.github.com/en/rest/pulls/pulls#merge-a-pull-request
  - https://docs.github.com/en/rest/commits/statuses#create-a-commit-status
  - https://docs.github.com/en/rest/commits/statuses#get-the-combined-status-for-a-specific-reference

### Secondary (MEDIUM confidence)
- GitHub Contents API (alternative path):
  - https://docs.github.com/en/rest/repos/contents#create-or-update-file-contents

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH (current code + official endpoints align with requirements)
- Architecture patterns: HIGH-MEDIUM (technical design clear; some product policy choices pending)
- Pitfalls: HIGH (directly observed from current local staging flow and required transitions)

**Research date:** 2026-02-19
**Valid until:** 2026-03-21 (re-check GitHub endpoint constraints/scopes before implementation)
