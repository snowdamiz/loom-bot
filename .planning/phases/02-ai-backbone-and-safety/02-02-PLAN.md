---
phase: 02-ai-backbone-and-safety
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/cli/package.json
  - apps/cli/tsconfig.json
  - apps/cli/src/index.ts
  - apps/cli/src/commands/kill.ts
  - apps/cli/src/commands/resume.ts
  - packages/ai/src/kill-switch.ts
  - packages/tools/src/invoke-safe.ts
  - packages/tools/src/index.ts
  - apps/agent/src/index.ts
  - apps/agent/src/worker.ts
  - apps/agent/package.json
autonomous: true
requirements: [KILL-01, KILL-03, TOOL-06]

must_haves:
  truths:
    - "Operator can run 'jarvis kill <reason>' from CLI and the kill switch is activated in the database"
    - "Operator can run 'jarvis resume <reason>' from CLI and the kill switch is deactivated"
    - "Every kill switch activation/deactivation is recorded in kill_switch_audit with reason and triggeredBy"
    - "Every tool call is checked against the kill switch before execution -- blocked if active"
    - "Agent process wires KillSwitchGuard and ModelRouter at startup"
  artifacts:
    - path: "apps/cli/src/index.ts"
      provides: "Commander-based CLI entry point"
      contains: "commander"
    - path: "apps/cli/src/commands/kill.ts"
      provides: "jarvis kill command that activates kill switch"
      contains: "kill_switch"
    - path: "apps/cli/src/commands/resume.ts"
      provides: "jarvis resume command that deactivates kill switch"
      contains: "kill_switch"
    - path: "packages/tools/src/invoke-safe.ts"
      provides: "invokeWithKillCheck wrapper gating tool calls with kill switch"
      contains: "assertActive"
    - path: "apps/agent/src/index.ts"
      provides: "Agent startup wiring KillSwitchGuard and ModelRouter"
      contains: "KillSwitchGuard"
    - path: "apps/agent/src/worker.ts"
      provides: "BullMQ worker using invokeWithKillCheck instead of invokeWithLogging"
      contains: "invokeWithKillCheck"
  key_links:
    - from: "apps/cli/src/commands/kill.ts"
      to: "packages/db/src/schema/agent-state.ts"
      via: "upsert agent_state where key='kill_switch' with active=true"
      pattern: "kill_switch.*active.*true"
    - from: "apps/cli/src/commands/kill.ts"
      to: "packages/db/src/schema/kill-switch-audit.ts"
      via: "insert into killSwitchAudit with action='activate'"
      pattern: "killSwitchAudit.*activate"
    - from: "apps/cli/src/commands/resume.ts"
      to: "packages/db/src/schema/kill-switch-audit.ts"
      via: "insert into killSwitchAudit with action='deactivate'"
      pattern: "killSwitchAudit.*deactivate"
    - from: "packages/tools/src/invoke-safe.ts"
      to: "packages/ai/src/kill-switch.ts"
      via: "guard.assertActive() before invokeWithLogging"
      pattern: "assertActive.*invokeWithLogging"
    - from: "apps/agent/src/worker.ts"
      to: "packages/tools/src/invoke-safe.ts"
      via: "worker calls invokeWithKillCheck instead of invokeWithLogging"
      pattern: "invokeWithKillCheck"
    - from: "apps/agent/src/index.ts"
      to: "packages/ai/src/index.ts"
      via: "import createRouter, KillSwitchGuard from @jarvis/ai"
      pattern: "@jarvis/ai"
---

<objective>
Build the kill switch enforcement system: CLI commands for operator control, tool execution gating, and agent process integration. After this plan, an operator can halt the agent from the terminal and all tool calls are blocked when the kill switch is active.

Purpose: Safety is non-negotiable -- the kill switch must be wired into every tool call and AI call path before the agent gains any autonomous capability. The CLI provides immediate operator control before the dashboard exists (Phase 5).

Output: `apps/cli` binary with kill/resume commands, `invokeWithKillCheck` wrapper in @jarvis/tools, agent process wired with KillSwitchGuard and ModelRouter, worker process updated to use kill-switch-gated invocation.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ai-backbone-and-safety/02-CONTEXT.md
@.planning/phases/02-ai-backbone-and-safety/02-RESEARCH.md
@.planning/phases/02-ai-backbone-and-safety/02-01-SUMMARY.md
@packages/db/src/schema/agent-state.ts
@packages/db/src/schema/kill-switch-audit.ts
@packages/ai/src/kill-switch.ts
@packages/ai/src/index.ts
@packages/tools/src/invoke.ts
@packages/tools/src/index.ts
@apps/agent/src/index.ts
@apps/agent/src/worker.ts
@apps/agent/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create apps/cli with kill and resume commands</name>
  <files>
    apps/cli/package.json
    apps/cli/tsconfig.json
    apps/cli/src/index.ts
    apps/cli/src/commands/kill.ts
    apps/cli/src/commands/resume.ts
  </files>
  <action>
    Create `apps/cli` as a new app in the monorepo (it is a deployable binary, not a shared library -- hence `apps/` not `packages/`).

    **package.json**: name "@jarvis/cli", version "0.0.1", type "module", private true, bin: { "jarvis": "dist/index.js" }. Dependencies: @jarvis/db (workspace:*), commander (^12.x), dotenv (^16.4.7). DevDependencies: @jarvis/typescript-config (workspace:*), tsx (^4.19.3), typescript (^5.7.3). Scripts: build (tsc), dev (tsx src/index.ts).

    **tsconfig.json**: Extends @jarvis/typescript-config/base.json. compilerOptions: outDir "dist", rootDir "src". Include ["src"].

    **src/index.ts**: Entry point. Import 'dotenv/config'. Import Command from 'commander'. Import killCommand and resumeCommand. Create program with .name('jarvis'), .description('Jarvis agent control CLI'), .version('0.1.0'). Add killCommand and resumeCommand via program.addCommand(). Call program.parseAsync(process.argv). Add shebang `#!/usr/bin/env node` at the top of the file.

    **src/commands/kill.ts** (KILL-01):
    - Import Command from 'commander'.
    - Import db, agentState, killSwitchAudit, eq from '@jarvis/db'.
    - Export const killCommand = new Command('kill').
    - .argument('<reason>', 'Reason for activating the kill switch').
    - .description('Activate the kill switch â€” halts all new agent operations').
    - .action(async (reason: string) => { ... }).
    - Inside action:
      1. Upsert agent_state: check if key='kill_switch' exists. If exists, update value to { active: true, reason, activatedAt: new Date().toISOString() }. If not, insert. Use the same upsert pattern as apps/agent/src/index.ts (select + update/insert).
      2. Insert into killSwitchAudit: { action: 'activate', reason, triggeredBy: 'cli' }.
      3. Console.log confirmation with reason.
      4. Shut down the DB pool cleanly: import { shutdown } from '@jarvis/db' (the pool shutdown function) and call it. Then process.exit(0).

    **src/commands/resume.ts** (KILL-01):
    - Same structure as kill.ts but with:
      1. Upsert agent_state key='kill_switch' with { active: false, reason, deactivatedAt: new Date().toISOString() }.
      2. Insert into killSwitchAudit: { action: 'deactivate', reason, triggeredBy: 'cli' }.
      3. Console.log confirmation.
      4. Clean shutdown + exit.

    IMPORTANT: The kill/resume commands connect directly to the database (using @jarvis/db which reads DATABASE_URL from env). They do NOT communicate with the agent process -- they write the flag that the agent reads. This is the correct pattern per user decision (DB flag, not IPC).

    After creating files, run `pnpm install` to link the workspace. Then `pnpm --filter @jarvis/cli run build`.
  </action>
  <verify>
    1. `pnpm --filter @jarvis/cli run build` exits 0
    2. Test kill: `DATABASE_URL=postgres://jarvis:jarvis@localhost:5433/jarvis pnpm --filter @jarvis/cli exec tsx src/index.ts kill "test activation"` -- should print confirmation and exit 0
    3. Verify DB state: `docker exec jarvis-postgres psql -U jarvis -d jarvis -c "SELECT value FROM agent_state WHERE key='kill_switch'"` -- should show `{"active": true, "reason": "test activation", ...}`
    4. Verify audit: `docker exec jarvis-postgres psql -U jarvis -d jarvis -c "SELECT * FROM kill_switch_audit ORDER BY id DESC LIMIT 1"` -- should show action='activate'
    5. Test resume: `DATABASE_URL=postgres://jarvis:jarvis@localhost:5433/jarvis pnpm --filter @jarvis/cli exec tsx src/index.ts resume "test deactivation"` -- should print confirmation
    6. Verify DB state after resume: agent_state kill_switch value.active should be false
  </verify>
  <done>
    `jarvis kill <reason>` and `jarvis resume <reason>` CLI commands work. Kill switch state persists in agent_state table. Every activation/deactivation is audited in kill_switch_audit with reason string and 'cli' as triggeredBy.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add TOOL-06 kill switch gate, update worker, and wire agent startup</name>
  <files>
    packages/ai/src/kill-switch.ts
    packages/tools/src/invoke-safe.ts
    packages/tools/src/index.ts
    apps/agent/src/index.ts
    apps/agent/src/worker.ts
    apps/agent/package.json
  </files>
  <action>
    **Part A: Add activateKillSwitch/deactivateKillSwitch helper functions to packages/ai/src/kill-switch.ts**

    Add two exported async functions to the existing kill-switch.ts file (which already has KillSwitchGuard and KillSwitchActiveError from Plan 01):

    - `activateKillSwitch(db: DbClient, reason: string, triggeredBy: string = 'cli')`: Upserts agent_state key='kill_switch' with { active: true, reason, activatedAt: new Date().toISOString() }. Inserts into killSwitchAudit { action: 'activate', reason, triggeredBy }. These helper functions are used by the CLI (Plan 02 Task 1) and can also be used programmatically.
    - `deactivateKillSwitch(db: DbClient, reason: string, triggeredBy: string = 'cli')`: Same but active=false, action='deactivate'.

    This avoids duplicating the upsert + audit logic in each CLI command. The CLI commands should be updated to call these helpers instead of doing raw DB operations.

    Import killSwitchAudit from @jarvis/db in kill-switch.ts.

    **Part B: Create packages/tools/src/invoke-safe.ts (TOOL-06)**

    Create a new file that wraps invokeWithLogging with a kill switch pre-check:

    ```
    import type { KillSwitchGuard } from '@jarvis/ai';
    ```

    WAIT -- @jarvis/tools cannot depend on @jarvis/ai (circular risk: @jarvis/ai depends on @jarvis/db, @jarvis/tools depends on @jarvis/db). Actually there's no circular dep: @jarvis/tools does not depend on @jarvis/ai currently, and @jarvis/ai does not depend on @jarvis/tools. But adding @jarvis/ai as a dep of @jarvis/tools creates a dependency: tools -> ai -> db. That's fine, no cycle.

    BUT -- it's cleaner to use a duck-typed interface (same pattern as apps/agent's ShutdownPool/ShutdownRedis). The invokeWithKillCheck function only needs `assertActive(): Promise<void>`. So define a local interface:

    ```typescript
    interface KillCheckable {
      assertActive(): Promise<void>;
    }
    ```

    Export function `invokeWithKillCheck(guard: KillCheckable, registry: ToolRegistry, db: DbClient, toolName: string, rawInput: unknown, overrideTimeoutMs?: number): Promise<ToolResult<unknown>>`:
    1. await guard.assertActive() -- throws KillSwitchActiveError if active
    2. return invokeWithLogging(registry, db, toolName, rawInput, overrideTimeoutMs)

    This satisfies TOOL-06: "Every tool call is checked against kill switch before execution."

    **Update packages/tools/src/index.ts**: Add export for invokeWithKillCheck.

    **Part C: Update the BullMQ worker (apps/agent/src/worker.ts) to use invokeWithKillCheck**

    This is CRITICAL for TOOL-06. The worker is where tool calls are actually dispatched via BullMQ jobs. Without this change, all tool calls dispatched through the queue would bypass the kill switch.

    Update apps/agent/src/worker.ts:
    - Change import from `import { createDefaultRegistry, invokeWithLogging } from '@jarvis/tools'` to `import { createDefaultRegistry, invokeWithKillCheck } from '@jarvis/tools'`.
    - Import `{ KillSwitchGuard } from '@jarvis/ai'`.
    - Create a KillSwitchGuard instance at module level (alongside the registry): `const killSwitch = new KillSwitchGuard(db);`
    - Replace the `invokeWithLogging(registry, db, toolName, input, timeoutMs)` call inside the worker processor with `invokeWithKillCheck(killSwitch, registry, db, toolName, input, timeoutMs)`.
    - This ensures every BullMQ tool execution job checks the kill switch before running.

    **Part D: Wire agent startup (apps/agent/src/index.ts)**

    Update apps/agent/package.json to add @jarvis/ai as a dependency (workspace:*).

    Update apps/agent/src/index.ts:
    - Import { createRouter, KillSwitchGuard, loadModelConfig } from '@jarvis/ai'.
    - After creating the tool registry, create the AI router:
      ```
      const killSwitch = new KillSwitchGuard(db);
      const modelConfig = loadModelConfig();
      const router = createRouter(db, process.env.OPENROUTER_API_KEY!);
      ```
      Or if createRouter already does this internally, just call createRouter.
    - Log model config to stderr: `[agent] AI router ready. Models: strong=${modelConfig.strong}, mid=${modelConfig.mid}, cheap=${modelConfig.cheap}`
    - Store the router instance for use by the planning loop (Phase 3). For now, just create it at startup to verify wiring.
    - The KillSwitchGuard is already wired into the ModelRouter by createRouter(). The agent doesn't need to call assertActive() directly -- the router does it automatically on every complete() call.

    Update the existing system:status agent_state write to include `aiRouter: 'ready'` in the status object.
  </action>
  <verify>
    1. `pnpm --filter @jarvis/tools run build` exits 0
    2. `pnpm --filter @jarvis/ai run build` exits 0
    3. `pnpm --filter @jarvis/agent run build` exits 0
    4. Verify worker.ts contains `invokeWithKillCheck` (not `invokeWithLogging`):
       `grep -q 'invokeWithKillCheck' apps/agent/src/worker.ts && echo "PASS" || echo "FAIL"`
    5. Test kill switch blocking: First activate kill switch via CLI (Task 1), then verify that attempting to call invokeWithKillCheck would throw. Can verify by running a small tsx script:
       ```
       DATABASE_URL=... tsx -e "
         import { db } from '@jarvis/db';
         import { KillSwitchGuard } from '@jarvis/ai';
         const guard = new KillSwitchGuard(db);
         guard.assertActive().then(() => console.log('NOT BLOCKED')).catch(e => console.log('BLOCKED:', e.message));
       "
       ```
       Should print "BLOCKED: Kill switch is active."
    6. Then resume via CLI and re-run -- should print "NOT BLOCKED"
  </verify>
  <done>
    invokeWithKillCheck gates every tool call with kill switch check (TOOL-06). The BullMQ worker (apps/agent/src/worker.ts) uses invokeWithKillCheck -- all queued tool executions are gated. activateKillSwitch/deactivateKillSwitch helper functions exist in @jarvis/ai. Agent process creates KillSwitchGuard and ModelRouter at startup. Kill switch enforcement path: CLI -> DB flag -> KillSwitchGuard cache -> assertActive() throw -> blocks AI calls (router) and tool calls (invokeWithKillCheck in worker).
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter @jarvis/cli run build && pnpm --filter @jarvis/tools run build && pnpm --filter @jarvis/agent run build` all exit 0
- `jarvis kill "test"` activates kill switch in DB and creates audit row
- `jarvis resume "test"` deactivates kill switch and creates audit row (with action='deactivate' in kill_switch_audit)
- KillSwitchGuard.assertActive() throws when kill switch is active, succeeds when inactive
- invokeWithKillCheck calls assertActive before delegating to invokeWithLogging
- Worker process (apps/agent/src/worker.ts) uses invokeWithKillCheck, NOT invokeWithLogging
- Agent startup creates KillSwitchGuard and ModelRouter
</verification>

<success_criteria>
- Operator can halt agent via `jarvis kill <reason>` and resume via `jarvis resume <reason>`
- Kill switch state persists in Postgres (survives restarts) -- KILL-04
- Every activation/deactivation recorded in kill_switch_audit -- KILL-01
- All tool calls gated by kill switch via invokeWithKillCheck -- TOOL-06, KILL-03
- BullMQ worker uses invokeWithKillCheck (not invokeWithLogging) for all queued tool jobs
- Agent process wires all Phase 2 components at startup
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-backbone-and-safety/02-02-SUMMARY.md`
</output>
