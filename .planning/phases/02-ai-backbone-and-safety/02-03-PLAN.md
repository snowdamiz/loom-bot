---
phase: 02-ai-backbone-and-safety
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/ai/src/cost-monitor.ts
  - packages/ai/src/discord.ts
  - packages/ai/src/index.ts
  - packages/ai/package.json
  - packages/db/src/schema/pnl-view.ts
  - packages/db/src/schema/index.ts
  - packages/db/drizzle.config.ts
autonomous: true
requirements: [COST-02, COST-03, COST-04, COST-05]

user_setup:
  - service: openrouter
    why: "AI model API calls and credit balance monitoring"
    env_vars:
      - name: OPENROUTER_API_KEY
        source: "OpenRouter Dashboard -> Settings -> API Keys -> Create Key"
  - service: discord
    why: "Low-credit warning DMs to operator"
    env_vars:
      - name: DISCORD_BOT_TOKEN
        source: "Discord Developer Portal -> Applications -> Bot -> Token"
      - name: DISCORD_OPERATOR_USER_ID
        source: "Discord -> User Settings -> Advanced -> Enable Developer Mode, then right-click your profile -> Copy User ID"

must_haves:
  truths:
    - "CreditMonitor polls OpenRouter /api/v1/key to get remaining credit balance"
    - "When credits drop below threshold ($5), Discord DM is sent to operator"
    - "P&L is queryable as a SQL view over operating_costs and revenue tables"
    - "Agent can query its own AI spend from ai_calls to inform planning decisions"
  artifacts:
    - path: "packages/ai/src/cost-monitor.ts"
      provides: "CreditMonitor class with periodic balance polling and low-credit detection"
      contains: "api/v1/key"
    - path: "packages/ai/src/discord.ts"
      provides: "sendOperatorDm function for Discord DM notifications"
      contains: "discord.js"
    - path: "packages/db/src/schema/pnl-view.ts"
      provides: "P&L query functions over operating_costs and revenue"
      exports: ["getPnl", "getOperatingCostTotal", "getRevenueTotal"]
  key_links:
    - from: "packages/ai/src/cost-monitor.ts"
      to: "https://openrouter.ai/api/v1/key"
      via: "fetch with Authorization header"
      pattern: "api/v1/key"
    - from: "packages/ai/src/cost-monitor.ts"
      to: "packages/ai/src/discord.ts"
      via: "sendOperatorDm when credits below threshold"
      pattern: "sendOperatorDm"
    - from: "packages/db/src/schema/pnl-view.ts"
      to: "packages/db/src/schema/operating-costs.ts"
      via: "SUM query over operating_costs.amount_usd"
      pattern: "operatingCosts"
    - from: "packages/db/src/schema/pnl-view.ts"
      to: "packages/db/src/schema/revenue.ts"
      via: "SUM query over revenue.amount_usd"
      pattern: "revenue"
---

<objective>
Build the cost monitoring and P&L system: OpenRouter credit balance polling with low-credit Discord DM alerts, and queryable P&L over operating_costs and revenue tables. After this plan, the agent can monitor its own spending and the operator gets warned when credits run low.

Purpose: The agent must track its own operating costs from the first API call (user decision). Credit balance monitoring prevents the agent from running out of funds without warning. P&L queryability lets the agent make cost-aware planning decisions.

Output: CreditMonitor class, Discord DM utility, P&L query functions, cost aggregation helpers.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ai-backbone-and-safety/02-CONTEXT.md
@.planning/phases/02-ai-backbone-and-safety/02-RESEARCH.md
@.planning/phases/02-ai-backbone-and-safety/02-01-SUMMARY.md
@packages/db/src/schema/operating-costs.ts
@packages/db/src/schema/revenue.ts
@packages/db/src/schema/ai-calls.ts
@packages/ai/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CreditMonitor and Discord DM notification</name>
  <files>
    packages/ai/src/cost-monitor.ts
    packages/ai/src/discord.ts
    packages/ai/src/index.ts
    packages/ai/package.json
  </files>
  <action>
    **Add discord.js to packages/ai/package.json**: Add `discord.js` (^14.x) as a dependency.

    **packages/ai/src/discord.ts** (operator notification):
    - Import { Client, GatewayIntentBits, Partials } from 'discord.js'.
    - Export async function `sendOperatorDm(token: string, operatorUserId: string, message: string): Promise<void>`:
      1. Create Client with intents: [GatewayIntentBits.DirectMessages], partials: [Partials.Channel] -- REQUIRED for DM support in discord.js v14 (see research pitfall 4).
      2. await client.login(token).
      3. Wait for ready: await new Promise<void>(resolve => client.once('ready', () => resolve())).
      4. const user = await client.users.fetch(operatorUserId).
      5. await user.send(message).
      6. await client.destroy() -- clean up the connection.
    - This function creates a short-lived client per message. It is called infrequently (only on low-credit alerts), so the connection setup overhead is acceptable. A persistent client would be wasteful for Phase 2's needs.

    **packages/ai/src/cost-monitor.ts** (COST-02, credit balance polling):
    - Import { sendOperatorDm } from './discord.js'.
    - Import DbClient, operatingCosts from '@jarvis/db'.

    - Export interface `CreditMonitorConfig`:
      - apiKey: string (OPENROUTER_API_KEY)
      - discordBotToken?: string (DISCORD_BOT_TOKEN -- optional, DMs skipped if not set)
      - discordOperatorUserId?: string (DISCORD_OPERATOR_USER_ID -- optional)
      - checkIntervalMs?: number (default: 5 * 60 * 1000 = 5 minutes)
      - lowCreditThresholdUsd?: number (default: 5.00 -- per Claude's Discretion recommendation)

    - Export class `CreditMonitor`:
      - Private fields: config, intervalHandle (ReturnType<typeof setInterval> | null), db, lastWarningAt (number | null -- prevent spam, only warn once per hour)
      - Constructor takes config: CreditMonitorConfig, db: DbClient.

      - async checkBalance(): Promise<{ remaining: number | null; usage: number }>:
        1. Fetch `https://openrouter.ai/api/v1/key` with Authorization: `Bearer ${this.config.apiKey}`.
        2. Parse response as `{ data: { limit_remaining: number | null; usage: number } }`.
        3. Return { remaining: data.data.limit_remaining, usage: data.data.usage }.
        4. NOTE: Use GET /api/v1/key (NOT /api/v1/credits which requires management key -- see research pitfall 2).

      - async recordBalance(): Promise<void>:
        1. Call checkBalance().
        2. If remaining is not null and remaining < threshold:
           a. If lastWarningAt is null or (Date.now() - lastWarningAt > 3600000) (1 hour debounce):
              - Set lastWarningAt = Date.now()
              - If discordBotToken and discordOperatorUserId are set:
                - Call sendOperatorDm with message: `[Jarvis] Low credits warning: $${remaining.toFixed(2)} remaining on OpenRouter. Please top up.`
              - Log to stderr: `[cost-monitor] LOW CREDITS: $${remaining.toFixed(2)} remaining`

      - start(): void -- starts setInterval calling recordBalance(). Also calls recordBalance() immediately (same pattern as memory consolidation in Phase 1).
      - stop(): void -- clearInterval.

    **Update packages/ai/src/index.ts**: Add exports for CreditMonitor, CreditMonitorConfig, sendOperatorDm.

    Run `pnpm install` then `pnpm --filter @jarvis/ai run build`.
  </action>
  <verify>
    1. `pnpm --filter @jarvis/ai run build` exits 0
    2. discord.js is in packages/ai/node_modules (or pnpm store) after install
    3. CreditMonitor, sendOperatorDm exported from @jarvis/ai
  </verify>
  <done>
    CreditMonitor polls OpenRouter /api/v1/key on a configurable interval. Low-credit detection triggers Discord DM with 1-hour debounce. Discord DM utility handles client lifecycle cleanly with Partials.Channel for DM support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create P&L query functions and cost aggregation</name>
  <files>
    packages/db/src/schema/pnl-view.ts
    packages/db/src/schema/index.ts
    packages/db/drizzle.config.ts
  </files>
  <action>
    Create P&L as query functions (not a Postgres VIEW) because drizzle-orm does not manage views in db:push. Use drizzle query builder for type safety.

    **packages/db/src/schema/pnl-view.ts** (COST-04, COST-05):
    - Import { sql } from 'drizzle-orm'.
    - Import type { DbClient } from '../client.js'.
    - Import { operatingCosts } from './operating-costs.js'.
    - Import { revenue } from './revenue.js'.
    - Import { aiCalls } from './ai-calls.js'.

    - Export interface `PnlSummary`:
      - totalCostsUsd: number
      - totalRevenueUsd: number
      - netPnlUsd: number
      - aiInferenceCostUsd: number
      - periodStart: Date | null
      - periodEnd: Date | null

    - Export async function `getPnl(db: DbClient, options?: { since?: Date; until?: Date }): Promise<PnlSummary>`:
      1. Query total costs from operating_costs with optional date range on periodStart/periodEnd.
      2. Query total revenue from revenue with optional date range on earnedAt.
      3. Query AI inference cost subtotal from ai_calls (or from operating_costs where category='ai_inference').
      4. Compute net = revenue - costs.
      5. Return PnlSummary.
      Use `db.select({ total: sql<string>`sum(${operatingCosts.amountUsd})` }).from(operatingCosts)` pattern. Parse numeric sum results from string to number.

    - Export async function `getOperatingCostTotal(db: DbClient, category?: string): Promise<number>`:
      Sum of operating_costs.amountUsd, optionally filtered by category. Returns 0 if no rows.

    - Export async function `getRevenueTotal(db: DbClient, strategyId?: string): Promise<number>`:
      Sum of revenue.amountUsd, optionally filtered by strategyId. Returns 0 if no rows.

    - Export async function `getAiSpendSummary(db: DbClient): Promise<{ totalCostUsd: number; totalCalls: number; byTier: Record<string, { calls: number; costUsd: number }> }>`:
      Aggregate ai_calls table: total cost, total calls, grouped by tier. This is the agent's view into its own AI spending (COST-05). This queries ai_calls directly -- no need to bridge to operating_costs since getAiSpendSummary already provides the per-call AI cost data the agent needs.

    **Update packages/db/src/schema/index.ts**: Add `export * from './pnl-view.js'`.

    NOTE: Do NOT add pnl-view.ts to drizzle.config.ts schema array -- it contains only query functions, not table definitions. drizzle-kit only needs table/enum definitions.

    Run `pnpm --filter @jarvis/db run build`.

    IMPORTANT: These query functions use `sql` template literals from drizzle-orm. Since this file is inside @jarvis/db itself, it CAN import directly from 'drizzle-orm' (unlike downstream packages). Import sql from 'drizzle-orm' here, NOT from the barrel -- the barrel is what we're building.
  </action>
  <verify>
    1. `pnpm --filter @jarvis/db run build` exits 0
    2. getPnl, getOperatingCostTotal, getRevenueTotal, getAiSpendSummary are exported from @jarvis/db
    3. Test P&L query returns zeros on empty tables:
       ```
       DATABASE_URL=postgres://jarvis:jarvis@localhost:5433/jarvis tsx -e "
         import { db, getPnl } from '@jarvis/db';
         const pnl = await getPnl(db);
         console.log(JSON.stringify(pnl));
         process.exit(0);
       "
       ```
       Should print `{"totalCostsUsd":0,"totalRevenueUsd":0,"netPnlUsd":0,"aiInferenceCostUsd":0,...}`
  </verify>
  <done>
    P&L queryable via getPnl() (COST-04). Agent can query AI spend via getAiSpendSummary() (COST-05). Revenue table ready for population in later phases (COST-03 schema-only). Operating costs aggregatable by category (COST-02). All query functions return type-safe results with number (not string) amounts.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter @jarvis/ai run build && pnpm --filter @jarvis/db run build` both exit 0
- CreditMonitor.checkBalance() compiles (runtime test requires OPENROUTER_API_KEY)
- sendOperatorDm() compiles (runtime test requires DISCORD_BOT_TOKEN)
- getPnl(db) returns PnlSummary with zeroed amounts on empty tables
- getAiSpendSummary(db) returns empty summary on fresh database
</verification>

<success_criteria>
- CreditMonitor polls /api/v1/key (correct endpoint, not /api/v1/credits) -- COST-02
- Low-credit alert sends Discord DM to operator with remaining balance
- Revenue table exists and is queryable (COST-03 schema-only for Phase 2)
- P&L computed as revenue minus costs, queryable by agent (COST-04, COST-05)
- AI spend breakdown available by tier via getAiSpendSummary (queries ai_calls directly)
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-backbone-and-safety/02-03-SUMMARY.md`
</output>
