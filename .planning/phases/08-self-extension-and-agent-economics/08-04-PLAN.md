---
phase: 08-self-extension-and-agent-economics
plan: 04
type: execute
wave: 3
depends_on:
  - "08-01"
  - "08-02"
  - "08-03"
files_modified:
  - apps/agent/src/index.ts
  - apps/agent/src/worker.ts
  - apps/agent/src/shutdown.ts
autonomous: true
requirements:
  - EXTEND-03
  - EXTEND-05

must_haves:
  truths:
    - "Agent process loads persisted tools from agent-tools/ directory on startup before the supervisor loop begins"
    - "All 3 self-extension tools (tool_write, tool_delete, schema_extend) are registered in the agent tool registry"
    - "LLM sees self-extension tools in its available tool list (openAITools re-derived after registration)"
    - "Worker process loads persisted tools from agent-tools/ on startup"
    - "When agent creates a new tool, the worker process reloads tools from disk via reload-tools BullMQ job"
    - "Graceful shutdown is clean — no new Phase 8 shutdown resources needed (tools are in-memory, no process to kill)"
  artifacts:
    - path: "apps/agent/src/index.ts"
      provides: "Phase 8 bootstrap block: loadPersistedTools + self-extension tool registration + reload-tools queue"
      contains: "createSelfExtensionTools"
    - path: "apps/agent/src/worker.ts"
      provides: "Worker loads persisted tools on startup + handles reload-tools job"
      contains: "loadPersistedTools"
  key_links:
    - from: "apps/agent/src/index.ts"
      to: "packages/tools/src/self-extension/tool-loader.ts"
      via: "loadPersistedTools(registry) at startup"
      pattern: "loadPersistedTools"
    - from: "apps/agent/src/index.ts"
      to: "packages/tools/src/self-extension/index.ts"
      via: "createSelfExtensionTools(registry) registration"
      pattern: "createSelfExtensionTools"
    - from: "apps/agent/src/worker.ts"
      to: "packages/tools/src/self-extension/tool-loader.ts"
      via: "loadPersistedTools(registry) at worker startup + on reload-tools job"
      pattern: "loadPersistedTools"
---

<objective>
Wire Phase 8 self-extension into the agent process and worker process. Load persisted agent-authored tools on startup (both processes), register self-extension tools, and implement worker reload-tools synchronization so newly created tools are available to both the agent loop and the BullMQ worker.

Purpose: The final wiring plan that makes self-extension operational. Without this, the tools exist in @jarvis/tools but are not registered or accessible to the agent. The worker sync ensures tools created by the agent loop are available for BullMQ job execution too.
Output: Updated agent entry point and worker with Phase 8 bootstrap, worker tool reload mechanism.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-self-extension-and-agent-economics/08-RESEARCH.md
@.planning/phases/08-self-extension-and-agent-economics/08-CONTEXT.md
@.planning/phases/08-self-extension-and-agent-economics/08-01-SUMMARY.md
@.planning/phases/08-self-extension-and-agent-economics/08-03-SUMMARY.md
@apps/agent/src/index.ts
@apps/agent/src/worker.ts
@apps/agent/src/shutdown.ts
@packages/tools/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Agent process Phase 8 bootstrap</name>
  <files>
    apps/agent/src/index.ts
  </files>
  <action>
Update `apps/agent/src/index.ts` to add Phase 8 self-extension bootstrap. Changes below — add after the Phase 6 block (after `createBootstrapTools` registration) and BEFORE the shutdown handler registration and recovery:

1. Add imports at the top of the file:
   ```typescript
   import { createSelfExtensionTools, loadPersistedTools } from '@jarvis/tools';
   ```

2. Add Phase 8 bootstrap block after Phase 6 bootstrap and before `registerShutdownHandlers`:

   ```typescript
   // === Phase 8: Self-Extension ===

   // Load agent-authored tools from disk (persisted from previous runs)
   const loadResult = await loadPersistedTools(registry);
   if (loadResult.loaded.length > 0) {
     process.stderr.write(
       `[agent] Loaded ${loadResult.loaded.length} persisted tool(s): ${loadResult.loaded.join(', ')}\n`,
     );
   }
   if (loadResult.failed.length > 0) {
     process.stderr.write(
       `[agent] Failed to load ${loadResult.failed.length} persisted tool(s): ${loadResult.failed.join(', ')}\n`,
     );
   }

   // Register self-extension tools (3 tools: tool_write, tool_delete, schema_extend)
   const selfExtensionTools = createSelfExtensionTools(registry);
   selfExtensionTools.forEach((t) => registry.register(t));

   // Re-derive openAITools after Phase 8 registration so the LLM sees all tools
   openAITools = toolDefinitionsToOpenAI(registry);

   process.stderr.write(
     `[agent] Phase 8 ready. Self-extension: ${selfExtensionTools.length} tools. ` +
       `Persisted: ${loadResult.loaded.length} loaded, ${loadResult.failed.length} failed. ` +
       `Total: ${registry.count()}\n`,
   );
   ```

3. IMPORTANT: The `openAITools` reassignment must happen AFTER Phase 8 registration. The variable is already `let` (reassigned after Phase 4 wallet tools and Phase 6). Just add another reassignment after Phase 8 registration.

4. The shutdown handler does NOT need Phase 8 updates — self-extension tools are in-memory only (no child process, no subscription to clean up). The agent-tools/ directory and registry are cleaned up by the existing process exit.

5. Move the existing Phase 4 log line `process.stderr.write('[agent] Phase 4 ready...')` to the end, or update it to reflect Phase 8:
   Change: `process.stderr.write(\`[agent] Phase 4 ready. Tools: ${registry.count()}. Goals: supervisor managed.\n\`);`
   To: `process.stderr.write(\`[agent] All phases ready. Tools: ${registry.count()}. Goals: supervisor managed.\n\`);`
  </action>
  <verify>
    - `pnpm build --filter @jarvis/agent` succeeds (or whatever the agent package build command is — check with `pnpm build --filter agent` or build from apps/agent)
    - grep for 'createSelfExtensionTools' in apps/agent/src/index.ts
    - grep for 'loadPersistedTools' in apps/agent/src/index.ts
  </verify>
  <done>Agent process loads persisted tools on startup, registers 3 self-extension tools, and re-derives openAITools for LLM visibility. Agent is fully self-extensible.</done>
</task>

<task type="auto">
  <name>Task 2: Worker process tool loading and reload-tools sync</name>
  <files>
    apps/agent/src/worker.ts
  </files>
  <action>
Update `apps/agent/src/worker.ts` to load persisted agent-authored tools on startup and handle reload-tools synchronization jobs.

The worker currently has a separate ToolRegistry (`createDefaultRegistry(db)` at line 38). Agent-authored tools created by the agent loop process are NOT visible to the worker — they are separate Node.js processes with separate in-memory registries. This task fixes that.

1. Add import at the top:
   ```typescript
   import { createDefaultRegistry, invokeWithKillCheck, loadPersistedTools } from '@jarvis/tools';
   ```

2. After `const registry = createDefaultRegistry(db);` (line 38), add:
   ```typescript
   // Load agent-authored tools persisted from previous runs (Phase 8)
   // This ensures the worker can execute agent-created tools after restart.
   loadPersistedTools(registry).then((result) => {
     if (result.loaded.length > 0) {
       process.stderr.write(
         `[worker] Loaded ${result.loaded.length} persisted tool(s): ${result.loaded.join(', ')}\n`,
       );
     }
     if (result.failed.length > 0) {
       process.stderr.write(
         `[worker] Failed to load ${result.failed.length} persisted tool(s): ${result.failed.join(', ')}\n`,
       );
     }
   }).catch((err) => {
     process.stderr.write(`[worker] Error loading persisted tools: ${err instanceof Error ? err.message : String(err)}\n`);
   });
   ```

   Note: Using `.then()` instead of await because the worker module is top-level and currently uses synchronous-style setup (no async IIFE wrapper). The loadPersistedTools call is non-blocking — the worker can start accepting jobs immediately while tools load in parallel.

3. Add a SECOND worker for the 'reload-tools' queue. This is a lightweight worker that just re-runs loadPersistedTools when the agent loop creates a new tool:

   ```typescript
   // Phase 8: Worker that reloads agent-authored tools from disk when notified.
   // The agent loop enqueues a 'reload-tools' job after creating/deleting a tool.
   // This ensures the tool-execution worker's registry stays in sync.
   const reloadWorker = new Worker(
     'reload-tools',
     async () => {
       const result = await loadPersistedTools(registry);
       process.stderr.write(
         `[worker] Reloaded tools: ${result.loaded.length} loaded, ${result.failed.length} failed\n`,
       );
       return result;
     },
     {
       connection: {
         url: process.env.REDIS_URL!,
       },
       concurrency: 1,
       removeOnComplete: { age: 60 }, // Short TTL — reload jobs are transient
     },
   );

   reloadWorker.on('error', (err) => {
     process.stderr.write(`[worker] Reload worker error: ${err.message}\n`);
   });
   ```

4. Now we need the agent loop to ENQUEUE reload-tools jobs when tool_write or tool_delete succeeds. This is best done by updating the tool_write and tool_delete execute() functions in tool-writer.ts.

   BUT WAIT — tool_write and tool_delete are in @jarvis/tools, not in apps/agent. They don't have access to the BullMQ queue. The solution: the createToolWriteTool and createToolDeleteTool factories need to accept an optional `onToolChange?: () => void` callback. The agent process passes a callback that enqueues a reload-tools job.

   Update `packages/tools/src/self-extension/tool-writer.ts`:
   - Change `createToolWriteTool(registry: ToolRegistry)` to `createToolWriteTool(registry: ToolRegistry, onToolChange?: () => void)`
   - At the end of a successful tool_write (after register), call `onToolChange?.()` — fire-and-forget
   - Change `createToolDeleteTool(registry: ToolRegistry)` to `createToolDeleteTool(registry: ToolRegistry, onToolChange?: () => void)`
   - At the end of a successful tool_delete (after unregister), call `onToolChange?.()` — fire-and-forget

   Update `packages/tools/src/self-extension/index.ts`:
   - Change `createSelfExtensionTools(registry: ToolRegistry)` to `createSelfExtensionTools(registry: ToolRegistry, onToolChange?: () => void)`
   - Pass onToolChange through to createToolWriteTool and createToolDeleteTool

   Update `packages/tools/src/index.ts` export if needed (the factory signature change is backward-compatible since onToolChange is optional).

5. Back in `apps/agent/src/index.ts`, update the Phase 8 block:
   ```typescript
   // Create reload-tools queue for worker synchronization (Phase 8)
   const reloadToolsQueue = new Queue('reload-tools', {
     connection: { url: process.env.REDIS_URL! },
   });

   const onToolChange = () => {
     reloadToolsQueue.add('reload', {}).catch((err) => {
       process.stderr.write(`[agent] Failed to enqueue reload-tools job: ${err instanceof Error ? err.message : String(err)}\n`);
     });
   };

   // Register self-extension tools with reload callback
   const selfExtensionTools = createSelfExtensionTools(registry, onToolChange);
   ```

6. Add `reloadToolsQueue` to shutdown resources in registerShutdownHandlers. Update the ShutdownResources interface and gracefulShutdown function in shutdown.ts:
   - No new interface needed — reloadToolsQueue satisfies the existing `{ close(): Promise<void> }` pattern
   - But we need a field for it. Add to ShutdownResources:
     ```typescript
     /** Phase 8: BullMQ queue for reload-tools dispatch */
     reloadToolsQueue?: { close(): Promise<void> };
     ```
   - In gracefulShutdown, close it after agentTasksQueue:
     ```typescript
     if (reloadToolsQueue !== undefined) {
       await reloadToolsQueue.close();
       process.stderr.write('[shutdown] Reload-tools queue closed.\n');
     }
     ```
   - Pass it from index.ts: `reloadToolsQueue` in the registerShutdownHandlers call

7. Build all: `pnpm build --filter @jarvis/tools && pnpm build` (tools first since agent depends on it)
  </action>
  <verify>
    - `pnpm build` succeeds across entire workspace
    - grep for 'loadPersistedTools' in apps/agent/src/worker.ts
    - grep for 'reload-tools' in apps/agent/src/worker.ts
    - grep for 'reloadToolsQueue' in apps/agent/src/index.ts
    - grep for 'onToolChange' in packages/tools/src/self-extension/tool-writer.ts
  </verify>
  <done>Worker loads persisted tools on startup and reloads when agent creates/deletes tools via BullMQ reload-tools job. Agent process enqueues reload-tools on tool_write/tool_delete success. Shutdown handles cleanup of the reload-tools queue. Both processes have synchronized tool registries.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds across entire workspace
- Agent process: loads persisted tools, registers 3 self-extension tools, re-derives openAITools
- Worker process: loads persisted tools at startup, reloads on reload-tools BullMQ job
- tool_write/tool_delete trigger reload-tools job via onToolChange callback
- Shutdown cleans up reload-tools queue
- No orphaned resources on SIGTERM/SIGINT
</verification>

<success_criteria>
The agent is fully self-extensible end-to-end: it can write a TypeScript tool that is compiled, sandbox-tested, persisted to disk, registered in the agent loop, and synchronized to the worker process. The schema_extend tool can create and modify database tables. Built-in tools are safely modifiable via git branch staging. All capabilities survive process restarts.
</success_criteria>

<output>
After completion, create `.planning/phases/08-self-extension-and-agent-economics/08-04-SUMMARY.md`
</output>
