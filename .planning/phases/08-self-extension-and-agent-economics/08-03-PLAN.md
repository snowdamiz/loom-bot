---
phase: 08-self-extension-and-agent-economics
plan: 03
type: execute
wave: 3
depends_on:
  - "08-01"
  - "08-02"
files_modified:
  - packages/tools/src/self-extension/tool-writer.ts
  - packages/tools/src/self-extension/staging-deployer.ts
  - packages/tools/src/self-extension/index.ts
  - packages/tools/src/index.ts
autonomous: true
requirements:
  - EXTEND-01
  - EXTEND-02
  - EXTEND-03
  - EXTEND-05
  - AGENT-01
  - AGENT-02
  - AGENT-03
  - AGENT-04

must_haves:
  truths:
    - "Agent provides TypeScript source and the tool_write tool compiles it, sandbox tests it, persists it to disk, and registers it in one operation"
    - "A tool that fails sandbox tests is NOT persisted to disk and NOT registered — the agent receives the error"
    - "Agent can delete a tool it previously created via tool_delete and it is unregistered and removed from disk"
    - "Agent can update an existing agent-authored tool by calling tool_write with the same name — old version is replaced"
    - "Built-in tool modifications go through git branch staging: branch, commit, test, merge on success, abandon on failure"
    - "Agent-authored tools skip git staging — modified freely without branches"
    - "tool_write rejects tool names that collide with built-in tools unless the agent explicitly uses the builtinModify flag"
    - "AGENT-01 through AGENT-04 are satisfied: the agent can write any tool (including x402 payment tools) using tool_write"
  artifacts:
    - path: "packages/tools/src/self-extension/tool-writer.ts"
      provides: "tool_write and tool_delete ToolDefinitions"
      exports: ["createToolWriteTool", "createToolDeleteTool"]
    - path: "packages/tools/src/self-extension/staging-deployer.ts"
      provides: "Git branch staging for built-in tool modifications"
      exports: ["stageBuiltinChange"]
    - path: "packages/tools/src/self-extension/index.ts"
      provides: "createSelfExtensionTools factory barrel export"
      exports: ["createSelfExtensionTools"]
    - path: "packages/tools/src/index.ts"
      provides: "Updated barrel with self-extension exports"
      contains: "createSelfExtensionTools"
  key_links:
    - from: "packages/tools/src/self-extension/tool-writer.ts"
      to: "packages/tools/src/self-extension/compiler.ts"
      via: "compileTypeScript() for TS->JS"
      pattern: "compileTypeScript"
    - from: "packages/tools/src/self-extension/tool-writer.ts"
      to: "packages/tools/src/self-extension/sandbox-runner.ts"
      via: "runInSandbox() for testing compiled code"
      pattern: "runInSandbox"
    - from: "packages/tools/src/self-extension/tool-writer.ts"
      to: "packages/tools/src/self-extension/tool-loader.ts"
      via: "AGENT_TOOLS_DIR for persistence path"
      pattern: "AGENT_TOOLS_DIR"
    - from: "packages/tools/src/self-extension/tool-writer.ts"
      to: "packages/tools/src/registry.ts"
      via: "registry.unregister + registry.register for hot-swap"
      pattern: "registry\\.(unregister|register)"
    - from: "packages/tools/src/self-extension/staging-deployer.ts"
      to: "packages/tools/src/self-extension/sandbox-runner.ts"
      via: "runInSandbox for testing staged built-in changes"
      pattern: "runInSandbox"
---

<objective>
Create the tool_write and tool_delete agent-facing tools that enable the agent to author, test, persist, and register new tools at runtime. Also create the git branch staging workflow for safe modification of built-in Phase 1-7 tools.

Purpose: This is the core self-extension capability. The agent can write any TypeScript tool (including x402 payment tools for AGENT-01 through AGENT-04), have it sandbox-tested, and immediately use it. Built-in tools are protected by git branch staging.
Output: tool_write and tool_delete ToolDefinitions, staging-deployer for built-in mods, createSelfExtensionTools factory.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-self-extension-and-agent-economics/08-RESEARCH.md
@.planning/phases/08-self-extension-and-agent-economics/08-CONTEXT.md
@.planning/phases/08-self-extension-and-agent-economics/08-01-SUMMARY.md
@packages/tools/src/types.ts
@packages/tools/src/registry.ts
@packages/tools/src/index.ts
@packages/tools/src/self-extension/compiler.ts
@packages/tools/src/self-extension/sandbox-runner.ts
@packages/tools/src/self-extension/tool-loader.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: tool_write and tool_delete ToolDefinitions + staging deployer</name>
  <files>
    packages/tools/src/self-extension/tool-writer.ts
    packages/tools/src/self-extension/staging-deployer.ts
  </files>
  <action>
### staging-deployer.ts

Create `packages/tools/src/self-extension/staging-deployer.ts`:

1. Export `async function stageBuiltinChange(opts: { toolName: string; filePath: string; newContent: string; testInput: unknown; }): Promise<{ success: boolean; error?: string }>`:
   - Import simpleGit from 'simple-git' (default import)
   - Import { compileTypeScript } from './compiler.js'
   - Import { runInSandbox } from './sandbox-runner.js'
   - const git = simpleGit(process.cwd())
   - Branch name: `agent/builtin-mod/${opts.toolName}-${Date.now()}`
   - Flow:
     a. Verify working tree is clean for the target file: `await git.status()` — check that `opts.filePath` is NOT in the modified/untracked lists. If dirty, return `{ success: false, error: 'Working tree has uncommitted changes for ${filePath}' }`
     b. `await git.checkoutLocalBranch(branchName)`
     c. Write newContent to opts.filePath using writeFileSync from 'node:fs'
     d. `await git.add(opts.filePath)`
     e. `await git.commit(\`agent: modify builtin tool ${opts.toolName}\`)`
     f. Compile the new content: `const { code } = await compileTypeScript(opts.newContent)`
     g. Run sandbox test: `const result = await runInSandbox(code, opts.toolName, opts.testInput, 30_000)`
     h. If !result.passed:
        - `await git.checkout('main')` (or current branch — use `git.revparse(['--abbrev-ref', 'HEAD'])` to get current branch name BEFORE creating the staging branch)
        - `await git.deleteLocalBranch(branchName, true)` (force delete)
        - Return `{ success: false, error: \`Sandbox test failed: ${result.error}\` }`
     i. If result.passed:
        - `await git.checkout(originalBranch)` (the branch we were on before staging)
        - `await git.merge([branchName, '--ff-only'])`
        - `await git.deleteLocalBranch(branchName)`
        - Return `{ success: true }`
   - Wrap entire function in try/catch:
     - On any error: ensure we switch back to original branch and delete staging branch (both in try/catch)
     - Return `{ success: false, error: err.message }`

   IMPORTANT: Save the current branch name BEFORE creating the staging branch (use `git.revparse(['--abbrev-ref', 'HEAD'])`). Don't assume 'main'.

### tool-writer.ts

Create `packages/tools/src/self-extension/tool-writer.ts`:

1. Import { compileTypeScript } from './compiler.js'
2. Import { runInSandbox } from './sandbox-runner.js'
3. Import { AGENT_TOOLS_DIR } from './tool-loader.js'
4. Import { stageBuiltinChange } from './staging-deployer.js'
5. Import type { ToolRegistry } from '../registry.js'
6. Import type { ToolDefinition } from '../types.js'
7. Import { mkdirSync, writeFileSync, unlinkSync, existsSync } from 'node:fs'
8. Import path from 'node:path'
9. Import { z } from 'zod'

**Maintain a set of built-in tool names** — the createToolWriteTool factory receives the registry and captures the initial tool names at factory creation time (these are the built-in tools). Agent-authored tools are anything NOT in this set.

10. Export `function createToolWriteTool(registry: ToolRegistry): ToolDefinition`:

Input schema:
```
z.object({
  name: z.string().min(1).max(64).regex(/^[a-z][a-z0-9_]*$/).describe(
    'Tool name (lowercase, underscores). Must be unique. If updating an existing agent-authored tool, use the same name.'
  ),
  description: z.string().min(1).max(500).describe('What this tool does — shown to the LLM for tool selection.'),
  tsSource: z.string().min(1).describe(
    'Complete TypeScript source code for the tool. Must export a ToolDefinition as default export or named "tool" export. ' +
    'The tool must have: name, description, inputSchema (zod), timeoutMs, execute(input, signal). ' +
    'Can import any installed npm package. Example: import { z } from "zod"; import type { ToolDefinition } from "@jarvis/tools";'
  ),
  testInput: z.unknown().default({}).describe(
    'Test input to pass to the tool execute() during sandbox testing. Must match the tool inputSchema.'
  ),
  builtinModify: z.boolean().default(false).describe(
    'Set to true to modify a built-in tool (Phase 1-7). This will use git branch staging: ' +
    'branch, test, merge on success. Only use this if you need to modify core agent capabilities. ' +
    'For new tools, leave false.'
  ),
  builtinFilePath: z.string().optional().describe(
    'Required when builtinModify is true. The file path of the built-in tool source to modify, ' +
    'relative to project root. Example: "packages/tools/src/shell/index.ts"'
  ),
})
```

Tool definition:
- name: 'tool_write'
- description: 'Write a new TypeScript tool or update an existing one. The source code is compiled, tested in an isolated sandbox process, then persisted to disk and registered for immediate use. ' +
  'For new tools: provide name, description, and tsSource. The tool is compiled via esbuild, tested in a forked child process, and on success written to disk and registered in the tool registry. ' +
  'For updating agent-authored tools: use the same name — the old version is replaced. ' +
  'For modifying built-in tools (Phase 1-7): set builtinModify=true and provide builtinFilePath. This creates a git branch, applies the change, tests it in a sandbox, and merges only on success. ' +
  'IMPORTANT: Your tool must export a ToolDefinition as default export or named "tool" export. ' +
  'All tool names must be lowercase with underscores. If your tool name matches a built-in, you must use builtinModify=true.'
- timeoutMs: 120_000 (compilation + sandbox can take time)
- maxOutputBytes: 8192

execute(input, signal):
  a. Check signal.aborted
  b. Validate the tool name:
     - If the name matches a built-in tool name AND builtinModify is false:
       return `{ success: false, error: 'Tool name "${input.name}" conflicts with a built-in tool. Use builtinModify=true to modify built-in tools, or choose a different name (e.g., "agent_${input.name}").' }`
  c. **If builtinModify is true:**
     - Require builtinFilePath: if not provided, return error
     - Call `stageBuiltinChange({ toolName: input.name, filePath: input.builtinFilePath!, newContent: input.tsSource, testInput: input.testInput })`
     - On success: return `{ success: true, mode: 'builtin-staged', toolName: input.name, message: 'Built-in tool modified via git branch staging. Run pnpm build --filter @jarvis/tools to compile changes.' }`
     - On failure: return `{ success: false, error: result.error }`
  d. **If builtinModify is false (agent-authored tool):**
     - Step 1: Compile — `const { code, warnings } = await compileTypeScript(input.tsSource)`
       - On compilation error (thrown): return `{ success: false, error: 'Compilation failed: ' + err.message }`
     - Step 2: Sandbox test — `const sandboxResult = await runInSandbox(code, input.name, input.testInput, 60_000)`
       - If !sandboxResult.passed: return `{ success: false, error: 'Sandbox test failed: ' + sandboxResult.error, sandboxOutput: sandboxResult.output }`
     - Step 3: Persist to disk
       - Ensure AGENT_TOOLS_DIR exists: `mkdirSync(AGENT_TOOLS_DIR, { recursive: true })`
       - Write TS source: `writeFileSync(path.join(AGENT_TOOLS_DIR, \`${input.name}.ts\`), input.tsSource, 'utf-8')`
       - Write compiled JS: `writeFileSync(path.join(AGENT_TOOLS_DIR, \`${input.name}.mjs\`), code, 'utf-8')`
     - Step 4: Dynamic import and register
       - Build absolute path: `const absPath = path.resolve(AGENT_TOOLS_DIR, \`${input.name}.mjs\`)`
       - Import with cache-busting: `const mod = await import(\`file://${absPath}?v=${Date.now()}\`)`
       - Extract tool: `const tool = mod.default ?? mod.tool`
       - If no valid tool: clean up disk files, return `{ success: false, error: 'Compiled code does not export a ToolDefinition (expected default or named "tool" export)' }`
       - Verify tool.name matches input.name: if not, clean up, return error
       - Unregister old version: `registry.unregister(input.name)` (no-op if not registered)
       - Register new: `registry.register(tool)`
     - Step 5: Return success
       - `{ success: true, mode: 'agent-authored', toolName: input.name, warnings, testOutput: sandboxResult.output }`
   - Wrap entire execute in try/catch: on unexpected error, return `{ success: false, error: err.message }`

11. Export `function createToolDeleteTool(registry: ToolRegistry): ToolDefinition`:

Input schema:
```
z.object({
  name: z.string().min(1).describe('Name of the agent-authored tool to delete.'),
})
```

Tool definition:
- name: 'tool_delete'
- description: 'Delete an agent-authored tool. Unregisters it from the tool registry and removes its source files from disk. ' +
  'Cannot delete built-in tools (Phase 1-7). The tool will no longer be available in subsequent planning cycles.'
- timeoutMs: 10_000
- execute(input, signal):
  a. Check if tool name is a built-in: if yes, return `{ success: false, error: 'Cannot delete built-in tool. Use tool_write with builtinModify=true to modify built-in tools.' }`
  b. Unregister from registry: `registry.unregister(input.name)` — if returns false, log warning (tool may already be unregistered)
  c. Remove disk files:
     - Try `unlinkSync(path.join(AGENT_TOOLS_DIR, \`${input.name}.ts\`))` (catch if not found)
     - Try `unlinkSync(path.join(AGENT_TOOLS_DIR, \`${input.name}.mjs\`))` (catch if not found)
  d. Return `{ success: true, deleted: input.name }`
  </action>
  <verify>
    - `pnpm build --filter @jarvis/tools` succeeds
    - tool-writer.ts exports createToolWriteTool and createToolDeleteTool
    - staging-deployer.ts exports stageBuiltinChange
  </verify>
  <done>tool_write compiles TS, sandbox tests, persists to disk, and registers agent-authored tools. Built-in modifications use git branch staging. tool_delete unregisters and removes agent-authored tools. Name collision detection prevents accidental built-in overwrites.</done>
</task>

<task type="auto">
  <name>Task 2: Self-extension barrel exports and @jarvis/tools integration</name>
  <files>
    packages/tools/src/self-extension/index.ts
    packages/tools/src/index.ts
  </files>
  <action>
1. Create `packages/tools/src/self-extension/index.ts`:
   ```typescript
   /**
    * Self-extension tool group — Phase 8.
    *
    * Tools:
    *   tool_write    — write, test, persist, and register new TypeScript tools (EXTEND-01, EXTEND-02, EXTEND-03)
    *   tool_delete   — unregister and remove agent-authored tools (EXTEND-03)
    *   schema_extend — extend database schema via transactional DDL (EXTEND-04)
    *
    * Use createSelfExtensionTools(registry) to get all 3 tools at once.
    */

   export { compileTypeScript } from './compiler.js';
   export { runInSandbox } from './sandbox-runner.js';
   export type { SandboxResult } from './sandbox-runner.js';
   export { loadPersistedTools, AGENT_TOOLS_DIR } from './tool-loader.js';
   export { createToolWriteTool, createToolDeleteTool } from './tool-writer.js';
   export { createSchemaExtendTool } from './schema-extend.js';
   export { stageBuiltinChange } from './staging-deployer.js';

   import type { ToolRegistry } from '../registry.js';
   import type { ToolDefinition } from '../types.js';
   import { createToolWriteTool, createToolDeleteTool } from './tool-writer.js';
   import { createSchemaExtendTool } from './schema-extend.js';

   /**
    * createSelfExtensionTools(registry) — convenience factory returning all 3 self-extension ToolDefinitions.
    *
    * Returns 3 tools:
    * 1. tool_write    — write/test/persist/register TypeScript tools (EXTEND-01, 02, 03, 05)
    * 2. tool_delete   — unregister and remove agent-authored tools
    * 3. schema_extend — extend database schema with transactional DDL (EXTEND-04)
    *
    * The registry reference is passed to tool_write/tool_delete so they can
    * register/unregister tools at runtime.
    *
    * @param registry - The ToolRegistry instance (passed by reference)
    */
   export function createSelfExtensionTools(registry: ToolRegistry): ToolDefinition<unknown, unknown>[] {
     return [
       createToolWriteTool(registry),
       createToolDeleteTool(registry),
       createSchemaExtendTool(),
     ];
   }
   ```

2. Update `packages/tools/src/index.ts`:
   - Add after the "// Bootstrap tools (Phase 06)" section:
   ```typescript
   // Self-extension tools (Phase 08)
   export { createSelfExtensionTools } from './self-extension/index.js';
   export { loadPersistedTools, AGENT_TOOLS_DIR } from './self-extension/index.js';
   ```

3. Verify build: `pnpm build --filter @jarvis/tools`
  </action>
  <verify>
    - `pnpm build --filter @jarvis/tools` succeeds
    - createSelfExtensionTools is exported from @jarvis/tools
    - loadPersistedTools and AGENT_TOOLS_DIR are exported from @jarvis/tools
  </verify>
  <done>createSelfExtensionTools factory returns all 3 self-extension tools. loadPersistedTools and AGENT_TOOLS_DIR are exported from @jarvis/tools for use in agent startup and worker sync.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds across entire workspace
- tool_write ToolDefinition: compiles TS, sandbox tests, persists to disk, registers (or stages built-in via git)
- tool_delete ToolDefinition: unregisters and removes agent-authored tools, blocks built-in deletion
- Built-in staging: git branch, commit, test, merge/abandon
- createSelfExtensionTools returns 3 tools (tool_write, tool_delete, schema_extend)
- @jarvis/tools barrel exports createSelfExtensionTools, loadPersistedTools, AGENT_TOOLS_DIR
</verification>

<success_criteria>
The agent can write any TypeScript tool (including x402 payment, data fetching, API integration) using tool_write. The tool is compiled, sandbox-tested in an isolated process, persisted to disk, and immediately registered. Built-in tool modifications go through git branch staging. Agent-authored tools can be deleted. All 3 self-extension tools are available via createSelfExtensionTools factory.
</success_criteria>

<output>
After completion, create `.planning/phases/08-self-extension-and-agent-economics/08-03-SUMMARY.md`
</output>