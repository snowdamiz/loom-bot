---
phase: 08-self-extension-and-agent-economics
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/tools/src/self-extension/schema-extend.ts
autonomous: true
requirements:
  - EXTEND-04
  - STRAT-07

must_haves:
  truths:
    - "Agent can execute CREATE TABLE inside a transaction and the table exists in Postgres after commit"
    - "Agent can execute ADD COLUMN on an existing table and the column exists after commit"
    - "A failed DDL statement inside a transaction leaves the database unchanged — no partial state"
    - "Agent cannot execute DROP TABLE or DROP COLUMN — the tool rejects destructive DDL"
    - "Each successfully applied migration is recorded in agent_migrations with name and SQL"
    - "Applying the same migration name twice is idempotent — returns already-applied, no error"
    - "Agent has full control over agent_* prefixed tables"
  artifacts:
    - path: "packages/tools/src/self-extension/schema-extend.ts"
      provides: "schema_extend ToolDefinition + applyAgentMigration internal function"
      exports: ["createSchemaExtendTool"]
  key_links:
    - from: "packages/tools/src/self-extension/schema-extend.ts"
      to: "packages/db/src/client.ts"
      via: "pool.connect() for raw SQL transactions"
      pattern: "pool\\.connect"
    - from: "packages/tools/src/self-extension/schema-extend.ts"
      to: "packages/db/src/schema/agent-migrations.ts"
      via: "INSERT into agent_migrations inside same transaction"
      pattern: "agent_migrations"
---

<objective>
Create the schema_extend tool that allows the agent to evolve its own database schema via transactional DDL. The tool validates DDL safety (no DROP TABLE/DROP COLUMN), enforces namespace rules, wraps execution in a PostgreSQL transaction (fully transactional DDL), and tracks migrations in agent_migrations.

Purpose: Enables EXTEND-04 (agent extends its own schema) and STRAT-07 (agent creates per-strategy P&L tables itself). PostgreSQL's unique transactional DDL support means failed migrations auto-rollback with no partial state.
Output: schema_extend ToolDefinition ready for registration in Plan 04.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-self-extension-and-agent-economics/08-RESEARCH.md
@.planning/phases/08-self-extension-and-agent-economics/08-CONTEXT.md
@packages/db/src/client.ts
@packages/db/src/index.ts
@packages/tools/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: DDL validation and migration application internals</name>
  <files>
    packages/tools/src/self-extension/schema-extend.ts
  </files>
  <action>
Create `packages/tools/src/self-extension/schema-extend.ts` with the following internal functions (NOT the tool definition yet — that's Task 2):

1. `function validateDdl(sql: string): { valid: boolean; error?: string }`:
   - Normalize SQL: trim, collapse whitespace, uppercase for matching
   - REJECT if it contains any of (case-insensitive regex):
     - `DROP\s+TABLE` — "DROP TABLE is not allowed. Agent can only create or modify tables."
     - `DROP\s+COLUMN` — "DROP COLUMN is not allowed. Use ALTER COLUMN to modify existing columns."
     - `TRUNCATE` — "TRUNCATE is not allowed."
     - `DROP\s+DATABASE` — "DROP DATABASE is not allowed."
     - `DROP\s+SCHEMA` — "DROP SCHEMA is not allowed."
   - ALLOW these DDL operations (informational — anything not in reject list passes):
     - CREATE TABLE, ALTER TABLE ... ADD COLUMN, ALTER TABLE ... ALTER COLUMN
     - CREATE INDEX, CREATE UNIQUE INDEX
     - ALTER TABLE ... ADD CONSTRAINT
   - For core table modifications (tables NOT prefixed with `agent_`):
     - Only allow ADD COLUMN: Check if the SQL targets a non-agent_* table AND contains ALTER TABLE — if so, verify it ONLY uses ADD COLUMN (not ALTER COLUMN, DROP COLUMN, DROP CONSTRAINT, RENAME)
     - Pattern: extract table name from `ALTER\s+TABLE\s+(\w+)`, if table name does NOT start with `agent_`, verify only `ADD\s+COLUMN` operations are present
     - If core table has destructive/modifying operations: reject with "Core tables (non-agent_* prefix) only support ADD COLUMN. Use agent_* prefixed tables for full control."
   - Return `{ valid: true }` if passes all checks

2. `async function applyAgentMigration(migrationName: string, ddlSql: string): Promise<{ applied: boolean; error?: string; alreadyApplied?: boolean }>`:
   - Import `pool` from '@jarvis/db' (the raw pg Pool, NOT the drizzle instance — need raw client for BEGIN/COMMIT/ROLLBACK)
   - `const client = await pool.connect()`
   - Inside try:
     a. `await client.query('BEGIN')`
     b. Check idempotency: `SELECT id FROM agent_migrations WHERE migration_name = $1` with [migrationName]
        - If rows.length > 0: `await client.query('ROLLBACK')`, return `{ applied: false, alreadyApplied: true }`
     c. Execute DDL: `await client.query(ddlSql)` — PostgreSQL DDL is fully transactional
     d. Record migration: `INSERT INTO agent_migrations (migration_name, sql_executed) VALUES ($1, $2)` with [migrationName, ddlSql]
     e. `await client.query('COMMIT')`
     f. Return `{ applied: true }`
   - Catch: `await client.query('ROLLBACK')`, return `{ applied: false, error: err.message }`
   - Finally: `client.release()` — CRITICAL: always release the connection back to the pool

   IMPORTANT per research Pitfall 5: The DDL SQL string must be fully constructed BEFORE acquiring the pool connection. Do NOT hold the connection while waiting for LLM or any async external call. The tool receives the final SQL as input — no async decisions during the transaction.
  </action>
  <verify>
    - File compiles: `pnpm build --filter @jarvis/tools` succeeds
    - validateDdl rejects: DROP TABLE, DROP COLUMN, TRUNCATE, non-agent_* ALTER COLUMN
    - validateDdl allows: CREATE TABLE agent_foo, ALTER TABLE agent_foo ADD COLUMN, CREATE INDEX
  </verify>
  <done>DDL validation rejects destructive operations and enforces namespace rules. applyAgentMigration wraps DDL in PostgreSQL transaction with idempotency check and migration tracking.</done>
</task>

<task type="auto">
  <name>Task 2: schema_extend ToolDefinition</name>
  <files>
    packages/tools/src/self-extension/schema-extend.ts
  </files>
  <action>
Add to the same `schema-extend.ts` file created in Task 1:

1. Define Zod input schema:
   ```
   z.object({
     migrationName: z.string().min(1).max(128).describe(
       'Unique name for this migration, e.g. "create_agent_x402_transactions" or "add_column_agent_strategies_profit". Must be unique across all migrations.'
     ),
     sql: z.string().min(1).describe(
       'The DDL SQL to execute. Allowed: CREATE TABLE, ALTER TABLE ADD COLUMN, CREATE INDEX, ALTER COLUMN. ' +
       'Forbidden: DROP TABLE, DROP COLUMN, TRUNCATE. ' +
       'Tables prefixed with agent_* have full control. Core tables only support ADD COLUMN. ' +
       'PostgreSQL DDL is transactional — on error, everything rolls back automatically.'
     ),
   })
   ```

2. Export `function createSchemaExtendTool(): ToolDefinition`:
   - name: 'schema_extend'
   - description: 'Extend the database schema by executing DDL (CREATE TABLE, ADD COLUMN, CREATE INDEX, ALTER COLUMN). ' +
     'All changes are wrapped in a PostgreSQL transaction — on error, the database is unchanged. ' +
     'You have full control over agent_* prefixed tables. Core tables support ADD COLUMN only. ' +
     'DROP TABLE and DROP COLUMN are forbidden. Each migration is tracked by name for idempotency. ' +
     'Use this to create tables for tracking data (P&L, transactions, metrics) or to add columns as needs evolve.'
   - inputSchema: the Zod schema above
   - timeoutMs: 30_000
   - execute(input, signal):
     a. Check signal.aborted — return error if aborted
     b. Call `validateDdl(input.sql)` — if invalid, return `{ success: false, error: validation.error }`
     c. Call `applyAgentMigration(input.migrationName, input.sql)`
     d. If alreadyApplied: return `{ success: true, alreadyApplied: true, migrationName: input.migrationName }`
     e. If applied: return `{ success: true, applied: true, migrationName: input.migrationName }`
     f. If error: return `{ success: false, error: result.error }`

   Per locked decision: On error, return structured result to agent — agent decides whether to fix SQL and retry or abandon. Never throw.

3. Import `pool` from '@jarvis/db' at the top of the file (not `db` — need raw pool for client.query).
   IMPORTANT: @jarvis/db exports `pool` from client.ts. Import as: `import { pool } from '@jarvis/db';`
  </action>
  <verify>
    - `pnpm build --filter @jarvis/tools` succeeds
    - The schema_extend tool is exported and has the correct ToolDefinition shape
  </verify>
  <done>schema_extend ToolDefinition is exported from schema-extend.ts. It validates DDL safety, enforces namespace rules, applies DDL in a PostgreSQL transaction, tracks migrations, and returns structured results to the agent.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds across workspace
- `packages/tools/src/self-extension/schema-extend.ts` exports createSchemaExtendTool
- DDL validation correctly rejects DROP TABLE, DROP COLUMN, TRUNCATE
- DDL validation allows CREATE TABLE, ADD COLUMN, CREATE INDEX for agent_* tables
- DDL validation restricts core tables to ADD COLUMN only
- Migration application uses BEGIN/COMMIT/ROLLBACK with connection release
</verification>

<success_criteria>
The schema_extend tool exists with full DDL validation, namespace enforcement, transactional execution, and migration tracking. The agent can safely CREATE TABLE agent_*, ADD COLUMN to any table, and CREATE INDEX — but cannot DROP TABLE or DROP COLUMN. Failed DDL is automatically rolled back by PostgreSQL's transactional DDL. Duplicate migrations are idempotent.
</success_criteria>

<output>
After completion, create `.planning/phases/08-self-extension-and-agent-economics/08-02-SUMMARY.md`
</output>
