---
phase: 03-autonomous-loop
plan: 06
type: execute
wave: 4
depends_on:
  - 03-02
  - 03-04
  - 03-05
files_modified:
  - apps/agent/src/recovery/journal.ts
  - apps/agent/src/recovery/startup-recovery.ts
  - apps/agent/src/index.ts
  - apps/agent/src/shutdown.ts
autonomous: true
requirements:
  - RECOV-01
  - RECOV-02
  - RECOV-03
  - RECOV-04

must_haves:
  truths:
    - "Agent journals each sub-goal completion before proceeding to the next step"
    - "On restart, agent reads journal and resumes from last completed sub-goal checkpoint"
    - "Incomplete planning cycles are detected and replanned on recovery"
    - "On crash recovery, Discord DM alert is sent to operator"
    - "Multiple main agents restart in staggered sequence to avoid resource spikes"
    - "Agent process bootstraps the full autonomous loop at startup"
  artifacts:
    - path: "apps/agent/src/recovery/journal.ts"
      provides: "Checkpoint write/read system using agent_state table"
      exports: ["checkpoint", "readJournal", "clearJournal"]
    - path: "apps/agent/src/recovery/startup-recovery.ts"
      provides: "On-boot recovery: detect interrupted work, replay journal, staggered restart"
      exports: ["performStartupRecovery"]
    - path: "apps/agent/src/index.ts"
      provides: "Updated agent entry point bootstrapping the full autonomous loop with all Phase 3 components"
      contains: "Supervisor"
    - path: "apps/agent/src/shutdown.ts"
      provides: "Updated shutdown handler including agent loop and sub-agent worker cleanup"
      contains: "supervisor"
  key_links:
    - from: "apps/agent/src/recovery/journal.ts"
      to: "packages/db/src/schema/agent-state.ts"
      via: "agent_state key-value store for checkpoint persistence"
      pattern: "agentState.*journal"
    - from: "apps/agent/src/recovery/startup-recovery.ts"
      to: "apps/agent/src/recovery/journal.ts"
      via: "Reads journal to determine recovery state"
      pattern: "readJournal"
    - from: "apps/agent/src/recovery/startup-recovery.ts"
      to: "packages/ai/src/discord.ts"
      via: "Discord DM alert on crash recovery"
      pattern: "sendOperatorDm"
    - from: "apps/agent/src/index.ts"
      to: "apps/agent/src/multi-agent/supervisor.ts"
      via: "Creates and starts supervisor for main agent management"
      pattern: "new Supervisor|supervisor\\.startSupervisorLoop"
---

<objective>
Build the crash recovery system (journal checkpointing + startup replay) and wire the full autonomous loop into the agent process entry point. This is the final integration plan that brings all Phase 3 components together into a running system.

Purpose: Without checkpointing, a crash loses all in-flight work. Without startup recovery, the agent starts fresh every time instead of resuming. Without the process wiring, all the loop/multi-agent/queue components sit unused.
Output: Journal system, startup recovery module, and updated agent entry point that boots the complete autonomous loop.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-autonomous-loop/03-RESEARCH.md
@.planning/phases/03-autonomous-loop/03-02-SUMMARY.md
@.planning/phases/03-autonomous-loop/03-04-SUMMARY.md
@.planning/phases/03-autonomous-loop/03-05-SUMMARY.md

@apps/agent/src/index.ts
@apps/agent/src/shutdown.ts
@apps/agent/src/worker.ts
@apps/agent/src/loop/agent-loop.ts
@apps/agent/src/loop/goal-manager.ts
@apps/agent/src/loop/evaluator.ts
@apps/agent/src/loop/replanner.ts
@apps/agent/src/multi-agent/supervisor.ts
@apps/agent/src/multi-agent/sub-agent-tool.ts
@apps/agent/src/multi-agent/agent-worker.ts
@apps/agent/src/multi-agent/result-collector.ts
@packages/ai/src/router.ts
@packages/ai/src/tool-schema.ts
@packages/ai/src/discord.ts
@packages/db/src/schema/agent-state.ts
@packages/db/src/schema/goals.ts
@packages/db/src/schema/planning-cycles.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create journal checkpoint system</name>
  <files>apps/agent/src/recovery/journal.ts</files>
  <action>
Create `apps/agent/src/recovery/journal.ts`:

Import `db, agentState, eq` from `@jarvis/db`. Import type `DbClient` from `@jarvis/db`.

Define `JournalEntry` interface:
```typescript
interface JournalEntry {
  subGoalId: number;
  goalId: number;
  completedAt: string;  // ISO timestamp
  outcome: unknown;     // what was produced
  status: 'completed' | 'failed' | 'skipped';
}
```

Export async function `checkpoint(db: DbClient, goalId: number, entry: JournalEntry): Promise<void>`:
- Key format: `journal:${goalId}`
- Read existing journal from agent_state (select where key = journalKey)
- Parse value as JournalEntry[] (default to empty array if not found)
- Push new entry
- Upsert: if row exists, update value + updatedAt; if not, insert
- CRITICAL (per research Pitfall 3): This write MUST succeed before the agent proceeds to the next sub-goal. If the write fails after 3 retries (with 500ms delay between), throw an error that halts the agent loop for this goal. Do NOT silently skip — a missed checkpoint means replay will re-execute the sub-goal on crash recovery, causing duplicates.
- Retry logic: wrap the DB operation in a 3-attempt retry loop with 500ms delay

Export async function `readJournal(db: DbClient, goalId: number): Promise<JournalEntry[]>`:
- Key: `journal:${goalId}`
- Select from agent_state
- Parse value as JournalEntry[], return empty array if not found

Export async function `clearJournal(db: DbClient, goalId: number): Promise<void>`:
- Delete the agent_state row for `journal:${goalId}`
- Called when a goal completes or is abandoned (cleanup)

Export async function `getCompletedSubGoalIds(db: DbClient, goalId: number): Promise<Set<number>>`:
- Convenience: reads journal, returns Set of subGoalId values with status='completed'
- Used by startup recovery to skip already-completed sub-goals

Export type { JournalEntry }.
  </action>
  <verify>
`cd /Users/sn0w/Documents/dev/jarvis/apps/agent && npx tsc --noEmit` compiles cleanly. Journal functions are importable.
  </verify>
  <done>
Journal checkpoint system writes to agent_state after each sub-goal completion with mandatory success (3 retries before halting). Reads support startup recovery with Set of completed sub-goal IDs. Cleanup available on goal completion.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create startup recovery module</name>
  <files>apps/agent/src/recovery/startup-recovery.ts</files>
  <action>
Create `apps/agent/src/recovery/startup-recovery.ts`:

Import from @jarvis/db: db, goals, planningCycles, eq
Import { readJournal, getCompletedSubGoalIds } from ./journal.js
Import { sendOperatorDm } from @jarvis/ai
Import type { Supervisor } from ../multi-agent/supervisor.js

Export async function `performStartupRecovery(db: DbClient, supervisor: Supervisor, config?: { discordBotToken?: string; discordOperatorUserId?: string }): Promise<{ recovered: number; escalated: number }>`:

Step 1 — Detect interrupted work:
- Query goals table for status='active' rows
- Query planningCycles table for status='active' rows (RECOV-04: incomplete cycles)
- If no active goals and no active cycles: return `{ recovered: 0, escalated: 0 }` (clean start)

Step 2 — Send recovery alert (locked decision: Discord DM on crash recovery):
- If config.discordBotToken and config.discordOperatorUserId are set:
  - `await sendOperatorDm(token, userId, '[Jarvis] Crash recovery: restarting ${activeGoals.length} active goals.')`
  - Non-fatal: if DM fails, log to stderr and continue

Step 3 — Handle incomplete planning cycles (RECOV-04):
- For each active planning cycle:
  - Mark as interrupted (insert completion row with status='interrupted', per two-row pattern)
  - The goals associated with these cycles will be re-evaluated in step 4

Step 4 — Re-evaluate partially completed sub-goals (locked decision):
- For each active goal:
  - Read journal via readJournal(db, goalId)
  - Get completed sub-goal IDs
  - For sub-goals with status='in-progress' at crash time:
    - These are the ones that were interrupted mid-execution
    - Reset status to 'pending' (they'll be re-executed on the next loop iteration)
    - Log: "[recovery] Sub-goal #{id} was in-progress at crash time, reset to pending for re-evaluation"
  - The agent loop will pick them up on the next cycle and the evaluator will determine if prior partial work is still valid

Step 5 — Staggered restart via supervisor (locked decision):
- Call `supervisor.staggeredRestart()` which spawns main agents with delay between each
- Return count of recovered goals

Export async function `detectCrashRecovery(db: DbClient): Promise<boolean>`:
- Quick check: are there active goals in the DB?
- If yes: this is a recovery scenario (process was restarted while goals were active)
- If no: clean start
- Used by index.ts to decide whether to run recovery flow
  </action>
  <verify>
`cd /Users/sn0w/Documents/dev/jarvis/apps/agent && npx tsc --noEmit` compiles cleanly. performStartupRecovery and detectCrashRecovery are importable.
  </verify>
  <done>
Startup recovery detects interrupted work, sends Discord DM alert, handles incomplete planning cycles, resets in-progress sub-goals, and restarts main agents via staggered supervisor. Agent resumes from last journal checkpoint without re-executing completed work.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire full autonomous loop into agent process entry point</name>
  <files>
    apps/agent/src/index.ts
    apps/agent/src/shutdown.ts
  </files>
  <action>
Update `apps/agent/src/index.ts` — the main agent process entry point:

Keep all existing Phase 1 + 2 initialization (registry, queue, consolidation, shutdown handlers, killSwitch, modelConfig, router, agent_state write). Remove the `void killSwitch; void router;` suppressions.

After existing initialization, add Phase 3 bootstrap:

1. Import new modules:
   - `{ GoalManager }` from `./loop/goal-manager.js`
   - `{ AgentLoop }` from `./loop/agent-loop.js`
   - `{ Evaluator }` from `./loop/evaluator.js`
   - `{ Replanner }` from `./loop/replanner.js`
   - `{ Supervisor }` from `./multi-agent/supervisor.js`
   - `{ createSpawnAgentTool, createAwaitAgentTool, createCancelAgentTool }` from `./multi-agent/sub-agent-tool.js`
   - `{ createAgentWorker }` from `./multi-agent/agent-worker.js`
   - `{ toolDefinitionsToOpenAI }` from `@jarvis/ai`
   - `{ detectCrashRecovery, performStartupRecovery }` from `./recovery/startup-recovery.js`

2. Create agent-tasks queue:
   ```
   const agentTasksQueue = new Queue('agent-tasks', { connection: { url: process.env.REDIS_URL! } });
   ```

3. Register sub-agent tools in the registry:
   ```
   registry.register(createSpawnAgentTool(agentTasksQueue));
   registry.register(createAwaitAgentTool(agentTasksQueue));
   registry.register(createCancelAgentTool(agentTasksQueue));
   ```

4. Convert tool registry to OpenAI format:
   ```
   const openAITools = toolDefinitionsToOpenAI(registry);
   ```

5. Create Phase 3 components:
   ```
   const goalManager = new GoalManager(db, router);
   const evaluator = new Evaluator(router, db);
   const replanner = new Replanner(goalManager, router, db);
   const supervisor = new Supervisor({
     db, router, registry, killSwitch, goalManager,
     tools: openAITools,
   });
   ```

6. Create agent-tasks worker:
   ```
   const agentWorker = createAgentWorker({
     redisUrl: process.env.REDIS_URL!,
     router, registry, killSwitch, db,
     tools: openAITools,
   });
   ```

7. Run startup recovery:
   ```
   const isRecovery = await detectCrashRecovery(db);
   if (isRecovery) {
     const result = await performStartupRecovery(db, supervisor, {
       discordBotToken: process.env.DISCORD_BOT_TOKEN,
       discordOperatorUserId: process.env.DISCORD_OPERATOR_USER_ID,
     });
     process.stderr.write(`[agent] Recovery complete: ${result.recovered} goals resumed.\n`);
   }
   ```

8. Start supervisor loop:
   ```
   supervisor.startSupervisorLoop();
   process.stderr.write('[agent] Autonomous loop started. Supervisor active.\n');
   ```

9. Log Phase 3 startup:
   ```
   process.stderr.write(`[agent] Phase 3 ready. Tools: ${registry.count()}. Goals: supervisor managed.\n`);
   ```

Update `apps/agent/src/shutdown.ts`:
- Add `supervisor?: { stopMainAgent(goalId: number): Promise<void>; getActiveGoalIds(): number[] }` to ShutdownResources interface
- Add `agentWorker?: Worker` to ShutdownResources
- Add `agentTasksQueue?: { close(): Promise<void> }` to ShutdownResources
- In gracefulShutdown:
  - After stopping consolidation, before closing BullMQ worker:
    - Stop all active main agents: `for (const goalId of resources.supervisor.getActiveGoalIds()) { await resources.supervisor.stopMainAgent(goalId); }`
    - Close agent worker: `await resources.agentWorker?.close()`
    - Close agent-tasks queue: `await resources.agentTasksQueue?.close()`
  - Log each step to stderr

Update the registerShutdownHandlers call in index.ts to pass the new resources:
```
registerShutdownHandlers({
  pool, redis, consolidation,
  supervisor, agentWorker, agentTasksQueue,
});
```

RECOV-03 note: Fly.io `restart: always` policy ensures the process relaunches on crash. The Postgres-backed journal and BullMQ Redis persistence survive restarts. Add a comment in index.ts noting this dependency.
  </action>
  <verify>
`cd /Users/sn0w/Documents/dev/jarvis && npx turbo build` — full monorepo builds. Agent process starts and logs Phase 3 startup messages. Supervisor loop is running.
  </verify>
  <done>
Agent process entry point bootstraps the full autonomous loop: tool registry with sub-agent tools, GoalManager, Evaluator, Replanner, Supervisor, agent-tasks worker, startup recovery, and graceful shutdown of all components. The agent is a fully autonomous system.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/sn0w/Documents/dev/jarvis && npx turbo build` — full monorepo build passes
2. Agent process starts, runs startup recovery if needed, starts supervisor loop
3. Journal checkpoint writes succeed with retry before proceeding (RECOV-01)
4. On simulated restart with active goals: recovery detects them, reads journal, resumes (RECOV-02)
5. Discord DM sent on crash recovery (if tokens configured)
6. Graceful shutdown stops all agents, workers, and queues cleanly
7. All sub-agent tools are registered in the registry and available to the LLM
</verification>

<success_criteria>
- Journal checkpoints at every sub-goal completion with mandatory success (RECOV-01)
- Startup recovery replays journal and resumes from last checkpoint (RECOV-02)
- Postgres-backed journal + BullMQ Redis survive Fly.io restarts (RECOV-03)
- Incomplete planning cycles detected and handled on recovery (RECOV-04)
- Discord DM alert on crash recovery (locked decision)
- Staggered restart for multiple main agents (locked decision)
- Full autonomous loop wired into agent process entry point
- Graceful shutdown handles all Phase 3 resources
- TypeScript compiles cleanly across the full monorepo
</success_criteria>

<output>
After completion, create `.planning/phases/03-autonomous-loop/03-06-SUMMARY.md`
</output>
