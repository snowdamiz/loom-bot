---
phase: 03-autonomous-loop
plan: 05
type: execute
wave: 3
depends_on:
  - 03-02
  - 03-03
files_modified:
  - apps/agent/src/loop/evaluator.ts
  - apps/agent/src/loop/replanner.ts
  - apps/agent/src/multi-agent/supervisor.ts
  - apps/agent/src/multi-agent/result-collector.ts
autonomous: true
requirements:
  - LOOP-03
  - MULTI-05
  - MULTI-06

must_haves:
  truths:
    - "Agent detects when sub-goal outcomes diverge from expectations and triggers replanning"
    - "Divergence detection uses both metric-based triggers and LLM evaluation"
    - "When replanning triggers, in-progress work is evaluated for relevance — kept if useful, aborted if not"
    - "Replan count is tracked per goal with a hard limit before operator escalation"
    - "Supervisor manages multiple independent main agents with staggered startup and concurrency caps"
    - "Main agent decides whether to spawn a sub-agent or execute inline based on task complexity"
  artifacts:
    - path: "apps/agent/src/loop/evaluator.ts"
      provides: "Dual divergence detection: metric-based triggers + LLM evaluation"
      exports: ["Evaluator"]
    - path: "apps/agent/src/loop/replanner.ts"
      provides: "Replan logic: evaluate in-progress work, replan limit, operator escalation"
      exports: ["Replanner"]
    - path: "apps/agent/src/multi-agent/supervisor.ts"
      provides: "Multi-agent supervisor: spawn main agents, manage concurrency, staggered restart"
      exports: ["Supervisor"]
    - path: "apps/agent/src/multi-agent/result-collector.ts"
      provides: "Result aggregation from multiple sub-agents"
      exports: ["ResultCollector"]
  key_links:
    - from: "apps/agent/src/loop/evaluator.ts"
      to: "packages/ai/src/router.ts"
      via: "LLM evaluation for subtle divergence detection"
      pattern: "router\\.complete"
    - from: "apps/agent/src/loop/replanner.ts"
      to: "apps/agent/src/loop/goal-manager.ts"
      via: "Resets sub-goals, increments replan count, pauses goal on limit"
      pattern: "goalManager\\.(updateSubGoalStatus|incrementReplanCount|updateGoalStatus)"
    - from: "apps/agent/src/multi-agent/supervisor.ts"
      to: "apps/agent/src/loop/agent-loop.ts"
      via: "Creates AgentLoop instances per main agent goal"
      pattern: "new AgentLoop|agentLoop\\.runGoalCycle"
---

<objective>
Build the evaluator (divergence detection), replanner (adaptive replanning with operator escalation), supervisor (multi-agent management), and result collector. These complete the autonomous loop's intelligence — the ability to detect problems, adapt plans, and coordinate multiple independent agents.

Purpose: Without evaluation, the agent blindly follows failing plans. Without replanning, it cannot adapt. Without the supervisor, multiple concurrent goals cannot be managed safely.
Output: Four modules that together enable adaptive, multi-agent goal execution with operator escalation as a safety valve.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-autonomous-loop/03-RESEARCH.md
@.planning/phases/03-autonomous-loop/03-02-SUMMARY.md
@.planning/phases/03-autonomous-loop/03-03-SUMMARY.md

@apps/agent/src/loop/goal-manager.ts
@apps/agent/src/loop/agent-loop.ts
@apps/agent/src/loop/planner.ts
@apps/agent/src/multi-agent/sub-agent-tool.ts
@apps/agent/src/multi-agent/agent-worker.ts
@packages/ai/src/router.ts
@packages/ai/src/discord.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create evaluator and replanner</name>
  <files>
    apps/agent/src/loop/evaluator.ts
    apps/agent/src/loop/replanner.ts
  </files>
  <action>
Create `apps/agent/src/loop/evaluator.ts`:

Export class `Evaluator` with constructor taking `(router: ModelRouter, db: DbClient)`.

Method `evaluateOutcome(subGoal: SubGoal, outcome: unknown, goalDescription: string): Promise<{ divergent: boolean; reason?: string; severity: 'none' | 'minor' | 'major' }>`:
- Step 1 — Metric-based triggers (fast, no LLM call):
  - Check if outcome indicates failure (success === false)
  - Check if sub-goal took too many retries (check BullMQ failed attempts if agentJobId present)
  - Check if cost exceeded threshold (query ai_calls for this goalId, compare to configurable limit)
  - If any metric trigger fires, return `{ divergent: true, reason: '...', severity: 'major' }` without LLM call
- Step 2 — LLM evaluation (for subtler divergence):
  - Only runs if metric checks pass (saves cost)
  - Call `router.complete(messages, 'cheap')` with a prompt:
    - "Goal: {goalDescription}"
    - "Sub-goal: {subGoal.description}"
    - "Outcome: {JSON.stringify(outcome)}"
    - "Evaluate: Did this outcome move us toward the goal? Is the quality acceptable? Are there unexpected results that suggest the plan needs adjustment?"
    - "Respond with JSON: { divergent: boolean, reason: string, severity: 'none'|'minor'|'major' }"
  - Parse JSON response, validate structure
  - Uses 'cheap' tier (evaluation is a classification task, not complex reasoning)

Method `shouldReplan(goalId: number, evaluations: Array<{ divergent: boolean; severity: string }>): boolean`:
- Returns true if:
  - Any evaluation has severity === 'major'
  - More than 2 evaluations have severity === 'minor' (accumulating minor issues)
  - More than 50% of recent evaluations are divergent

Create `apps/agent/src/loop/replanner.ts`:

Export class `Replanner` with constructor taking `(goalManager: GoalManager, router: ModelRouter, db: DbClient, config?: { maxReplansPerGoal?: number })`.

Method `replan(goalId: number, reason: string): Promise<{ replanned: boolean; escalated: boolean }>`:
- Step 1: Increment replan count via goalManager.incrementReplanCount()
- Step 2: Check against hard limit (config.maxReplansPerGoal, default 5)
  - If exceeded: pause goal via goalManager.updateGoalStatus(goalId, 'paused', reason), send Discord DM alert, return `{ replanned: false, escalated: true }`
- Step 3: Evaluate in-progress work (locked decision — keep what's relevant, abort what's not):
  - Get all sub-goals for this goal
  - For sub-goals with status='in-progress':
    - Ask LLM (cheap tier): "Given this replan reason: {reason}, is sub-goal '{description}' with current progress still useful? Respond JSON: { keep: boolean, reason: string }"
    - If keep=false: update status to 'skipped'
    - If keep=true: leave as-is
  - For sub-goals with status='pending': mark as 'skipped' (they were part of the old plan)
- Step 4: Re-decompose the goal via goalManager.decomposeGoal() with updated context (what was already accomplished via completed sub-goals)
- Step 5: Notify operator (locked decision — operator notified on major replans):
  - Import sendOperatorDm from @jarvis/ai
  - Send: "[Jarvis] Goal #{goalId} replanned (attempt {replanCount}): {reason}"
  - Non-fatal: if DM fails, log to stderr and continue
- Return `{ replanned: true, escalated: false }`

IMPORTANT per locked decision:
- Operator notified ONLY on major replans (top-level goal changes). Routine sub-goal replanning is logged but silent.
- Hard replan limit per goal → escalate to operator. Goal is PAUSED (not abandoned) pending operator decision.
- When replanning triggers, agent evaluates whether in-progress work is still useful under new plan.
  </action>
  <verify>
`cd /Users/sn0w/Documents/dev/jarvis/apps/agent && npx tsc --noEmit` compiles cleanly. Evaluator and Replanner classes are importable.
  </verify>
  <done>
Evaluator detects divergence via dual detection (metric triggers + LLM evaluation). Replanner evaluates in-progress work, re-decomposes goals, and escalates to operator when replan limit is reached. Operator gets Discord DM on major replans.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create supervisor and result collector</name>
  <files>
    apps/agent/src/multi-agent/supervisor.ts
    apps/agent/src/multi-agent/result-collector.ts
  </files>
  <action>
Create `apps/agent/src/multi-agent/supervisor.ts`:

Export class `Supervisor` with constructor taking:
- `db: DbClient`
- `router: ModelRouter`
- `registry: ToolRegistry`
- `killSwitch: KillCheckable`
- `goalManager: GoalManager`
- `tools: ChatCompletionTool[]`
- `config?: { maxConcurrentMainAgents?: number; staggerDelayMs?: number; subAgentConcurrencyPerGoal?: number }`

State: `activeLoops: Map<number, AgentLoop>` — tracks running agent loops by goalId

Method `spawnMainAgent(goalId: number): Promise<void>`:
- Check concurrency cap (config.maxConcurrentMainAgents, default 5)
  - If at cap, log warning and return (do NOT block — caller can retry later)
- Create new AgentLoop instance for this goal with config
- Store in activeLoops map
- Start `agentLoop.runGoalCycle(goalId)` in background (fire-and-forget with error handler)
- Log spawn to stderr

Method `stopMainAgent(goalId: number): Promise<void>`:
- Remove from activeLoops
- The AgentLoop should check a cancellation flag — add a `cancel()` method on AgentLoop that sets an internal flag checked at each iteration

Method `getActiveAgentCount(): number`:
- Returns activeLoops.size

Method `getActiveGoalIds(): number[]`:
- Returns Array.from(activeLoops.keys())

Method `startSupervisorLoop(): Promise<void>`:
- Periodic loop (every 10 seconds):
  - Query goalManager.getActiveGoals()
  - For each active goal not in activeLoops: spawn a main agent
  - For each goalId in activeLoops not in active goals (completed/paused): stop the main agent
  - MULTI-06: For new goals, let the agent itself decide spawn-vs-inline — this is handled at the LLM level via tool descriptions. The supervisor just starts one main agent per active goal.

Method `staggeredRestart(): Promise<void>` (for crash recovery):
- Get all active goal IDs from DB
- Spawn main agents one at a time with configurable delay between each (config.staggerDelayMs, default 2000)
- Per locked decision: multiple main agents restart in staggered sequence to avoid resource spikes

Create `apps/agent/src/multi-agent/result-collector.ts`:

Export class `ResultCollector` with constructor taking `(queue: Queue)`.

Method `collectResults(jobIds: string[], timeoutMs?: number): Promise<Array<{ jobId: string; success: boolean; result?: unknown; error?: string }>>`:
- Poll all jobIds in parallel (Promise.all)
- For each jobId: check job state, collect result or error
- Timeout after timeoutMs (default 300_000 = 5 min)
- Returns array of results matching input jobIds order

Method `getJobStatus(jobId: string): Promise<{ state: string; progress?: number; result?: unknown; error?: string }>`:
- Get job from queue, return current state and available data
- Used by parent agent to check on sub-agents periodically (locked decision — parent periodically checks in)

MULTI-06 note: The decision of "spawn sub-agent vs execute inline" is made by the LLM during planning. The spawn-agent tool description explicitly says "Use this for tasks that are complex enough to warrant isolated context OR can run in parallel with other work. Do NOT spawn sub-agents for simple, fast tasks — execute those inline." The supervisor does NOT make this decision — it manages the lifecycle of whatever the agent decides to spawn.
  </action>
  <verify>
`cd /Users/sn0w/Documents/dev/jarvis/apps/agent && npx tsc --noEmit` compiles cleanly. Supervisor and ResultCollector are importable.
  </verify>
  <done>
Supervisor manages multiple independent main agent loops with concurrency caps and staggered restart. ResultCollector aggregates sub-agent results for the parent. MULTI-06 spawn-vs-inline decision is handled at the LLM prompt level.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/sn0w/Documents/dev/jarvis && npx turbo build` — monorepo builds
2. Evaluator uses dual detection: metric triggers first, LLM evaluation only if metrics pass
3. Replanner evaluates in-progress work before re-decomposing (locked decision)
4. Replan limit triggers operator escalation via Discord DM (locked decision)
5. Supervisor respects concurrency cap and supports staggered restart
6. ResultCollector can aggregate results from multiple sub-agent jobs
</verification>

<success_criteria>
- Evaluator detects divergence via metric triggers AND LLM evaluation (LOOP-03)
- Replanner keeps useful in-progress work, aborts irrelevant work, re-decomposes goal
- Replan limit per goal with operator escalation (goal paused, not abandoned)
- Supervisor manages concurrent main agents with staggered restart (MULTI-05)
- LLM decides spawn-vs-inline via tool description guidance (MULTI-06)
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-autonomous-loop/03-05-SUMMARY.md`
</output>
