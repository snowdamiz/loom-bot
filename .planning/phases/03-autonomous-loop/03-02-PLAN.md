---
phase: 03-autonomous-loop
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - apps/agent/src/loop/goal-manager.ts
  - apps/agent/src/loop/planner.ts
  - apps/agent/src/loop/agent-loop.ts
autonomous: true
requirements:
  - LOOP-01
  - LOOP-02
  - LOOP-04
  - LOOP-05

must_haves:
  truths:
    - "Agent can set a high-level goal and decompose it into prioritized sub-goals with dependencies"
    - "Agent executes sub-goals by invoking tools through the LLM tool-calling protocol and records outcomes"
    - "Agent runs continuous planning cycles without human intervention"
    - "Agent prioritizes sub-goals based on expected value and dependency ordering"
  artifacts:
    - path: "apps/agent/src/loop/goal-manager.ts"
      provides: "Goal lifecycle management: create, decompose, track status, complete, pause"
      exports: ["GoalManager"]
    - path: "apps/agent/src/loop/planner.ts"
      provides: "LLM planning prompts for goal decomposition and sub-goal generation"
      exports: ["planGoalDecomposition", "planNextAction"]
    - path: "apps/agent/src/loop/agent-loop.ts"
      provides: "Core agentic tool-calling loop: messages -> LLM -> tool_calls -> execute -> repeat"
      exports: ["AgentLoop"]
  key_links:
    - from: "apps/agent/src/loop/agent-loop.ts"
      to: "packages/ai/src/router.ts"
      via: "ModelRouter.completeWithTools for LLM tool-calling"
      pattern: "router\\.completeWithTools"
    - from: "apps/agent/src/loop/agent-loop.ts"
      to: "packages/tools/src/invoke-safe.ts"
      via: "invokeWithKillCheck for tool execution"
      pattern: "invokeWithKillCheck"
    - from: "apps/agent/src/loop/goal-manager.ts"
      to: "packages/db/src/schema/goals.ts"
      via: "Drizzle insert/update/select on goals and subGoals tables"
      pattern: "db\\.(insert|update|select).*goals"
---

<objective>
Build the agent's core autonomous loop — the goal manager that tracks goal lifecycle, the planner that decomposes goals into sub-goals via LLM, and the agentic tool-calling cycle that executes sub-goals by iterating between LLM decisions and tool invocations.

Purpose: This is the beating heart of the autonomous agent. Without it, the agent cannot think, plan, or act.
Output: Three modules (goal-manager, planner, agent-loop) that together enable the agent to set goals, break them down, and execute them tool-by-tool through LLM reasoning.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-autonomous-loop/03-RESEARCH.md
@.planning/phases/03-autonomous-loop/03-01-SUMMARY.md

@packages/ai/src/router.ts
@packages/ai/src/provider.ts
@packages/ai/src/tool-schema.ts
@packages/ai/src/config.ts
@packages/db/src/schema/goals.ts
@packages/db/src/schema/sub-goals.ts
@packages/tools/src/types.ts
@packages/tools/src/registry.ts
@packages/tools/src/invoke-safe.ts
@apps/agent/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GoalManager and LLM planner</name>
  <files>
    apps/agent/src/loop/goal-manager.ts
    apps/agent/src/loop/planner.ts
  </files>
  <action>
Create `apps/agent/src/loop/goal-manager.ts`:
- Export class `GoalManager` with constructor taking `(db: DbClient, router: ModelRouter)`
- Methods:
  - `createGoal(description: string, source: 'operator-injected' | 'agent-discovered', priority?: number): Promise<Goal>` — inserts into goals table, returns the created row
  - `decomposeGoal(goalId: number): Promise<SubGoal[]>` — calls planner.planGoalDecomposition() to get sub-goal list from LLM, inserts all sub-goals into sub_goals table with dependsOn relationships, returns created rows. The LLM response should be parsed via `response_format: { type: 'json_schema' }` or by requesting structured JSON in the system prompt and parsing with JSON.parse
  - `getActiveGoals(): Promise<Goal[]>` — selects goals where status='active', ordered by priority ASC (0=highest)
  - `getSubGoals(goalId: number): Promise<SubGoal[]>` — selects sub_goals for a goal, ordered by priority
  - `getNextSubGoal(goalId: number): Promise<SubGoal | null>` — returns the next actionable sub-goal: status='pending' AND all dependsOn IDs are status='completed'. Order by priority ASC, return first match
  - `updateSubGoalStatus(subGoalId: number, status: string, outcome?: unknown): Promise<void>` — updates sub_goal status and outcome, sets completedAt if status is 'completed' or 'failed'
  - `updateGoalStatus(goalId: number, status: string, pauseReason?: string): Promise<void>` — updates goal status, pauseReason, updatedAt
  - `incrementReplanCount(goalId: number): Promise<number>` — increments replanCount, returns new value
  - `isGoalComplete(goalId: number): Promise<boolean>` — returns true if all sub-goals are completed or skipped

Import goals, subGoals, eq, and from @jarvis/db. Import ModelRouter from @jarvis/ai (or accept via constructor for testability). Import planGoalDecomposition from ./planner.js.

Create `apps/agent/src/loop/planner.ts`:
- Export async function `planGoalDecomposition(router: ModelRouter, goalDescription: string, availableTools: Array<{ name: string; description: string }>): Promise<Array<{ description: string; dependsOn: number[]; priority: number }>>`
  - Builds a system prompt instructing the LLM to decompose the goal into sub-goals
  - System prompt should include: the goal description, available tool names+descriptions, instruction to return JSON array of sub-goals with description/dependsOn/priority fields
  - dependsOn uses 0-based indices into the returned array (resolved to actual IDs after insert)
  - Uses router.complete() with 'strong' tier (goal decomposition is a high-reasoning task)
  - Parses JSON response, validates structure
  - IMPORTANT: Prompt must instruct the LLM to weigh task complexity against spawning overhead (per Anthropic research pitfall — avoid over-decomposition)

- Export async function `planNextAction(router: ModelRouter, subGoalDescription: string, previousResults: unknown[], availableTools: Array<{ name: string; description: string }>): Promise<string>`
  - Builds a system prompt for deciding the next action for a sub-goal
  - Returns the LLM's reasoning/plan text (used as system context in the agent loop)
  - Uses router.complete() with 'mid' tier (action planning is mid-complexity)
  </action>
  <verify>
`cd /Users/sn0w/Documents/dev/jarvis/apps/agent && npx tsc --noEmit` compiles cleanly. GoalManager and planner functions are importable.
  </verify>
  <done>
GoalManager can create goals, decompose them via LLM into sub-goals with dependencies, track sub-goal status, and determine the next actionable sub-goal. Planner generates structured decomposition prompts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create the agentic tool-calling loop</name>
  <files>apps/agent/src/loop/agent-loop.ts</files>
  <action>
Create `apps/agent/src/loop/agent-loop.ts`:
- Export class `AgentLoop` with constructor taking:
  - `router: ModelRouter`
  - `registry: ToolRegistry`
  - `killSwitch: KillCheckable` (duck-typed, same pattern as invoke-safe.ts)
  - `db: DbClient`
  - `goalManager: GoalManager`
  - `tools: ChatCompletionTool[]` (pre-converted OpenAI tool schemas)
  - `config?: { maxTurnsPerSubGoal?: number; cycleSleepMs?: number }`

- Method `executeSubGoal(subGoal: SubGoal): Promise<{ success: boolean; outcome: unknown }>`:
  - Initialize fresh messages array: `ChatCompletionMessageParam[]`
  - Add system message with sub-goal description, constraints, and available tool descriptions
  - Add user message: "Execute this sub-goal: {subGoal.description}"
  - Enter tool-calling loop (max turns from config, default 20):
    - Call `router.completeWithTools(messages, 'strong', tools, { goalId: subGoal.goalId })`
    - Push the returned assistant message onto the messages array (CRITICAL — must be before tool results)
    - Check `finishReason`:
      - `'stop'`: Sub-goal complete. Extract message content as outcome. Break loop.
      - `'tool_calls'`: For each tool_call in `message.tool_calls`:
        - Parse `toolCall.function.arguments` with JSON.parse
        - Call `invokeWithKillCheck(killSwitch, registry, db, toolCall.function.name, parsedArgs)`
        - Push `{ role: 'tool', tool_call_id: toolCall.id, content: JSON.stringify(result) }` onto messages
      - `'length'`: Context window exhausted. Log warning. Return with partial outcome and success=false.
      - `'content_filter'`: Content filtered. Log warning. Return with success=false.
    - If max turns exceeded, return success=false with "max turns exceeded" outcome
  - Update sub-goal status via goalManager based on result

- Method `runGoalCycle(goalId: number): Promise<void>`:
  - Log cycle start via logCycleStart (from @jarvis/logging)
  - Loop: get next actionable sub-goal via goalManager.getNextSubGoal()
  - If no next sub-goal and goal is complete (all sub-goals done): mark goal complete, break
  - If no next sub-goal but goal not complete: all remaining sub-goals are blocked/failed — log warning, break
  - Execute sub-goal via executeSubGoal()
  - Log cycle complete

- Method `runContinuousLoop(): Promise<void>` (LOOP-04):
  - Infinite loop:
    - Get active goals via goalManager.getActiveGoals()
    - For each active goal: run runGoalCycle()
    - Sleep for cycleSleepMs (default 5000ms) between iterations
    - Check kill switch at top of each iteration — if active, sleep and retry

IMPORTANT patterns from research:
- Each sub-goal execution gets a FRESH messages array (no shared state between sub-goals)
- Assistant message with tool_calls MUST be appended before tool result messages (OpenRouter rejects otherwise)
- Handle all finish_reason values exhaustively (stop, tool_calls, length, content_filter)
- Use 'strong' tier for sub-goal execution (complex reasoning with tool use)
  </action>
  <verify>
`cd /Users/sn0w/Documents/dev/jarvis/apps/agent && npx tsc --noEmit` compiles cleanly. AgentLoop class is importable with all three methods.
  </verify>
  <done>
AgentLoop executes sub-goals through the OpenAI tool-calling protocol, running tool_calls -> execute -> append results -> repeat until the LLM signals completion. The continuous loop processes all active goals in priority order without human intervention.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/sn0w/Documents/dev/jarvis && npx turbo build` — monorepo builds
2. AgentLoop.executeSubGoal() correctly handles all finish_reason branches
3. GoalManager.getNextSubGoal() respects dependency ordering (only returns sub-goals whose dependencies are all completed)
4. Messages array is fresh per sub-goal (no context leakage between sub-goals)
5. Assistant message is appended before tool result messages in every tool-calling turn
</verification>

<success_criteria>
- GoalManager creates goals, decomposes via LLM, tracks sub-goal lifecycle
- AgentLoop executes sub-goals through tool-calling protocol with proper message array management
- Continuous loop processes goals in priority order (LOOP-05) without human intervention (LOOP-04)
- All tool invocations go through invokeWithKillCheck (LOOP-02, TOOL-06 compliance)
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-autonomous-loop/03-02-SUMMARY.md`
</output>
